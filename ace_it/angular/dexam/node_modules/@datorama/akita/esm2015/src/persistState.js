/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { filter, skip } from 'rxjs/operators';
import { from, isObservable, of, ReplaySubject } from 'rxjs';
import { isFunction } from './isFunction';
import { AkitaError } from './errors';
import { __stores__ } from './stores';
import { getValue } from './getValueByString';
import { setAction } from './actions';
import { setValue } from './setValueByString';
import { $$addStore, $$deleteStore } from './dispatchers';
import { isNil } from './isNil';
import { isObject } from './isObject';
import { isNotBrowser } from './root';
/** @type {?} */
let skipStorageUpdate = false;
/** @type {?} */
const _persistStateInit = new ReplaySubject(1);
/**
 * @return {?}
 */
export function selectPersistStateInit() {
    return _persistStateInit.asObservable();
}
/**
 * @param {?} skip
 * @return {?}
 */
export function setSkipStorageUpdate(skip) {
    skipStorageUpdate = skip;
}
/**
 * @return {?}
 */
export function getSkipStorageUpdate() {
    return skipStorageUpdate;
}
/**
 * @record
 */
export function PersistStateStorage() { }
if (false) {
    /**
     * @param {?} key
     * @return {?}
     */
    PersistStateStorage.prototype.getItem = function (key) { };
    /**
     * @param {?} key
     * @param {?} value
     * @return {?}
     */
    PersistStateStorage.prototype.setItem = function (key, value) { };
    /**
     * @return {?}
     */
    PersistStateStorage.prototype.clear = function () { };
}
/**
 * @param {?} v
 * @return {?}
 */
function isPromise(v) {
    return v && isFunction(v.then);
}
/**
 * @param {?} asyncOrValue
 * @return {?}
 */
function observify(asyncOrValue) {
    if (isPromise(asyncOrValue) || isObservable(asyncOrValue)) {
        return from(asyncOrValue);
    }
    return of(asyncOrValue);
}
/**
 * @record
 */
export function PersistStateParams() { }
if (false) {
    /**
     * The storage key
     * @type {?}
     */
    PersistStateParams.prototype.key;
    /**
     * Whether to enable persistState in a non-browser environment
     * @type {?}
     */
    PersistStateParams.prototype.enableInNonBrowser;
    /**
     * Storage strategy to use. This defaults to LocalStorage but you can pass SessionStorage or anything that implements the StorageEngine API.
     * @type {?}
     */
    PersistStateParams.prototype.storage;
    /**
     * Custom deserializer. Defaults to JSON.parse
     * @type {?}
     */
    PersistStateParams.prototype.deserialize;
    /**
     * Custom serializer, defaults to JSON.stringify
     * @type {?}
     */
    PersistStateParams.prototype.serialize;
    /**
     * By default the whole state is saved to storage, use this param to include only the stores you need.
     * Pay attention that you can't use both include and exclude
     * @type {?}
     */
    PersistStateParams.prototype.include;
    /**
     *  By default the whole state is saved to storage, use this param to exclude stores that you don't need.
     *  Pay attention that you can't use both include and exclude
     * @type {?}
     */
    PersistStateParams.prototype.exclude;
    /** @type {?} */
    PersistStateParams.prototype.skipStorageUpdate;
    /** @type {?} */
    PersistStateParams.prototype.preStorageUpdateOperator;
    /**
     * Whether to persist a dynamic store upon destroy
     * @type {?}
     */
    PersistStateParams.prototype.persistOnDestroy;
    /**
     * @param {?} storeName
     * @param {?} state
     * @return {?}
     */
    PersistStateParams.prototype.preStorageUpdate = function (storeName, state) { };
    /**
     * @param {?} storeName
     * @param {?} state
     * @return {?}
     */
    PersistStateParams.prototype.preStoreUpdate = function (storeName, state) { };
}
/**
 * @param {?=} params
 * @return {?}
 */
export function persistState(params) {
    /** @type {?} */
    const defaults = {
        key: 'AkitaStores',
        enableInNonBrowser: false,
        storage: typeof localStorage === 'undefined' ? params.storage : localStorage,
        deserialize: JSON.parse,
        serialize: JSON.stringify,
        include: [],
        /**
         * @deprecated use include with a callback
         */
        exclude: [],
        persistOnDestroy: false,
        preStorageUpdate: (/**
         * @param {?} storeName
         * @param {?} state
         * @return {?}
         */
        function (storeName, state) {
            return state;
        }),
        preStoreUpdate: (/**
         * @param {?} storeName
         * @param {?} state
         * @return {?}
         */
        function (storeName, state) {
            return state;
        }),
        skipStorageUpdate: getSkipStorageUpdate,
        preStorageUpdateOperator: (/**
         * @return {?}
         */
        () => (/**
         * @param {?} source
         * @return {?}
         */
        source => source))
    };
    const { storage, enableInNonBrowser, deserialize, serialize, include, exclude, key, preStorageUpdate, persistOnDestroy, preStorageUpdateOperator, preStoreUpdate, skipStorageUpdate } = Object.assign({}, defaults, params);
    if (isNotBrowser && !enableInNonBrowser)
        return;
    /** @type {?} */
    const hasInclude = include.length > 0;
    /** @type {?} */
    const hasExclude = exclude.length > 0;
    /** @type {?} */
    let includeStores;
    if (hasInclude && hasExclude) {
        throw new AkitaError("You can't use both include and exclude");
    }
    if (hasInclude) {
        includeStores = include.reduce((/**
         * @param {?} acc
         * @param {?} path
         * @return {?}
         */
        (acc, path) => {
            if (isFunction(path)) {
                acc.fns.push(path);
            }
            else {
                /** @type {?} */
                const storeName = path.split('.')[0];
                acc[storeName] = path;
            }
            return acc;
        }), { fns: [] });
    }
    /** @type {?} */
    let stores = {};
    /** @type {?} */
    let acc = {};
    /** @type {?} */
    let subscriptions = [];
    /** @type {?} */
    const buffer = [];
    /**
     * @param {?} v
     * @return {?}
     */
    function _save(v) {
        observify(v).subscribe((/**
         * @return {?}
         */
        () => {
            /** @type {?} */
            const next = buffer.shift();
            next && _save(next);
        }));
    }
    // when we use the local/session storage we perform the serialize, otherwise we let the passed storage implementation to do it
    /** @type {?} */
    const isLocalStorage = typeof localStorage !== 'undefined' && (storage === localStorage || storage === sessionStorage);
    observify(storage.getItem(key)).subscribe((/**
     * @param {?} value
     * @return {?}
     */
    (value) => {
        /** @type {?} */
        let storageState = isObject(value) ? value : deserialize(value || '{}');
        /**
         * @param {?} storeCache
         * @return {?}
         */
        function save(storeCache) {
            storageState['$cache'] = Object.assign({}, (storageState['$cache'] || {}), storeCache);
            storageState = Object.assign({}, storageState, acc);
            buffer.push(storage.setItem(key, isLocalStorage ? serialize(storageState) : storageState));
            _save(buffer.shift());
        }
        /**
         * @param {?} storeName
         * @param {?} path
         * @return {?}
         */
        function subscribe(storeName, path) {
            stores[storeName] = __stores__[storeName]
                ._select((/**
             * @param {?} state
             * @return {?}
             */
            state => getValue(state, path)))
                .pipe(skip(1), filter((/**
             * @return {?}
             */
            () => skipStorageUpdate() === false)), preStorageUpdateOperator())
                .subscribe((/**
             * @param {?} data
             * @return {?}
             */
            data => {
                acc[storeName] = preStorageUpdate(storeName, data);
                Promise.resolve().then((/**
                 * @return {?}
                 */
                () => save({ [storeName]: __stores__[storeName]._cache().getValue() })));
            }));
        }
        /**
         * @param {?} storeName
         * @param {?} store
         * @param {?} path
         * @return {?}
         */
        function setInitial(storeName, store, path) {
            if (storeName in storageState) {
                setAction('@PersistState');
                store._setState((/**
                 * @param {?} state
                 * @return {?}
                 */
                state => {
                    return setValue(state, path, preStoreUpdate(storeName, storageState[storeName]));
                }));
                /** @type {?} */
                const hasCache = storageState['$cache'] ? storageState['$cache'][storeName] : false;
                __stores__[storeName].setHasCache(hasCache, { restartTTL: true });
            }
        }
        subscriptions.push($$deleteStore.subscribe((/**
         * @param {?} storeName
         * @return {?}
         */
        storeName => {
            if (stores[storeName]) {
                if (persistOnDestroy === false) {
                    save({ [storeName]: false });
                }
                stores[storeName].unsubscribe();
                delete stores[storeName];
            }
        })));
        subscriptions.push($$addStore.subscribe((/**
         * @param {?} storeName
         * @return {?}
         */
        storeName => {
            if (storeName === 'router' || (hasExclude && exclude.includes(storeName))) {
                return;
            }
            /** @type {?} */
            const store = __stores__[storeName];
            if (hasInclude) {
                /** @type {?} */
                let path = includeStores[storeName];
                if (!path) {
                    /** @type {?} */
                    const passPredicate = includeStores.fns.some((/**
                     * @param {?} fn
                     * @return {?}
                     */
                    fn => fn(storeName)));
                    if (passPredicate) {
                        path = storeName;
                    }
                    else {
                        return;
                    }
                }
                setInitial(storeName, store, path);
                subscribe(storeName, path);
            }
            else {
                setInitial(storeName, store, storeName);
                subscribe(storeName, storeName);
            }
        })));
        _persistStateInit.next();
    }));
    return {
        /**
         * @return {?}
         */
        destroy() {
            subscriptions.forEach((/**
             * @param {?} s
             * @return {?}
             */
            s => s.unsubscribe()));
            for (let i = 0, keys = Object.keys(stores); i < keys.length; i++) {
                /** @type {?} */
                const storeName = keys[i];
                stores[storeName].unsubscribe();
            }
            stores = {};
        },
        /**
         * @return {?}
         */
        clear() {
            storage.clear();
        },
        /**
         * @param {?=} storeName
         * @return {?}
         */
        clearStore(storeName) {
            if (isNil(storeName)) {
                /** @type {?} */
                const value = observify(storage.setItem(key, '{}'));
                value.subscribe();
                return;
            }
            /** @type {?} */
            const value = storage.getItem(key);
            observify(value).subscribe((/**
             * @param {?} v
             * @return {?}
             */
            v => {
                /** @type {?} */
                const storageState = deserialize(v || '{}');
                if (storageState[storeName]) {
                    delete storageState[storeName];
                    /** @type {?} */
                    const value = observify(storage.setItem(key, serialize(storageState)));
                    value.subscribe();
                }
            }));
        }
    };
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicGVyc2lzdFN0YXRlLmpzIiwic291cmNlUm9vdCI6Im5nOi8vQGRhdG9yYW1hL2FraXRhLyIsInNvdXJjZXMiOlsic3JjL3BlcnNpc3RTdGF0ZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7O0FBQUEsT0FBTyxFQUFFLE1BQU0sRUFBRSxJQUFJLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQztBQUM5QyxPQUFPLEVBQUUsSUFBSSxFQUFFLFlBQVksRUFBRSxFQUFFLEVBQW9CLGFBQWEsRUFBZ0IsTUFBTSxNQUFNLENBQUM7QUFFN0YsT0FBTyxFQUFFLFVBQVUsRUFBRSxNQUFNLGNBQWMsQ0FBQztBQUMxQyxPQUFPLEVBQUUsVUFBVSxFQUFFLE1BQU0sVUFBVSxDQUFDO0FBQ3RDLE9BQU8sRUFBRSxVQUFVLEVBQUUsTUFBTSxVQUFVLENBQUM7QUFDdEMsT0FBTyxFQUFFLFFBQVEsRUFBRSxNQUFNLG9CQUFvQixDQUFDO0FBQzlDLE9BQU8sRUFBRSxTQUFTLEVBQUUsTUFBTSxXQUFXLENBQUM7QUFDdEMsT0FBTyxFQUFFLFFBQVEsRUFBRSxNQUFNLG9CQUFvQixDQUFDO0FBQzlDLE9BQU8sRUFBRSxVQUFVLEVBQUUsYUFBYSxFQUFFLE1BQU0sZUFBZSxDQUFDO0FBQzFELE9BQU8sRUFBRSxLQUFLLEVBQUUsTUFBTSxTQUFTLENBQUM7QUFDaEMsT0FBTyxFQUFFLFFBQVEsRUFBRSxNQUFNLFlBQVksQ0FBQztBQUN0QyxPQUFPLEVBQUUsWUFBWSxFQUFFLE1BQU0sUUFBUSxDQUFDOztJQUVsQyxpQkFBaUIsR0FBRyxLQUFLOztNQUV2QixpQkFBaUIsR0FBRyxJQUFJLGFBQWEsQ0FBQyxDQUFDLENBQUM7Ozs7QUFFOUMsTUFBTSxVQUFVLHNCQUFzQjtJQUNwQyxPQUFPLGlCQUFpQixDQUFDLFlBQVksRUFBRSxDQUFDO0FBQzFDLENBQUM7Ozs7O0FBRUQsTUFBTSxVQUFVLG9CQUFvQixDQUFDLElBQWE7SUFDaEQsaUJBQWlCLEdBQUcsSUFBSSxDQUFDO0FBQzNCLENB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QUM7UUFDZCxDQUFDOzs7O1FBQ0QsS0FBSztZQUNILE9BQU8sQ0FBQyxLQUFLLEVBQUUsQ0FBQztRQUNsQixDQUFDOzs7OztRQUNELFVBQVUsQ0FBQyxTQUFrQjtZQUMzQixJQUFJLEtBQUssQ0FBQyxTQUFTLENBQUMsRUFBRTs7c0JBQ2QsS0FBSyxHQUFHLFNBQVMsQ0FBQyxPQUFPLENBQUMsT0FBTyxDQUFDLEdBQUcsRUFBRSxJQUFJLENBQUMsQ0FBQztnQkFDbkQsS0FBSyxDQUFDLFNBQVMsRUFBRSxDQUFDO2dCQUNsQixPQUFPO2FBQ1I7O2tCQUNLLEtBQUssR0FBRyxPQUFPLENBQUMsT0FBTyxDQUFDLEdBQUcsQ0FBQztZQUNsQyxTQUFTLENBQUMsS0FBSyxDQUFDLENBQUMsU0FBUzs7OztZQUFDLENBQUMsQ0FBQyxFQUFFOztzQkFDdkIsWUFBWSxHQUFHLFdBQVcsQ0FBQyxDQUFDLElBQUksSUFBSSxDQUFDO2dCQUUzQyxJQUFJLFlBQVksQ0FBQyxTQUFTLENBQUMsRUFBRTtvQkFDM0IsT0FBTyxZQUFZLENBQUMsU0FBUyxDQUFDLENBQUM7OzBCQUN6QixLQUFLLEdBQUcsU0FBUyxDQUFDLE9BQU8sQ0FBQyxPQUFPLENBQUMsR0FBRyxFQUFFLFNBQVMsQ0FBQyxZQUFZLENBQUMsQ0FBQyxDQUFDO29CQUN0RSxLQUFLLENBQUMsU0FBUyxFQUFFLENBQUM7aUJBQ25CO1lBQ0gsQ0FBQyxFQUFDLENBQUM7UUFDTCxDQUFDO0tBQ0YsQ0FBQztBQUNKLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBmaWx0ZXIsIHNraXAgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5pbXBvcnQgeyBmcm9tLCBpc09ic2VydmFibGUsIG9mLCBPcGVyYXRvckZ1bmN0aW9uLCBSZXBsYXlTdWJqZWN0LCBTdWJzY3JpcHRpb24gfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IEhhc2hNYXAsIE1heWJlQXN5bmMgfSBmcm9tICcuL3R5cGVzJztcbmltcG9ydCB7IGlzRnVuY3Rpb24gfSBmcm9tICcuL2lzRnVuY3Rpb24nO1xuaW1wb3J0IHsgQWtpdGFFcnJvciB9IGZyb20gJy4vZXJyb3JzJztcbmltcG9ydCB7IF9fc3RvcmVzX18gfSBmcm9tICcuL3N0b3Jlcyc7XG5pbXBvcnQgeyBnZXRWYWx1ZSB9IGZyb20gJy4vZ2V0VmFsdWVCeVN0cmluZyc7XG5pbXBvcnQgeyBzZXRBY3Rpb24gfSBmcm9tICcuL2FjdGlvbnMnO1xuaW1wb3J0IHsgc2V0VmFsdWUgfSBmcm9tICcuL3NldFZhbHVlQnlTdHJpbmcnO1xuaW1wb3J0IHsgJCRhZGRTdG9yZSwgJCRkZWxldGVTdG9yZSB9IGZyb20gJy4vZGlzcGF0Y2hlcnMnO1xuaW1wb3J0IHsgaXNOaWwgfSBmcm9tICcuL2lzTmlsJztcbmltcG9ydCB7IGlzT2JqZWN0IH0gZnJvbSAnLi9pc09iamVjdCc7XG5pbXBvcnQgeyBpc05vdEJyb3dzZXIgfSBmcm9tICcuL3Jvb3QnO1xuXG5sZXQgc2tpcFN0b3JhZ2VVcGRhdGUgPSBmYWxzZTtcblxuY29uc3QgX3BlcnNpc3RTdGF0ZUluaXQgPSBuZXcgUmVwbGF5U3ViamVjdCgxKTtcblxuZXhwb3J0IGZ1bmN0aW9uIHNlbGVjdFBlcnNpc3RTdGF0ZUluaXQoKSB7XG4gIHJldHVybiBfcGVyc2lzdFN0YXRlSW5pdC5hc09ic2VydmFibGUoKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNldFNraXBTdG9yYWdlVXBkYXRlKHNraXA6IGJvb2xlYW4pIHtcbiAgc2tpcFN0b3JhZ2VVcGRhdGUgPSBza2lwO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0U2tpcFN0b3JhZ2VVcGRhdGUoKSB7XG4gIHJldHVybiBza2lwU3RvcmFnZVVwZGF0ZTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBQZXJzaXN0U3RhdGVTdG9yYWdlIHtcbiAgZ2V0SXRlbShrZXk6IHN0cmluZyk6IE1heWJlQXN5bmM7XG5cbiAgc2V0SXRlbShrZXk6IHN0cmluZywgdmFsdWU6IGFueSk6IE1heWJlQXN5bmM7XG5cbiAgY2xlYXIoKTogdm9pZDtcbn1cblxuZnVuY3Rpb24gaXNQcm9taXNlKHY6IGFueSkge1xuICByZXR1cm4gdiAmJiBpc0Z1bmN0aW9uKHYudGhlbik7XG59XG5cbmZ1bmN0aW9uIG9ic2VydmlmeShhc3luY09yVmFsdWU6IGFueSkge1xuICBpZiAoaXNQcm9taXNlKGFzeW5jT3JWYWx1ZSkgfHwgaXNPYnNlcnZhYmxlKGFzeW5jT3JWYWx1ZSkpIHtcbiAgICByZXR1cm4gZnJvbShhc3luY09yVmFsdWUpO1xuICB9XG5cbiAgcmV0dXJuIG9mKGFzeW5jT3JWYWx1ZSk7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUGVyc2lzdFN0YXRlUGFyYW1zIHtcbiAgLyoqIFRoZSBzdG9yYWdlIGtleSAqL1xuICBrZXk6IHN0cmluZztcbiAgLyoqIFdoZXRoZXIgdG8gZW5hYmxlIHBlcnNpc3RTdGF0ZSBpbiBhIG5vbi1icm93c2VyIGVudmlyb25tZW50ICovXG4gIGVuYWJsZUluTm9uQnJvd3NlcjogYm9vbGVhbjtcbiAgLyoqIFN0b3JhZ2Ugc3RyYXRlZ3kgdG8gdXNlLiBUaGlzIGRlZmF1bHRzIHRvIExvY2FsU3RvcmFnZSBidXQgeW91IGNhbiBwYXNzIFNlc3Npb25TdG9yYWdlIG9yIGFueXRoaW5nIHRoYXQgaW1wbGVtZW50cyB0aGUgU3RvcmFnZUVuZ2luZSBBUEkuICovXG4gIHN0b3JhZ2U6IFBlcnNpc3RTdGF0ZVN0b3JhZ2U7XG4gIC8qKiBDdXN0b20gZGVzZXJpYWxpemVyLiBEZWZhdWx0cyB0byBKU09OLnBhcnNlICovXG4gIGRlc2VyaWFsaXplOiBGdW5jdGlvbjtcbiAgLyoqIEN1c3RvbSBzZXJpYWxpemVyLCBkZWZhdWx0cyB0byBKU09OLnN0cmluZ2lmeSAqL1xuICBzZXJpYWxpemU6IEZ1bmN0aW9uO1xuICAvKipcbiAgICogQnkgZGVmYXVsdCB0aGUgd2hvbGUgc3RhdGUgaXMgc2F2ZWQgdG8gc3RvcmFnZSwgdXNlIHRoaXMgcGFyYW0gdG8gaW5jbHVkZSBvbmx5IHRoZSBzdG9yZXMgeW91IG5lZWQuXG4gICAqIFBheSBhdHRlbnRpb24gdGhhdCB5b3UgY2FuJ3QgdXNlIGJvdGggaW5jbHVkZSBhbmQgZXhjbHVkZVxuICAgKi9cbiAgaW5jbHVkZTogKHN0cmluZyB8ICgoc3RvcmVOYW1lOiBzdHJpbmcpID0+IGJvb2xlYW4pKVtdO1xuICAvKipcbiAgICogIEJ5IGRlZmF1bHQgdGhlIHdob2xlIHN0YXRlIGlzIHNhdmVkIHRvIHN0b3JhZ2UsIHVzZSB0aGlzIHBhcmFtIHRvIGV4Y2x1ZGUgc3RvcmVzIHRoYXQgeW91IGRvbid0IG5lZWQuXG4gICAqICBQYXkgYXR0ZW50aW9uIHRoYXQgeW91IGNhbid0IHVzZSBib3RoIGluY2x1ZGUgYW5kIGV4Y2x1ZGVcbiAgICovXG4gIGV4Y2x1ZGU6IHN0cmluZ1tdO1xuXG4gIHByZVN0b3JhZ2VVcGRhdGUoc3RvcmVOYW1lOiBzdHJpbmcsIHN0YXRlOiBhbnkpOiBhbnk7XG5cbiAgcHJlU3RvcmVVcGRhdGUoc3RvcmVOYW1lOiBzdHJpbmcsIHN0YXRlOiBhbnkpOiBhbnk7XG5cbiAgc2tpcFN0b3JhZ2VVcGRhdGU6ICgpID0+IGJvb2xlYW47XG4gIHByZVN0b3JhZ2VVcGRhdGVPcGVyYXRvcjogKCkgPT4gT3BlcmF0b3JGdW5jdGlvbjxhbnksIGFueT47XG4gIC8qKiBXaGV0aGVyIHRvIHBlcnNpc3QgYSBkeW5hbWljIHN0b3JlIHVwb24gZGVzdHJveSAqL1xuICBwZXJzaXN0T25EZXN0cm95OiBib29sZWFuO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcGVyc2lzdFN0YXRlKHBhcmFtcz86IFBhcnRpYWw8UGVyc2lzdFN0YXRlUGFyYW1zPikge1xuICBjb25zdCBkZWZhdWx0czogUGVyc2lzdFN0YXRlUGFyYW1zID0ge1xuICAgIGtleTogJ0FraXRhU3RvcmVzJyxcbiAgICBlbmFibGVJbk5vbkJyb3dzZXI6IGZhbHNlLFxuICAgIHN0b3JhZ2U6IHR5cGVvZiBsb2NhbFN0b3JhZ2UgPT09ICd1bmRlZmluZWQnID8gcGFyYW1zLnN0b3JhZ2UgOiBsb2NhbFN0b3JhZ2UsXG4gICAgZGVzZXJpYWxpemU6IEpTT04ucGFyc2UsXG4gICAgc2VyaWFsaXplOiBKU09OLnN0cmluZ2lmeSxcbiAgICBpbmNsdWRlOiBbXSxcbiAgICAvKipcbiAgICAgKiBAZGVwcmVjYXRlZCB1c2UgaW5jbHVkZSB3aXRoIGEgY2FsbGJhY2tcbiAgICAgKi9cbiAgICBleGNsdWRlOiBbXSxcbiAgICBwZXJzaXN0T25EZXN0cm95OiBmYWxzZSxcbiAgICBwcmVTdG9yYWdlVXBkYXRlOiBmdW5jdGlvbihzdG9yZU5hbWUsIHN0YXRlKSB7XG4gICAgICByZXR1cm4gc3RhdGU7XG4gICAgfSxcbiAgICBwcmVTdG9yZVVwZGF0ZTogZnVuY3Rpb24oc3RvcmVOYW1lLCBzdGF0ZSkge1xuICAgICAgcmV0dXJuIHN0YXRlO1xuICAgIH0sXG4gICAgc2tpcFN0b3JhZ2VVcGRhdGU6IGdldFNraXBTdG9yYWdlVXBkYXRlLFxuICAgIHByZVN0b3JhZ2VVcGRhdGVPcGVyYXRvcjogKCkgPT4gc291cmNlID0+IHNvdXJjZVxuICB9O1xuXG4gIGNvbnN0IHsgc3RvcmFnZSwgZW5hYmxlSW5Ob25Ccm93c2VyLCBkZXNlcmlhbGl6ZSwgc2VyaWFsaXplLCBpbmNsdWRlLCBleGNsdWRlLCBrZXksIHByZVN0b3JhZ2VVcGRhdGUsIHBlcnNpc3RPbkRlc3Ryb3ksIHByZVN0b3JhZ2VVcGRhdGVPcGVyYXRvciwgcHJlU3RvcmVVcGRhdGUsIHNraXBTdG9yYWdlVXBkYXRlIH0gPSBPYmplY3QuYXNzaWduKFxuICAgIHt9LFxuICAgIGRlZmF1bHRzLFxuICAgIHBhcmFtc1xuICApO1xuXG4gIGlmIChpc05vdEJyb3dzZXIgJiYgIWVuYWJsZUluTm9uQnJvd3NlcikgcmV0dXJuO1xuXG4gIGNvbnN0IGhhc0luY2x1ZGUgPSBpbmNsdWRlLmxlbmd0aCA+IDA7XG4gIGNvbnN0IGhhc0V4Y2x1ZGUgPSBleGNsdWRlLmxlbmd0aCA+IDA7XG4gIGxldCBpbmNsdWRlU3RvcmVzOiB7IGZuczogRnVuY3Rpb25bXTsgW2tleTogc3RyaW5nXTogRnVuY3Rpb25bXSB8IHN0cmluZyB9O1xuXG4gIGlmIChoYXNJbmNsdWRlICYmIGhhc0V4Y2x1ZGUpIHtcbiAgICB0aHJvdyBuZXcgQWtpdGFFcnJvcihcIllvdSBjYW4ndCB1c2UgYm90aCBpbmNsdWRlIGFuZCBleGNsdWRlXCIpO1xuICB9XG5cbiAgaWYgKGhhc0luY2x1ZGUpIHtcbiAgICBpbmNsdWRlU3RvcmVzID0gaW5jbHVkZS5yZWR1Y2UoXG4gICAgICAoYWNjLCBwYXRoKSA9PiB7XG4gICAgICAgIGlmIChpc0Z1bmN0aW9uKHBhdGgpKSB7XG4gICAgICAgICAgYWNjLmZucy5wdXNoKHBhdGgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnN0IHN0b3JlTmFtZSA9IHBhdGguc3BsaXQoJy4nKVswXTtcbiAgICAgICAgICBhY2Nbc3RvcmVOYW1lXSA9IHBhdGg7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgIH0sXG4gICAgICB7IGZuczogW10gfVxuICAgICk7XG4gIH1cblxuICBsZXQgc3RvcmVzOiBIYXNoTWFwPFN1YnNjcmlwdGlvbj4gPSB7fTtcbiAgbGV0IGFjYyA9IHt9O1xuICBsZXQgc3Vic2NyaXB0aW9uczogU3Vic2NyaXB0aW9uW10gPSBbXTtcblxuICBjb25zdCBidWZmZXIgPSBbXTtcblxuICBmdW5jdGlvbiBfc2F2ZSh2OiBhbnkpIHtcbiAgICBvYnNlcnZpZnkodikuc3Vic2NyaWJlKCgpID0+IHtcbiAgICAgIGNvbnN0IG5leHQgPSBidWZmZXIuc2hpZnQoKTtcbiAgICAgIG5leHQgJiYgX3NhdmUobmV4dCk7XG4gICAgfSk7XG4gIH1cblxuICAvLyB3aGVuIHdlIHVzZSB0aGUgbG9jYWwvc2Vzc2lvbiBzdG9yYWdlIHdlIHBlcmZvcm0gdGhlIHNlcmlhbGl6ZSwgb3RoZXJ3aXNlIHdlIGxldCB0aGUgcGFzc2VkIHN0b3JhZ2UgaW1wbGVtZW50YXRpb24gdG8gZG8gaXRcbiAgY29uc3QgaXNMb2NhbFN0b3JhZ2UgPSB0eXBlb2YgbG9jYWxTdG9yYWdlICE9PSAndW5kZWZpbmVkJyAmJiAoc3RvcmFnZSA9PT0gbG9jYWxTdG9yYWdlIHx8IHN0b3JhZ2UgPT09IHNlc3Npb25TdG9yYWdlKTtcblxuICBvYnNlcnZpZnkoc3RvcmFnZS5nZXRJdGVtKGtleSkpLnN1YnNjcmliZSgodmFsdWU6IGFueSkgPT4ge1xuICAgIGxldCBzdG9yYWdlU3RhdGUgPSBpc09iamVjdCh2YWx1ZSkgPyB2YWx1ZSA6IGRlc2VyaWFsaXplKHZhbHVlIHx8ICd7fScpO1xuXG4gICAgZnVuY3Rpb24gc2F2ZShzdG9yZUNhY2hlKSB7XG4gICAgICBzdG9yYWdlU3RhdGVbJyRjYWNoZSddID0geyAuLi4oc3RvcmFnZVN0YXRlWyckY2FjaGUnXSB8fCB7fSksIC4uLnN0b3JlQ2FjaGUgfTtcbiAgICAgIHN0b3JhZ2VTdGF0ZSA9IE9iamVjdC5hc3NpZ24oe30sIHN0b3JhZ2VTdGF0ZSwgYWNjKTtcblxuICAgICAgYnVmZmVyLnB1c2goc3RvcmFnZS5zZXRJdGVtKGtleSwgaXNMb2NhbFN0b3JhZ2UgPyBzZXJpYWxpemUoc3RvcmFnZVN0YXRlKSA6IHN0b3JhZ2VTdGF0ZSkpO1xuICAgICAgX3NhdmUoYnVmZmVyLnNoaWZ0KCkpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHN1YnNjcmliZShzdG9yZU5hbWUsIHBhdGgpIHtcbiAgICAgIHN0b3Jlc1tzdG9yZU5hbWVdID0gX19zdG9yZXNfX1tzdG9yZU5hbWVdXG4gICAgICAgIC5fc2VsZWN0KHN0YXRlID0+IGdldFZhbHVlKHN0YXRlLCBwYXRoKSlcbiAgICAgICAgLnBpcGUoXG4gICAgICAgICAgc2tpcCgxKSxcbiAgICAgICAgICBmaWx0ZXIoKCkgPT4gc2tpcFN0b3JhZ2VVcGRhdGUoKSA9PT0gZmFsc2UpLFxuICAgICAgICAgIHByZVN0b3JhZ2VVcGRhdGVPcGVyYXRvcigpXG4gICAgICAgIClcbiAgICAgICAgLnN1YnNjcmliZShkYXRhID0+IHtcbiAgICAgICAgICBhY2Nbc3RvcmVOYW1lXSA9IHByZVN0b3JhZ2VVcGRhdGUoc3RvcmVOYW1lLCBkYXRhKTtcbiAgICAgICAgICBQcm9taXNlLnJlc29sdmUoKS50aGVuKCgpID0+IHNhdmUoeyBbc3RvcmVOYW1lXTogX19zdG9yZXNfX1tzdG9yZU5hbWVdLl9jYWNoZSgpLmdldFZhbHVlKCkgfSkpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzZXRJbml0aWFsKHN0b3JlTmFtZSwgc3RvcmUsIHBhdGgpIHtcbiAgICAgIGlmIChzdG9yZU5hbWUgaW4gc3RvcmFnZVN0YXRlKSB7XG4gICAgICAgIHNldEFjdGlvbignQFBlcnNpc3RTdGF0ZScpO1xuICAgICAgICBzdG9yZS5fc2V0U3RhdGUoc3RhdGUgPT4ge1xuICAgICAgICAgIHJldHVybiBzZXRWYWx1ZShzdGF0ZSwgcGF0aCwgcHJlU3RvcmVVcGRhdGUoc3RvcmVOYW1lLCBzdG9yYWdlU3RhdGVbc3RvcmVOYW1lXSkpO1xuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgaGFzQ2FjaGUgPSBzdG9yYWdlU3RhdGVbJyRjYWNoZSddID8gc3RvcmFnZVN0YXRlWyckY2FjaGUnXVtzdG9yZU5hbWVdIDogZmFsc2U7XG4gICAgICAgIF9fc3RvcmVzX19bc3RvcmVOYW1lXS5zZXRIYXNDYWNoZShoYXNDYWNoZSwgeyByZXN0YXJ0VFRMOiB0cnVlIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHN1YnNjcmlwdGlvbnMucHVzaChcbiAgICAgICQkZGVsZXRlU3RvcmUuc3Vic2NyaWJlKHN0b3JlTmFtZSA9PiB7XG4gICAgICAgIGlmIChzdG9yZXNbc3RvcmVOYW1lXSkge1xuICAgICAgICAgIGlmIChwZXJzaXN0T25EZXN0cm95ID09PSBmYWxzZSkge1xuICAgICAgICAgICAgc2F2ZSh7IFtzdG9yZU5hbWVdOiBmYWxzZSB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgc3RvcmVzW3N0b3JlTmFtZV0udW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICBkZWxldGUgc3RvcmVzW3N0b3JlTmFtZV07XG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgKTtcblxuICAgIHN1YnNjcmlwdGlvbnMucHVzaChcbiAgICAgICQkYWRkU3RvcmUuc3Vic2NyaWJlKHN0b3JlTmFtZSA9PiB7XG4gICAgICAgIGlmIChzdG9yZU5hbWUgPT09ICdyb3V0ZXInIHx8IChoYXNFeGNsdWRlICYmIGV4Y2x1ZGUuaW5jbHVkZXMoc3RvcmVOYW1lKSkpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBzdG9yZSA9IF9fc3RvcmVzX19bc3RvcmVOYW1lXTtcbiAgICAgICAgaWYgKGhhc0luY2x1ZGUpIHtcbiAgICAgICAgICBsZXQgcGF0aCA9IGluY2x1ZGVTdG9yZXNbc3RvcmVOYW1lXTtcblxuICAgICAgICAgIGlmICghcGF0aCkge1xuICAgICAgICAgICAgY29uc3QgcGFzc1ByZWRpY2F0ZSA9IGluY2x1ZGVTdG9yZXMuZm5zLnNvbWUoZm4gPT4gZm4oc3RvcmVOYW1lKSk7XG4gICAgICAgICAgICBpZiAocGFzc1ByZWRpY2F0ZSkge1xuICAgICAgICAgICAgICBwYXRoID0gc3RvcmVOYW1lO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBzZXRJbml0aWFsKHN0b3JlTmFtZSwgc3RvcmUsIHBhdGgpO1xuICAgICAgICAgIHN1YnNjcmliZShzdG9yZU5hbWUsIHBhdGgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNldEluaXRpYWwoc3RvcmVOYW1lLCBzdG9yZSwgc3RvcmVOYW1lKTtcbiAgICAgICAgICBzdWJzY3JpYmUoc3RvcmVOYW1lLCBzdG9yZU5hbWUpO1xuICAgICAgICB9XG4gICAgICB9KVxuICAgICk7XG5cbiAgICBfcGVyc2lzdFN0YXRlSW5pdC5uZXh0KCk7XG4gIH0pO1xuXG4gIHJldHVybiB7XG4gICAgZGVzdHJveSgpIHtcbiAgICAgIHN1YnNjcmlwdGlvbnMuZm9yRWFjaChzID0+IHMudW5zdWJzY3JpYmUoKSk7XG4gICAgICBmb3IgKGxldCBpID0gMCwga2V5cyA9IE9iamVjdC5rZXlzKHN0b3Jlcyk7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IHN0b3JlTmFtZSA9IGtleXNbaV07XG4gICAgICAgIHN0b3Jlc1tzdG9yZU5hbWVdLnVuc3Vic2NyaWJlKCk7XG4gICAgICB9XG4gICAgICBzdG9yZXMgPSB7fTtcbiAgICB9LFxuICAgIGNsZWFyKCkge1xuICAgICAgc3RvcmFnZS5jbGVhcigpO1xuICAgIH0sXG4gICAgY2xlYXJTdG9yZShzdG9yZU5hbWU/OiBzdHJpbmcpIHtcbiAgICAgIGlmIChpc05pbChzdG9yZU5hbWUpKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gb2JzZXJ2aWZ5KHN0b3JhZ2Uuc2V0SXRlbShrZXksICd7fScpKTtcbiAgICAgICAgdmFsdWUuc3Vic2NyaWJlKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHZhbHVlID0gc3RvcmFnZS5nZXRJdGVtKGtleSk7XG4gICAgICBvYnNlcnZpZnkodmFsdWUpLnN1YnNjcmliZSh2ID0+IHtcbiAgICAgICAgY29uc3Qgc3RvcmFnZVN0YXRlID0gZGVzZXJpYWxpemUodiB8fCAne30nKTtcblxuICAgICAgICBpZiAoc3RvcmFnZVN0YXRlW3N0b3JlTmFtZV0pIHtcbiAgICAgICAgICBkZWxldGUgc3RvcmFnZVN0YXRlW3N0b3JlTmFtZV07XG4gICAgICAgICAgY29uc3QgdmFsdWUgPSBvYnNlcnZpZnkoc3RvcmFnZS5zZXRJdGVtKGtleSwgc2VyaWFsaXplKHN0b3JhZ2VTdGF0ZSkpKTtcbiAgICAgICAgICB2YWx1ZS5zdWJzY3JpYmUoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9O1xufVxuIl19