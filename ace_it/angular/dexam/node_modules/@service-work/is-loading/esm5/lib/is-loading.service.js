/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { Injectable } from '@angular/core';
import { BehaviorSubject, Subscription, Observable } from 'rxjs';
import { distinctUntilChanged, debounceTime, take } from 'rxjs/operators';
import * as i0 from "@angular/core";
/**
 * @record
 */
export function IGetLoadingOptions() { }
if (false) {
    /** @type {?|undefined} */
    IGetLoadingOptions.prototype.key;
}
/**
 * @record
 */
export function IUpdateLoadingOptions() { }
if (false) {
    /** @type {?|undefined} */
    IUpdateLoadingOptions.prototype.key;
}
var IsLoadingService = /** @class */ (function () {
    function IsLoadingService() {
        this.defaultKey = 'default';
        // provides an observable indicating if a particular key is loading
        this.loadingSubjects = new Map();
        // tracks how many "things" are loading for each key
        this.loadingStacks = new Map();
        // tracks which keys are being watched so that unused keys
        // can be deleted/garbage collected.
        this.loadingKeyIndex = new Map();
    }
    /**
     * Used to determine if something is loading or not.
     *
     * When called without arguments, returns the default *isLoading*
     * observable for your app. When called with an options object
     * containing a `key` property, returns the *isLoading* observable
     * corresponding to that key.
     *
     * Internally, *isLoading* observables are `BehaviorSubject`s, so
     * they will return values immediately upon subscription.
     *
     * When called, this method creates a new observable and returns it.
     * This means that you should not use this method directly in an Angular
     * template because each time the method is called it will look
     * (to Angular change detection) like the value has changed. To make
     * subscribing in templates easier, check out the `IsLoadingPipe`.
     * Alternatively, store the observable returned from this method in
     * a variable on your component and use that variable inside your
     * template.
     *
     * Example:
     *
     * ```ts
     *  class MyCustomComponent implements OnInit {
     *    variableForUseInTemplate: Observable<boolean>;
     *
     *    constructor(private loadingService: IsLoadingService) {}
     *
     *    ngOnInit() {
     *      this.variableForUseInTemplate =
     *        this.loadingService.isLoading$({key: 'button'});
     *
     *      this.loadingService.isLoading$().subscribe(value => {
     *        // ... do stuff
     *      });
     *
     *      this.loadingService
     *        .isLoading$({key: MyCustomComponent})
     *        .subscribe(value => {
     *          // ... do stuff
     *        });
     *    }
     *  }
     * ```
     *
     * @param args.key optionally specify the key to subscribe to
     */
    /**
     * Used to determine if something is loading or not.
     *
     * When called without arguments, returns the default *isLoading*
     * observable for your app. When called with an options object
     * containing a `key` property, returns the *isLoading* observable
     * corresponding to that key.
     *
     * Internally, *isLoading* observables are `BehaviorSubject`s, so
     * they will return values immediately upon subscription.
     *
     * When called, this method creates a new observable and returns it.
     * This means that you should not use this method directly in an Angular
     * template because each time the method is called it will look
     * (to Angular change detection) like the value has changed. To make
     * subscribing in templates easier, check out the `IsLoadingPipe`.
     * Alternatively, store the observable returned from this method in
     * a variable on your component and use that variable inside your
     * template.
     *
     * Example:
     *
     * ```ts
     *  class MyCustomComponent implements OnInit {
     *    variableForUseInTemplate: Observable<boolean>;
     *
     *    constructor(private loadingService: IsLoadingService) {}
     *
     *    ngOnInit() {
     *      this.variableForUseInTemplate =
     *        this.loadingService.isLoading$({key: 'button'});
     *
     *      this.loadingService.isLoading$().subscribe(value => {
     *        // ... do stuff
     *      });
     *
     *      this.loadingService
     *        .isLoading$({key: MyCustomComponent})
     *        .subscribe(value => {
     *          // ... do stuff
     *        });
     *    }
     *  }
     * ```
     *
     * @param {?=} args
     * @return {?}
     */
    IsLoadingService.prototype.isLoading$ = /**
     * Used to determine if something is loading or not.
     *
     * When called without arguments, returns the default *isLoading*
     * observable for your app. When called with an options object
     * containing a `key` property, returns the *isLoading* observable
     * corresponding to that key.
     *
     * Internally, *isLoading* observables are `BehaviorSubject`s, so
     * they will return values immediately upon subscription.
     *
     * When called, this method creates a new observable and returns it.
     * This means that you should not use this method directly in an Angular
     * template because each time the method is called it will look
     * (to Angular change detection) like the value has changed. To make
     * subscribing in templates easier, check out the `IsLoadingPipe`.
     * Alternatively, store the observable returned from this method in
     * a variable on your component and use that variable inside your
     * template.
     *
     * Example:
     *
     * ```ts
     *  class MyCustomComponent implements OnInit {
     *    variableForUseInTemplate: Observable<boolean>;
     *
     *    constructor(private loadingService: IsLoadingService) {}
     *
     *    ngOnInit() {
     *      this.variableForUseInTemplate =
     *        this.loadingService.isLoading$({key: 'button'});
     *
     *      this.loadingService.isLoading$().subscribe(value => {
     *        // ... do stuff
     *      });
     *
     *      this.loadingService
     *        .isLoading$({key: MyCustomComponent})
     *        .subscribe(value => {
     *          // ... do stuff
     *        });
     *    }
     *  }
     * ```
     *
     * @param {?=} args
     * @return {?}
     */
    function (args) {
        var _this = this;
        if (args === void 0) { args = {}; }
        /** @type {?} */
        var keys = this.normalizeKeys(args.key);
        return new Observable((/**
         * @param {?} observer
         * @return {?}
         */
        function (observer) {
            // this function will called each time this
            // Observable is subscribed to.
            _this.indexKeys(keys);
            /** @type {?} */
            var subscription = (/** @type {?} */ (_this.loadingSubjects
                .get(keys[0]))).pipe(distinctUntilChanged(), debounceTime(10), distinctUntilChanged())
                .subscribe({
                next: /**
                 * @param {?} value
                 * @return {?}
                 */
                function (value) {
                    observer.next(value);
                },
                error: /**
                 * @param {?} err
                 * @return {?}
                 */
                function (err) {
                    observer.error(err);
                },
                complete: /**
                 * @return {?}
                 */
                function () {
                    observer.complete();
                },
            });
            // the return value is the teardown function,
            // which will be invoked when the new
            // Observable is unsubscribed from.
            return (/**
             * @return {?}
             */
            function () {
                subscription.unsubscribe();
                keys.forEach((/**
                 * @param {?} key
                 * @return {?}
                 */
                function (key) { return _this.deIndexKey(key); }));
            });
        }));
    };
    /**
     * Same as `isLoading$()` except a boolean is returned,
     * rather than an observable.
     *
     * @param args.key optionally specify the key to check
     */
    /**
     * Same as `isLoading$()` except a boolean is returned,
     * rather than an observable.
     *
     * @param {?=} args
     * @return {?}
     */
    IsLoadingService.prototype.isLoading = /**
     * Same as `isLoading$()` except a boolean is returned,
     * rather than an observable.
     *
     * @param {?=} args
     * @return {?}
     */
    function (args) {
        if (args === void 0) { args = {}; }
        /** @type {?} */
        var key = this.normalizeKeys(args.key)[0];
        /** @type {?} */
        var obs = this.loadingSubjects.get(key);
        return (obs && obs.value) || false;
    };
    /**
     * @param {?=} first
     * @param {?=} second
     * @return {?}
     */
    IsLoadingService.prototype.add = /**
     * @param {?=} first
     * @param {?=} second
     * @return {?}
     */
    function (first, second) {
        var _this = this;
        /** @type {?} */
        var keyParam;
        /** @type {?} */
        var sub;
        if (first instanceof Subscription) {
            if (first.closed)
                return first;
            sub = first;
            first.add((/**
             * @return {?}
             */
            function () { return _this.remove(first, second); }));
        }
        else if (first instanceof Promise) {
            sub = first;
            // If the promise is already resolved, this executes syncronously
            first.then((/**
             * @return {?}
             */
            function () { return _this.remove(first, second); }), (/**
             * @return {?}
             */
            function () { return _this.remove(first, second); }));
        }
        else if (first instanceof Observable) {
            sub = first.pipe(take(1)).subscribe();
            if (sub.closed)
                return first;
            sub.add((/**
             * @return {?}
             */
            function () { return _this.remove((/** @type {?} */ (sub)), second); }));
        }
        else if (first) {
            keyParam = first.key;
        }
        if (second && second.key) {
            keyParam = second.key;
        }
        /** @type {?} */
        var keys = this.normalizeKeys(keyParam);
        this.indexKeys(keys);
        keys.forEach((/**
         * @param {?} key
         * @return {?}
         */
        function (key) {
            (/** @type {?} */ (_this.loadingStacks.get(key))).push(sub || true);
            _this.updateLoadingStatus(key);
        }));
        return first instanceof Observable ? first : sub;
    };
    /**
     * @param {?=} first
     * @param {?=} second
     * @return {?}
     */
    IsLoadingService.prototype.remove = /**
     * @param {?=} first
     * @param {?=} second
     * @return {?}
     */
    function (first, second) {
        var _this = this;
        /** @type {?} */
        var keyParam;
        /** @type {?} */
        var sub;
        if (first instanceof Subscription) {
            sub = first;
        }
        else if (first instanceof Promise) {
            sub = first;
        }
        else if (first) {
            keyParam = first.key;
        }
        if (second && second.key) {
            keyParam = second.key;
        }
        /** @type {?} */
        var keys = this.normalizeKeys(keyParam);
        keys.forEach((/**
         * @param {?} key
         * @return {?}
         */
        function (key) {
            /** @type {?} */
            var loadingStack = _this.loadingStacks.get(key);
            // !loadingStack means that a user has called remove() needlessly
            if (!loadingStack)
                return;
            /** @type {?} */
            var index = loadingStack.indexOf(sub || true);
            if (index >= 0) {
                loadingStack.splice(index, 1);
                _this.updateLoadingStatus(key);
                _this.deIndexKey(key);
            }
        }));
    };
    /**
     * @private
     * @param {?=} key
     * @return {?}
     */
    IsLoadingService.prototype.normalizeKeys = /**
     * @private
     * @param {?=} key
     * @return {?}
     */
    function (key) {
        if (!key)
            key = [this.defaultKey];
        else if (!Array.isArray(key))
            key = [key];
        return (/** @type {?} */ (key));
    };
    /**
     * `indexKeys()` along with `deIndexKeys()` helps us track which
     * keys are being watched so that unused keys can be deleted
     * / garbage collected.
     *
     * When `indexKeys()` is called with an array of keys, it means
     * that each of those keys has at least one "thing" interested
     * in it. Therefore, we need to make sure that a loadingSubject
     * and loadingStack exists for that key. We also need to index
     * the number of "things" interested in that key in the
     * `loadingKeyIndex` map.
     *
     * When `deIndexKeys()` is called with an array of keys, it
     * means that some "thing" is no longer interested in each
     * of those keys. Therefore, we need to re-index
     * the number of "things" interested in each key. For keys
     * that no longer have anything interested in them, we need
     * to delete the associated `loadingKeyIndex`, `loadingSubject`,
     * and `loadingStack`. So that the `key` can be properly
     * released for garbage collection.
     */
    /**
     * `indexKeys()` along with `deIndexKeys()` helps us track which
     * keys are being watched so that unused keys can be deleted
     * / garbage collected.
     *
     * When `indexKeys()` is called with an array of keys, it means
     * that each of those keys has at least one "thing" interested
     * in it. Therefore, we need to make sure that a loadingSubject
     * and loadingStack exists for that key. We also need to index
     * the number of "things" interested in that key in the
     * `loadingKeyIndex` map.
     *
     * When `deIndexKeys()` is called with an array of keys, it
     * means that some "thing" is no longer interested in each
     * of those keys. Therefore, we need to re-index
     * the number of "things" interested in each key. For keys
     * that no longer have anything interested in them, we need
     * to delete the associated `loadingKeyIndex`, `loadingSubject`,
     * and `loadingStack`. So that the `key` can be properly
     * released for garbage collection.
     * @private
     * @param {?} keys
     * @return {?}
     */
    IsLoadingService.prototype.indexKeys = /**
     * `indexKeys()` along with `deIndexKeys()` helps us track which
     * keys are being watched so that unused keys can be deleted
     * / garbage collected.
     *
     * When `indexKeys()` is called with an array of keys, it means
     * that each of those keys has at least one "thing" interested
     * in it. Therefore, we need to make sure that a loadingSubject
     * and loadingStack exists for that key. We also need to index
     * the number of "things" interested in that key in the
     * `loadingKeyIndex` map.
     *
     * When `deIndexKeys()` is called with an array of keys, it
     * means that some "thing" is no longer interested in each
     * of those keys. Therefore, we need to re-index
     * the number of "things" interested in each key. For keys
     * that no longer have anything interested in them, we need
     * to delete the associated `loadingKeyIndex`, `loadingSubject`,
     * and `loadingStack`. So that the `key` can be properly
     * released for garbage collection.
     * @private
     * @param {?} keys
     * @return {?}
     */
    function (keys) {
        var _this = this;
        keys.forEach((/**
         * @param {?} key
         * @return {?}
         */
        function (key) {
            if (_this.loadingKeyIndex.has(key)) {
                /** @type {?} */
                var curr = (/** @type {?} */ (_this.loadingKeyIndex.get(key)));
                _this.loadingKeyIndex.set(key, curr + 1);
            }
            else {
                /** @type {?} */
                var subject = new BehaviorSubject(false);
                _this.loadingKeyIndex.set(key, 1);
                _this.loadingSubjects.set(key, subject);
                _this.loadingStacks.set(key, []);
            }
        }));
    };
    /**
     * @private
     * @param {?} key
     * @return {?}
     */
    IsLoadingService.prototype.deIndexKey = /**
     * @private
     * @param {?} key
     * @return {?}
     */
    function (key) {
        /** @type {?} */
        var curr = (/** @type {?} */ (this.loadingKeyIndex.get(key)));
        if (curr === 1) {
            this.loadingKeyIndex.delete(key);
            this.loadingSubjects.delete(key);
            this.loadingStacks.delete(key);
        }
        else {
            this.loadingKeyIndex.set(key, curr - 1);
        }
    };
    /**
     * @private
     * @param {?} key
     * @return {?}
     */
    IsLoadingService.prototype.updateLoadingStatus = /**
     * @private
     * @param {?} key
     * @return {?}
     */
    function (key) {
        /** @type {?} */
        var loadingStatus = (/** @type {?} */ (this.loadingStacks.get(key))).length > 0;
        (/** @type {?} */ (this.loadingSubjects.get(key))).next(loadingStatus);
    };
    IsLoadingService.decorators = [
        { type: Injectable, args: [{
                    providedIn: 'root',
                },] }
    ];
    /** @nocollapse */
    IsLoadingService.ctorParameters = function () { return []; };
    /** @nocollapse */ IsLoadingService.ngInjectableDef = i0.defineInjectable({ factory: function IsLoadingService_Factory() { return new IsLoadingService(); }, token: IsLoadingService, providedIn: "root" });
    return IsLoadingService;
}());
export { IsLoadingService };
if (false) {
    /**
     * @type {?}
     * @protected
     */
    IsLoadingService.prototype.defaultKey;
    /**
     * @type {?}
     * @private
     */
    IsLoadingService.prototype.loadingSubjects;
    /**
     * @type {?}
     * @private
     */
    IsLoadingService.prototype.loadingStacks;
    /**
     * @type {?}
     * @private
     */
    IsLoadingService.prototype.loadingKeyIndex;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaXMtbG9hZGluZy5zZXJ2aWNlLmpzIiwic291cmNlUm9vdCI6Im5nOi8vQHNlcnZpY2Utd29yay9pcy1sb2FkaW5nLyIsInNvdXJjZXMiOlsibGliL2lzLWxvYWRpbmcuc2VydmljZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7O0FBQUEsT0FBTyxFQUFFLFVBQVUsRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUMzQyxPQUFPLEVBQUUsZUFBZSxFQUFFLFlBQVksRUFBRSxVQUFVLEVBQUUsTUFBTSxNQUFNLENBQUM7QUFDakUsT0FBTyxFQUFFLG9CQUFvQixFQUFFLFlBQVksRUFBRSxJQUFJLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQzs7Ozs7QUFJMUUsd0NBRUM7OztJQURDLGlDQUFVOzs7OztBQUdaLDJDQUVDOzs7SUFEQyxvQ0FBa0I7O0FBR3BCO0lBbUJFO1FBZlUsZUFBVSxHQUFHLFNBQVMsQ0FBQzs7UUFHekIsb0JBQWUsR0FBRyxJQUFJLEdBQUcsRUFBaUMsQ0FBQzs7UUFHM0Qsa0JBQWEsR0FBRyxJQUFJLEdBQUcsRUFHNUIsQ0FBQzs7O1FBSUksb0JBQWUsR0FBRyxJQUFJLEdBQUcsRUFBZSxDQUFDO0lBRWxDLENBQUM7SUFFaEI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7T0E4Q0c7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7SUFDSCxxQ0FBVTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0lBQVYsVUFBVyxJQUE2QjtRQUF4QyxpQkFtQ0M7UUFuQ1UscUJBQUEsRUFBQSxTQUE2Qjs7WUFDaEMsSUFBSSxHQUFHLElBQUksQ0FBQyxhQUFhLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQztRQUV6QyxPQUFPLElBQUksVUFBVTs7OztRQUFVLFVBQUEsUUFBUTtZQUNyQywyQ0FBMkM7WUFDM0MsK0JBQStCO1lBQy9CLEtBQUksQ0FBQyxT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QUFDLGFBQWEsQ0FBQyxDQUFDO0lBQ3JELENBQUM7O2dCQWphRixVQUFVLFNBQUM7b0JBQ1YsVUFBVSxFQUFFLE1BQU07aUJBQ25COzs7OzsyQkFoQkQ7Q0FnYkMsQUFsYUQsSUFrYUM7U0EvWlksZ0JBQWdCOzs7Ozs7SUFDM0Isc0NBQWlDOzs7OztJQUdqQywyQ0FBbUU7Ozs7O0lBR25FLHlDQUdJOzs7OztJQUlKLDJDQUFpRCIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEluamVjdGFibGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IEJlaGF2aW9yU3ViamVjdCwgU3Vic2NyaXB0aW9uLCBPYnNlcnZhYmxlIH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyBkaXN0aW5jdFVudGlsQ2hhbmdlZCwgZGVib3VuY2VUaW1lLCB0YWtlIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuXG5leHBvcnQgdHlwZSBLZXkgPSBzdHJpbmcgfCBvYmplY3QgfCBzeW1ib2w7XG5cbmV4cG9ydCBpbnRlcmZhY2UgSUdldExvYWRpbmdPcHRpb25zIHtcbiAga2V5PzogS2V5O1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIElVcGRhdGVMb2FkaW5nT3B0aW9ucyB7XG4gIGtleT86IEtleSB8IEtleVtdO1xufVxuXG5ASW5qZWN0YWJsZSh7XG4gIHByb3ZpZGVkSW46ICdyb290Jyxcbn0pXG5leHBvcnQgY2xhc3MgSXNMb2FkaW5nU2VydmljZSB7XG4gIHByb3RlY3RlZCBkZWZhdWx0S2V5ID0gJ2RlZmF1bHQnO1xuXG4gIC8vIHByb3ZpZGVzIGFuIG9ic2VydmFibGUgaW5kaWNhdGluZyBpZiBhIHBhcnRpY3VsYXIga2V5IGlzIGxvYWRpbmdcbiAgcHJpdmF0ZSBsb2FkaW5nU3ViamVjdHMgPSBuZXcgTWFwPEtleSwgQmVoYXZpb3JTdWJqZWN0PGJvb2xlYW4+PigpO1xuXG4gIC8vIHRyYWNrcyBob3cgbWFueSBcInRoaW5nc1wiIGFyZSBsb2FkaW5nIGZvciBlYWNoIGtleVxuICBwcml2YXRlIGxvYWRpbmdTdGFja3MgPSBuZXcgTWFwPFxuICAgIHVua25vd24sXG4gICAgKHRydWUgfCBTdWJzY3JpcHRpb24gfCBQcm9taXNlPHVua25vd24+KVtdXG4gID4oKTtcblxuICAvLyB0cmFja3Mgd2hpY2gga2V5cyBhcmUgYmVpbmcgd2F0Y2hlZCBzbyB0aGF0IHVudXNlZCBrZXlzXG4gIC8vIGNhbiBiZSBkZWxldGVkL2dhcmJhZ2UgY29sbGVjdGVkLlxuICBwcml2YXRlIGxvYWRpbmdLZXlJbmRleCA9IG5ldyBNYXA8S2V5LCBudW1iZXI+KCk7XG5cbiAgY29uc3RydWN0b3IoKSB7fVxuXG4gIC8qKlxuICAgKiBVc2VkIHRvIGRldGVybWluZSBpZiBzb21ldGhpbmcgaXMgbG9hZGluZyBvciBub3QuXG4gICAqXG4gICAqIFdoZW4gY2FsbGVkIHdpdGhvdXQgYXJndW1lbnRzLCByZXR1cm5zIHRoZSBkZWZhdWx0ICppc0xvYWRpbmcqXG4gICAqIG9ic2VydmFibGUgZm9yIHlvdXIgYXBwLiBXaGVuIGNhbGxlZCB3aXRoIGFuIG9wdGlvbnMgb2JqZWN0XG4gICAqIGNvbnRhaW5pbmcgYSBga2V5YCBwcm9wZXJ0eSwgcmV0dXJucyB0aGUgKmlzTG9hZGluZyogb2JzZXJ2YWJsZVxuICAgKiBjb3JyZXNwb25kaW5nIHRvIHRoYXQga2V5LlxuICAgKlxuICAgKiBJbnRlcm5hbGx5LCAqaXNMb2FkaW5nKiBvYnNlcnZhYmxlcyBhcmUgYEJlaGF2aW9yU3ViamVjdGBzLCBzb1xuICAgKiB0aGV5IHdpbGwgcmV0dXJuIHZhbHVlcyBpbW1lZGlhdGVseSB1cG9uIHN1YnNjcmlwdGlvbi5cbiAgICpcbiAgICogV2hlbiBjYWxsZWQsIHRoaXMgbWV0aG9kIGNyZWF0ZXMgYSBuZXcgb2JzZXJ2YWJsZSBhbmQgcmV0dXJucyBpdC5cbiAgICogVGhpcyBtZWFucyB0aGF0IHlvdSBzaG91bGQgbm90IHVzZSB0aGlzIG1ldGhvZCBkaXJlY3RseSBpbiBhbiBBbmd1bGFyXG4gICAqIHRlbXBsYXRlIGJlY2F1c2UgZWFjaCB0aW1lIHRoZSBtZXRob2QgaXMgY2FsbGVkIGl0IHdpbGwgbG9va1xuICAgKiAodG8gQW5ndWxhciBjaGFuZ2UgZGV0ZWN0aW9uKSBsaWtlIHRoZSB2YWx1ZSBoYXMgY2hhbmdlZC4gVG8gbWFrZVxuICAgKiBzdWJzY3JpYmluZyBpbiB0ZW1wbGF0ZXMgZWFzaWVyLCBjaGVjayBvdXQgdGhlIGBJc0xvYWRpbmdQaXBlYC5cbiAgICogQWx0ZXJuYXRpdmVseSwgc3RvcmUgdGhlIG9ic2VydmFibGUgcmV0dXJuZWQgZnJvbSB0aGlzIG1ldGhvZCBpblxuICAgKiBhIHZhcmlhYmxlIG9uIHlvdXIgY29tcG9uZW50IGFuZCB1c2UgdGhhdCB2YXJpYWJsZSBpbnNpZGUgeW91clxuICAgKiB0ZW1wbGF0ZS5cbiAgICpcbiAgICogRXhhbXBsZTpcbiAgICpcbiAgICogYGBgdHNcbiAgICogIGNsYXNzIE15Q3VzdG9tQ29tcG9uZW50IGltcGxlbWVudHMgT25Jbml0IHtcbiAgICogICAgdmFyaWFibGVGb3JVc2VJblRlbXBsYXRlOiBPYnNlcnZhYmxlPGJvb2xlYW4+O1xuICAgKlxuICAgKiAgICBjb25zdHJ1Y3Rvcihwcml2YXRlIGxvYWRpbmdTZXJ2aWNlOiBJc0xvYWRpbmdTZXJ2aWNlKSB7fVxuICAgKlxuICAgKiAgICBuZ09uSW5pdCgpIHtcbiAgICogICAgICB0aGlzLnZhcmlhYmxlRm9yVXNlSW5UZW1wbGF0ZSA9XG4gICAqICAgICAgICB0aGlzLmxvYWRpbmdTZXJ2aWNlLmlzTG9hZGluZyQoe2tleTogJ2J1dHRvbid9KTtcbiAgICpcbiAgICogICAgICB0aGlzLmxvYWRpbmdTZXJ2aWNlLmlzTG9hZGluZyQoKS5zdWJzY3JpYmUodmFsdWUgPT4ge1xuICAgKiAgICAgICAgLy8gLi4uIGRvIHN0dWZmXG4gICAqICAgICAgfSk7XG4gICAqXG4gICAqICAgICAgdGhpcy5sb2FkaW5nU2VydmljZVxuICAgKiAgICAgICAgLmlzTG9hZGluZyQoe2tleTogTXlDdXN0b21Db21wb25lbnR9KVxuICAgKiAgICAgICAgLnN1YnNjcmliZSh2YWx1ZSA9PiB7XG4gICAqICAgICAgICAgIC8vIC4uLiBkbyBzdHVmZlxuICAgKiAgICAgICAgfSk7XG4gICAqICAgIH1cbiAgICogIH1cbiAgICogYGBgXG4gICAqXG4gICAqIEBwYXJhbSBhcmdzLmtleSBvcHRpb25hbGx5IHNwZWNpZnkgdGhlIGtleSB0byBzdWJzY3JpYmUgdG9cbiAgICovXG4gIGlzTG9hZGluZyQoYXJnczogSUdldExvYWRpbmdPcHRpb25zID0ge30pOiBPYnNlcnZhYmxlPGJvb2xlYW4+IHtcbiAgICBjb25zdCBrZXlzID0gdGhpcy5ub3JtYWxpemVLZXlzKGFyZ3Mua2V5KTtcblxuICAgIHJldHVybiBuZXcgT2JzZXJ2YWJsZTxib29sZWFuPihvYnNlcnZlciA9PiB7XG4gICAgICAvLyB0aGlzIGZ1bmN0aW9uIHdpbGwgY2FsbGVkIGVhY2ggdGltZSB0aGlzXG4gICAgICAvLyBPYnNlcnZhYmxlIGlzIHN1YnNjcmliZWQgdG8uXG4gICAgICB0aGlzLmluZGV4S2V5cyhrZXlzKTtcblxuICAgICAgY29uc3Qgc3Vic2NyaXB0aW9uID0gdGhpcy5sb2FkaW5nU3ViamVjdHNcbiAgICAgICAgLmdldChrZXlzWzBdKSFcbiAgICAgICAgLnBpcGUoXG4gICAgICAgICAgZGlzdGluY3RVbnRpbENoYW5nZWQoKSxcbiAgICAgICAgICBkZWJvdW5jZVRpbWUoMTApLFxuICAgICAgICAgIGRpc3RpbmN0VW50aWxDaGFuZ2VkKCksXG4gICAgICAgIClcbiAgICAgICAgLnN1YnNjcmliZSh7XG4gICAgICAgICAgbmV4dCh2YWx1ZSkge1xuICAgICAgICAgICAgb2JzZXJ2ZXIubmV4dCh2YWx1ZSk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBlcnJvcihlcnIpIHtcbiAgICAgICAgICAgIG9ic2VydmVyLmVycm9yKGVycik7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBjb21wbGV0ZSgpIHtcbiAgICAgICAgICAgIG9ic2VydmVyLmNvbXBsZXRlKCk7XG4gICAgICAgICAgfSxcbiAgICAgICAgfSk7XG5cbiAgICAgIC8vIHRoZSByZXR1cm4gdmFsdWUgaXMgdGhlIHRlYXJkb3duIGZ1bmN0aW9uLFxuICAgICAgLy8gd2hpY2ggd2lsbCBiZSBpbnZva2VkIHdoZW4gdGhlIG5ld1xuICAgICAgLy8gT2JzZXJ2YWJsZSBpcyB1bnN1YnNjcmliZWQgZnJvbS5cbiAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIHN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgICAgICBrZXlzLmZvckVhY2goa2V5ID0+IHRoaXMuZGVJbmRleEtleShrZXkpKTtcbiAgICAgIH07XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogU2FtZSBhcyBgaXNMb2FkaW5nJCgpYCBleGNlcHQgYSBib29sZWFuIGlzIHJldHVybmVkLFxuICAgKiByYXRoZXIgdGhhbiBhbiBvYnNlcnZhYmxlLlxuICAgKlxuICAgKiBAcGFyYW0gYXJncy5rZXkgb3B0aW9uYWxseSBzcGVjaWZ5IHRoZSBrZXkgdG8gY2hlY2tcbiAgICovXG4gIGlzTG9hZGluZyhhcmdzOiBJR2V0TG9hZGluZ09wdGlvbnMgPSB7fSk6IGJvb2xlYW4ge1xuICAgIGNvbnN0IGtleSA9IHRoaXMubm9ybWFsaXplS2V5cyhhcmdzLmtleSlbMF07XG4gICAgY29uc3Qgb2JzID0gdGhpcy5sb2FkaW5nU3ViamVjdHMuZ2V0KGtleSk7XG5cbiAgICByZXR1cm4gKG9icyAmJiBvYnMudmFsdWUpIHx8IGZhbHNlO1xuICB9XG5cbiAgLyoqXG4gICAqIFVzZWQgdG8gaW5kaWNhdGUgdGhhdCAqc29tZXRoaW5nKiBoYXMgc3RhcnRlZCBsb2FkaW5nLlxuICAgKlxuICAgKiBPcHRpb25hbGx5LCBhIGtleSBvciBrZXlzIGNhbiBiZSBwYXNzZWQgdG8gdHJhY2sgdGhlIGxvYWRpbmdcbiAgICogb2YgZGlmZmVyZW50IHRoaW5ncy5cbiAgICpcbiAgICogWW91IGNhbiBwYXNzIGEgYFN1YnNjcmlwdGlvbmAsIGBQcm9taXNlYCwgb3IgYE9ic2VydmFibGVgXG4gICAqIGFyZ3VtZW50LCBvciB5b3UgY2FuIGNhbGwgYGFkZCgpYCB3aXRob3V0IGFyZ3VtZW50cy4gSWZcbiAgICogdGhpcyBtZXRob2QgaXMgY2FsbGVkIHdpdGggYSBgU3Vic2NyaXB0aW9uYCwgYFByb21pc2VgLFxuICAgKiBvciBgT2JzZXJ2YWJsZWAgYXJndW1lbnQsIHRoaXMgbWV0aG9kIHJldHVybnMgdGhhdCBhcmd1bWVudC5cbiAgICogVGhpcyBpcyB0byBtYWtlIGl0IGVhc2llciBmb3IgeW91IHRvIGNoYWluIG9mZiBvZiBgYWRkKClgLlxuICAgKlxuICAgKiBFeGFtcGxlOiBgYXdhaXQgaXNMb2FkaW5nU2VydmljZS5hZGQocHJvbWlzZSk7YFxuICAgKlxuICAgKiBPcHRpb25zOlxuICAgKlxuICAgKiAtIElmIGNhbGxlZCB3aXRob3V0IGFyZ3VtZW50cywgdGhlIGBcImRlZmF1bHRcImAga2V5IGlzXG4gICAqICAgbWFya2VkIGFzIGxvYWRpbmcuIEl0IHdpbGwgcmVtYWluIGxvYWRpbmcgdW50aWwgeW91XG4gICAqICAgbWFudWFsbHkgY2FsbCBgcmVtb3ZlKClgIG9uY2UuIElmIHlvdSBjYWxsIGBhZGQoKWBcbiAgICogICB0d2ljZSB3aXRob3V0IGFyZ3VtZW50cywgeW91IHdpbGwgbmVlZCB0byBjYWxsXG4gICAqICAgYHJlbW92ZSgpYCB0d2ljZSB3aXRob3V0IGFyZ3VtZW50cyBmb3IgbG9hZGluZyB0b1xuICAgKiAgIHN0b3AuIEV0Yy5cbiAgICogLSBJZiBjYWxsZWQgd2l0aCBhIGBTdWJzY3JpcHRpb25gIG9yIGBQcm9taXNlYFxuICAgKiAgIGFyZ3VtZW50LCB0aGUgYXBwcm9wcmlhdGUga2V5IGlzIG1hcmtlZCBhcyBsb2FkaW5nXG4gICAqICAgdW50aWwgdGhlIGBTdWJzY3JpcHRpb25gIG9yIGBQcm9taXNlYCByZXNvbHZlcywgYXRcbiAgICogICB3aGljaCBwb2ludCBpdCBpcyBhdXRvbWF0aWNhbGx5IG1hcmtlZCBhcyBubyBsb25nZXJcbiAgICogICBsb2FkaW5nLiBUaGVyZSBpcyBubyBuZWVkIHRvIGNhbGwgYHJlbW92ZSgpYCBpbiB0aGlzXG4gICAqICAgc2NlbmVyaW8uXG4gICAqIC0gSWYgY2FsbGVkIHdpdGggYW4gYE9ic2VydmFibGVgIGFyZ3VtZW50LCB0aGVcbiAgICogICBhcHByb3ByaWF0ZSBrZXkgaXMgbWFya2VkIGFzIGxvYWRpbmcgdW50aWwgdGhlXG4gICAqICAgbmV4dCBlbWlzc2lvbiBvZiB0aGUgYE9ic2VydmFibGVgLCBhdCB3aGljaCBwb2ludFxuICAgKiAgIElzTG9hZGluZ1NlcnZpY2Ugd2lsbCB1bnN1YnNjcmliZSBmcm9tIHRoZVxuICAgKiAgIG9ic2VydmFibGUgYW5kIG1hcmsgdGhlIGtleSBhcyBubyBsb25nZXIgbG9hZGluZy5cbiAgICpcbiAgICogRmluYWxseSwgYXMgcHJldmlvdXNseSBub3RlZCB0aGUga2V5IG9wdGlvbiBhbGxvd3MgeW91XG4gICAqIHRvIHRyYWNrIHRoZSBsb2FkaW5nIG9mIGRpZmZlcmVudCB0aGluZ3Mgc2VwZXJhdGVseS5cbiAgICogQW55IHRydXRoeSB2YWx1ZSBjYW4gYmUgdXNlZCBhcyBhIGtleS4gVGhlIGtleSBvcHRpb25cbiAgICogZm9yIGBhZGQoKWAgaXMgaW50ZW5kZWQgdG8gYmUgdXNlZCBpbiBjb25qdW5jdGlvbiB3aXRoXG4gICAqIHRoZSBga2V5YCBvcHRpb24gZm9yIGBpc0xvYWRpbmckKClgIGFuZCBgcmVtb3ZlKClgLiBJZlxuICAgKiB5b3UgcGFzcyBtdWx0aXBsZSBrZXlzIHRvIGBhZGQoKWAsIGVhY2gga2V5IHdpbGwgYmVcbiAgICogbWFya2VkIGFzIGxvYWRpbmcuXG4gICAqXG4gICAqIEV4YW1wbGU6XG4gICAqXG4gICAqIGBgYHRzXG4gICAqICBjbGFzcyBNeUN1c3RvbUNvbXBvbmVudCBpbXBsZW1lbnRzIE9uSW5pdCwgQWZ0ZXJWaWV3SW5pdCB7XG4gICAqICAgIGNvbnN0cnVjdG9yKFxuICAgKiAgICAgIHByaXZhdGUgbG9hZGluZ1NlcnZpY2U6IElzTG9hZGluZ1NlcnZpY2UsXG4gICAqICAgICAgcHJpdmF0ZSBteUN1c3RvbURhdGFTZXJ2aWNlOiBNeUN1c3RvbURhdGFTZXJ2aWNlLFxuICAgKiAgICApIHt9XG4gICAqXG4gICAqICAgIG5nT25Jbml0KCkge1xuICAgKiAgICAgIGNvbnN0IHN1YnNjcmlwdGlvbiA9IHRoaXMubXlDdXN0b21EYXRhU2VydmljZS5nZXREYXRhKCkuc3Vic2NyaWJlKCk7XG4gICAqXG4gICAqICAgICAgLy8gTm90ZSwgd2UgZG9uJ3QgbmVlZCB0byBjYWxsIHJlbW92ZSgpIHdoZW4gY2FsbGluZ1xuICAgKiAgICAgIC8vIGFkZCgpIHdpdGggYSBzdWJzY3JpcHRpb25cbiAgICogICAgICB0aGlzLmxvYWRpbmdTZXJ2aWNlLmFkZChzdWJzY3JpcHRpb24sIHtcbiAgICogICAgICAgIGtleTogJ2dldHRpbmctZGF0YSdcbiAgICogICAgICB9KTtcbiAgICpcbiAgICogICAgICAvLyBIZXJlIHdlIG1hcmsgYE15Q3VzdG9tQ29tcG9uZW50YCBhcyB3ZWxsIGFzIHRoZSBcImRlZmF1bHRcIiBrZXlcbiAgICogICAgICAvLyBhcyBsb2FkaW5nLCBhbmQgdGhlbiBtYXJrIHRoZW0gYXMgbm8gbG9uZ2VyIGxvYWRpbmcgaW5cbiAgICogICAgICAvLyBuZ0FmdGVyVmlld0luaXQoKVxuICAgKiAgICAgIHRoaXMubG9hZGluZ1NlcnZpY2UuYWRkKHtrZXk6IFtNeUN1c3RvbUNvbXBvbmVudCwgJ2RlZmF1bHQnXX0pO1xuICAgKiAgICB9XG4gICAqXG4gICAqICAgIG5nQWZ0ZXJWaWV3SW5pdCgpIHtcbiAgICogICAgICB0aGlzLmxvYWRpbmdTZXJ2aWNlLnJlbW92ZSh7a2V5OiBbTXlDdXN0b21Db21wb25lbnQsICdkZWZhdWx0J119KVxuICAgKiAgICB9XG4gICAqXG4gICAqICAgIGFzeW5jIHN1Ym1pdChkYXRhOiBhbnkpIHtcbiAgICogICAgICAvLyBoZXJlIHdlIHRha2UgYWR2YW50YWdlIG9mIHRoZSBmYWN0IHRoYXQgYGFkZCgpYCByZXR1cm5zIHRoZVxuICAgKiAgICAgIC8vIFByb21pc2UgcGFzc2VkIHRvIGl0LlxuICAgKiAgICAgIGF3YWl0IHRoaXMubG9hZGluZ1NlcnZpY2UuYWRkKFxuICAgKiAgICAgICAgdGhpcy5teUN1c3RvbURhdGFTZXJ2aWNlLnVwZGF0ZURhdGEoZGF0YSksXG4gICAqICAgICAgICB7IGtleTogJ2J1dHRvbicgfVxuICAgKiAgICAgIClcbiAgICpcbiAgICogICAgICAvLyBkbyBzdHVmZi4uLlxuICAgKiAgICB9XG4gICAqICB9XG4gICAqIGBgYFxuICAgKlxuICAgKiBAcmV0dXJuIElmIGNhbGxlZCB3aXRoIGEgYFN1YnNjcmlwdGlvbmAsIGBQcm9taXNlYCBvciBgT2JzZXJ2YWJsZWAsXG4gICAqICAgICAgICAgdGhlIFN1YnNjcmlwdGlvbi9Qcm9taXNlL09ic2VydmFibGUgaXMgcmV0dXJuZWQuXG4gICAqICAgICAgICAgVGhpcyBhbGxvd3MgY29kZSBsaWtlIGBhd2FpdCB0aGlzLmlzTG9hZGluZ1NlcnZpY2UuYWRkKHByb21pc2UpYC5cbiAgICovXG4gIGFkZCgpOiB2b2lkO1xuICBhZGQob3B0aW9uczogSVVwZGF0ZUxvYWRpbmdPcHRpb25zKTogdm9pZDtcbiAgYWRkPFQgZXh0ZW5kcyBTdWJzY3JpcHRpb24gfCBQcm9taXNlPHVua25vd24+IHwgT2JzZXJ2YWJsZTx1bmtub3duPj4oXG4gICAgc3ViOiBULFxuICAgIG9wdGlvbnM/OiBJVXBkYXRlTG9hZGluZ09wdGlvbnMsXG4gICk6IFQ7XG4gIGFkZChcbiAgICBmaXJzdD86IFN1YnNjcmlwdGlvbiB8IFByb21pc2U8dW5rbm93bj4gfCBJVXBkYXRlTG9hZGluZ09wdGlvbnMsXG4gICAgc2Vjb25kPzogSVVwZGF0ZUxvYWRpbmdPcHRpb25zLFxuICApIHtcbiAgICBsZXQga2V5UGFyYW06IEtleSB8IEtleVtdIHwgdW5kZWZpbmVkO1xuICAgIGxldCBzdWI6IFN1YnNjcmlwdGlvbiB8IFByb21pc2U8dW5rbm93bj4gfCB1bmRlZmluZWQ7XG5cbiAgICBpZiAoZmlyc3QgaW5zdGFuY2VvZiBTdWJzY3JpcHRpb24pIHtcbiAgICAgIGlmIChmaXJzdC5jbG9zZWQpIHJldHVybiBmaXJzdDtcblxuICAgICAgc3ViID0gZmlyc3Q7XG5cbiAgICAgIGZpcnN0LmFkZCgoKSA9PiB0aGlzLnJlbW92ZShmaXJzdCwgc2Vjb25kKSk7XG4gICAgfSBlbHNlIGlmIChmaXJzdCBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgIHN1YiA9IGZpcnN0O1xuXG4gICAgICAvLyBJZiB0aGUgcHJvbWlzZSBpcyBhbHJlYWR5IHJlc29sdmVkLCB0aGlzIGV4ZWN1dGVzIHN5bmNyb25vdXNseVxuICAgICAgZmlyc3QudGhlbihcbiAgICAgICAgKCkgPT4gdGhpcy5yZW1vdmUoZmlyc3QsIHNlY29uZCksXG4gICAgICAgICgpID0+IHRoaXMucmVtb3ZlKGZpcnN0LCBzZWNvbmQpLFxuICAgICAgKTtcbiAgICB9IGVsc2UgaWYgKGZpcnN0IGluc3RhbmNlb2YgT2JzZXJ2YWJsZSkge1xuICAgICAgc3ViID0gZmlyc3QucGlwZSh0YWtlKDEpKS5zdWJzY3JpYmUoKTtcblxuICAgICAgaWYgKHN1Yi5jbG9zZWQpIHJldHVybiBmaXJzdDtcblxuICAgICAgc3ViLmFkZCgoKSA9PiB0aGlzLnJlbW92ZShzdWIgYXMgU3Vic2NyaXB0aW9uLCBzZWNvbmQpKTtcbiAgICB9IGVsc2UgaWYgKGZpcnN0KSB7XG4gICAgICBrZXlQYXJhbSA9IGZpcnN0LmtleTtcbiAgICB9XG5cbiAgICBpZiAoc2Vjb25kICYmIHNlY29uZC5rZXkpIHtcbiAgICAgIGtleVBhcmFtID0gc2Vjb25kLmtleTtcbiAgICB9XG5cbiAgICBjb25zdCBrZXlzID0gdGhpcy5ub3JtYWxpemVLZXlzKGtleVBhcmFtKTtcblxuICAgIHRoaXMuaW5kZXhLZXlzKGtleXMpO1xuXG4gICAga2V5cy5mb3JFYWNoKGtleSA9PiB7XG4gICAgICB0aGlzLmxvYWRpbmdTdGFja3MuZ2V0KGtleSkhLnB1c2goc3ViIHx8IHRydWUpO1xuXG4gICAgICB0aGlzLnVwZGF0ZUxvYWRpbmdTdGF0dXMoa2V5KTtcbiAgICB9KTtcblxuICAgIHJldHVybiBmaXJzdCBpbnN0YW5jZW9mIE9ic2VydmFibGUgPyBmaXJzdCA6IHN1YjtcbiAgfVxuXG4gIC8qKlxuICAgKiBVc2VkIHRvIGluZGljYXRlIHRoYXQgc29tZXRoaW5nIGhhcyBzdG9wcGVkIGxvYWRpbmcuXG4gICAqXG4gICAqIC0gTm90ZTogaWYgeW91IGNhbGwgYGFkZCgpYCB3aXRoIGEgYFN1YnNjcmlwdGlvbmAsXG4gICAqICAgYFByb21pc2VgLCBvciBgT2JzZXJ2YWJsZWAgYXJndW1lbnQsIHlvdSBkbyBub3QgbmVlZFxuICAgKiAgIHRvIG1hbnVhbGx5IGNhbGwgYHJlbW92ZSgpLlxuICAgKlxuICAgKiBXaGVuIGNhbGxlZCB3aXRob3V0IGFyZ3VtZW50cywgYHJlbW92ZSgpYFxuICAgKiByZW1vdmVzIGEgbG9hZGluZyBpbmRpY2F0b3IgZnJvbSB0aGUgZGVmYXVsdFxuICAgKiAqaXNMb2FkaW5nKiBvYnNlcnZhYmxlJ3Mgc3RhY2suIFNvIGxvbmcgYXMgYW55IGl0ZW1zXG4gICAqIGFyZSBpbiBhbiAqaXNMb2FkaW5nKiBvYnNlcnZhYmxlJ3Mgc3RhY2ssIHRoYXRcbiAgICogb2JzZXJ2YWJsZSB3aWxsIGJlIG1hcmtlZCBhcyBsb2FkaW5nLlxuICAgKlxuICAgKiBJbiBtb3JlIGFkdmFuY2VkIHVzYWdlLCB5b3UgY2FuIGNhbGwgYHJlbW92ZSgpYCB3aXRoXG4gICAqIGFuIG9wdGlvbnMgb2JqZWN0IHdoaWNoIGFjY2VwdHMgYSBga2V5YCBwcm9wZXJ0eS5cbiAgICogVGhlIGtleSBhbGxvd3MgeW91IHRvIHRyYWNrIHRoZSBsb2FkaW5nIG9mIGRpZmZlcmVudFxuICAgKiB0aGluZ3Mgc2VwZXJhdGVseS4gQW55IHRydXRoeSB2YWx1ZSBjYW4gYmUgdXNlZCBhcyBhXG4gICAqIGtleS4gVGhlIGtleSBvcHRpb24gZm9yIGByZW1vdmUoKWAgaXMgaW50ZW5kZWQgdG8gYmVcbiAgICogdXNlZCBpbiBjb25qdW5jdGlvbiB3aXRoIHRoZSBga2V5YCBvcHRpb24gZm9yXG4gICAqIGBpc0xvYWRpbmckKClgIGFuZCBgYWRkKClgLiBJZiB5b3UgcGFzcyBhbiBhcnJheSBvZlxuICAgKiBrZXlzIHRvIGByZW1vdmUoKWAsIHRoZW4gZWFjaCBrZXkgd2lsbCBiZSBtYXJrZWQgYXNcbiAgICogbm8gbG9uZ2VyIGxvYWRpbmcuXG4gICAqXG4gICAqIEV4YW1wbGU6XG4gICAqXG4gICAqIGBgYHRzXG4gICAqICBjbGFzcyBNeUN1c3RvbUNvbXBvbmVudCBpbXBsZW1lbnRzIE9uSW5pdCwgQWZ0ZXJWaWV3SW5pdCB7XG4gICAqICAgIGNvbnN0cnVjdG9yKHByaXZhdGUgbG9hZGluZ1NlcnZpY2U6IElzTG9hZGluZ1NlcnZpY2UpIHt9XG4gICAqXG4gICAqICAgIG5nT25Jbml0KCkge1xuICAgKiAgICAgIC8vIFB1c2hlcyBhIGxvYWRpbmcgaW5kaWNhdG9yIG9udG8gdGhlIGBcImRlZmF1bHRcImAgc3RhY2tcbiAgICogICAgICB0aGlzLmxvYWRpbmdTZXJ2aWNlLmFkZCgpXG4gICAqICAgIH1cbiAgICpcbiAgICogICAgbmdBZnRlclZpZXdJbml0KCkge1xuICAgKiAgICAgIC8vIFJlbW92ZXMgYSBsb2FkaW5nIGluZGljYXRvciBmcm9tIHRoZSBkZWZhdWx0IHN0YWNrXG4gICAqICAgICAgdGhpcy5sb2FkaW5nU2VydmljZS5yZW1vdmUoKVxuICAgKiAgICB9XG4gICAqXG4gICAqICAgIHBlcmZvcm1Mb25nQWN0aW9uKCkge1xuICAgKiAgICAgIC8vIFB1c2hlcyBhIGxvYWRpbmcgaW5kaWNhdG9yIG9udG8gdGhlIGAnbG9uZy1hY3Rpb24nYFxuICAgKiAgICAgIC8vIHN0YWNrXG4gICAqICAgICAgdGhpcy5sb2FkaW5nU2VydmljZS5hZGQoe2tleTogJ2xvbmctYWN0aW9uJ30pXG4gICAqICAgIH1cbiAgICpcbiAgICogICAgZmluaXNoTG9uZ0FjdGlvbigpIHtcbiAgICogICAgICAvLyBSZW1vdmVzIGEgbG9hZGluZyBpbmRpY2F0b3IgZnJvbSB0aGUgYCdsb25nLWFjdGlvbidgXG4gICAqICAgICAgLy8gc3RhY2tcbiAgICogICAgICB0aGlzLmxvYWRpbmdTZXJ2aWNlLnJlbW92ZSh7a2V5OiAnbG9uZy1hY3Rpb24nfSlcbiAgICogICAgfVxuICAgKiAgfVxuICAgKiBgYGBcbiAgICpcbiAgICovXG4gIHJlbW92ZSgpOiB2b2lkO1xuICByZW1vdmUob3B0aW9uczogSVVwZGF0ZUxvYWRpbmdPcHRpb25zKTogdm9pZDtcbiAgcmVtb3ZlKFxuICAgIHN1YjogU3Vic2NyaXB0aW9uIHwgUHJvbWlzZTx1bmtub3duPixcbiAgICBvcHRpb25zPzogSVVwZGF0ZUxvYWRpbmdPcHRpb25zLFxuICApOiB2b2lkO1xuICByZW1vdmUoXG4gICAgZmlyc3Q/OiBTdWJzY3JpcHRpb24gfCBQcm9taXNlPHVua25vd24+IHwgSVVwZGF0ZUxvYWRpbmdPcHRpb25zLFxuICAgIHNlY29uZD86IElVcGRhdGVMb2FkaW5nT3B0aW9ucyxcbiAgKSB7XG4gICAgbGV0IGtleVBhcmFtOiBLZXkgfCBLZXlbXSB8IHVuZGVmaW5lZDtcbiAgICBsZXQgc3ViOiBTdWJzY3JpcHRpb24gfCBQcm9taXNlPHVua25vd24+IHwgdW5kZWZpbmVkO1xuXG4gICAgaWYgKGZpcnN0IGluc3RhbmNlb2YgU3Vic2NyaXB0aW9uKSB7XG4gICAgICBzdWIgPSBmaXJzdDtcbiAgICB9IGVsc2UgaWYgKGZpcnN0IGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgc3ViID0gZmlyc3Q7XG4gICAgfSBlbHNlIGlmIChmaXJzdCkge1xuICAgICAga2V5UGFyYW0gPSBmaXJzdC5rZXk7XG4gICAgfVxuXG4gICAgaWYgKHNlY29uZCAmJiBzZWNvbmQua2V5KSB7XG4gICAgICBrZXlQYXJhbSA9IHNlY29uZC5rZXk7XG4gICAgfVxuXG4gICAgY29uc3Qga2V5cyA9IHRoaXMubm9ybWFsaXplS2V5cyhrZXlQYXJhbSk7XG5cbiAgICBrZXlzLmZvckVhY2goa2V5ID0+IHtcbiAgICAgIGNvbnN0IGxvYWRpbmdTdGFjayA9IHRoaXMubG9hZGluZ1N0YWNrcy5nZXQoa2V5KTtcblxuICAgICAgLy8gIWxvYWRpbmdTdGFjayBtZWFucyB0aGF0IGEgdXNlciBoYXMgY2FsbGVkIHJlbW92ZSgpIG5lZWRsZXNzbHlcbiAgICAgIGlmICghbG9hZGluZ1N0YWNrKSByZXR1cm47XG5cbiAgICAgIGNvbnN0IGluZGV4ID0gbG9hZGluZ1N0YWNrLmluZGV4T2Yoc3ViIHx8IHRydWUpO1xuXG4gICAgICBpZiAoaW5kZXggPj0gMCkge1xuICAgICAgICBsb2FkaW5nU3RhY2suc3BsaWNlKGluZGV4LCAxKTtcblxuICAgICAgICB0aGlzLnVwZGF0ZUxvYWRpbmdTdGF0dXMoa2V5KTtcblxuICAgICAgICB0aGlzLmRlSW5kZXhLZXkoa2V5KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIHByaXZhdGUgbm9ybWFsaXplS2V5cyhrZXk/OiBLZXkgfCBLZXlbXSk6IEtleVtdIHtcbiAgICBpZiAoIWtleSkga2V5ID0gW3RoaXMuZGVmYXVsdEtleV07XG4gICAgZWxzZSBpZiAoIUFycmF5LmlzQXJyYXkoa2V5KSkga2V5ID0gW2tleV07XG4gICAgcmV0dXJuIGtleSBhcyBLZXlbXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBgaW5kZXhLZXlzKClgIGFsb25nIHdpdGggYGRlSW5kZXhLZXlzKClgIGhlbHBzIHVzIHRyYWNrIHdoaWNoXG4gICAqIGtleXMgYXJlIGJlaW5nIHdhdGNoZWQgc28gdGhhdCB1bnVzZWQga2V5cyBjYW4gYmUgZGVsZXRlZFxuICAgKiAvIGdhcmJhZ2UgY29sbGVjdGVkLlxuICAgKlxuICAgKiBXaGVuIGBpbmRleEtleXMoKWAgaXMgY2FsbGVkIHdpdGggYW4gYXJyYXkgb2Yga2V5cywgaXQgbWVhbnNcbiAgICogdGhhdCBlYWNoIG9mIHRob3NlIGtleXMgaGFzIGF0IGxlYXN0IG9uZSBcInRoaW5nXCIgaW50ZXJlc3RlZFxuICAgKiBpbiBpdC4gVGhlcmVmb3JlLCB3ZSBuZWVkIHRvIG1ha2Ugc3VyZSB0aGF0IGEgbG9hZGluZ1N1YmplY3RcbiAgICogYW5kIGxvYWRpbmdTdGFjayBleGlzdHMgZm9yIHRoYXQga2V5LiBXZSBhbHNvIG5lZWQgdG8gaW5kZXhcbiAgICogdGhlIG51bWJlciBvZiBcInRoaW5nc1wiIGludGVyZXN0ZWQgaW4gdGhhdCBrZXkgaW4gdGhlXG4gICAqIGBsb2FkaW5nS2V5SW5kZXhgIG1hcC5cbiAgICpcbiAgICogV2hlbiBgZGVJbmRleEtleXMoKWAgaXMgY2FsbGVkIHdpdGggYW4gYXJyYXkgb2Yga2V5cywgaXRcbiAgICogbWVhbnMgdGhhdCBzb21lIFwidGhpbmdcIiBpcyBubyBsb25nZXIgaW50ZXJlc3RlZCBpbiBlYWNoXG4gICAqIG9mIHRob3NlIGtleXMuIFRoZXJlZm9yZSwgd2UgbmVlZCB0byByZS1pbmRleFxuICAgKiB0aGUgbnVtYmVyIG9mIFwidGhpbmdzXCIgaW50ZXJlc3RlZCBpbiBlYWNoIGtleS4gRm9yIGtleXNcbiAgICogdGhhdCBubyBsb25nZXIgaGF2ZSBhbnl0aGluZyBpbnRlcmVzdGVkIGluIHRoZW0sIHdlIG5lZWRcbiAgICogdG8gZGVsZXRlIHRoZSBhc3NvY2lhdGVkIGBsb2FkaW5nS2V5SW5kZXhgLCBgbG9hZGluZ1N1YmplY3RgLFxuICAgKiBhbmQgYGxvYWRpbmdTdGFja2AuIFNvIHRoYXQgdGhlIGBrZXlgIGNhbiBiZSBwcm9wZXJseVxuICAgKiByZWxlYXNlZCBmb3IgZ2FyYmFnZSBjb2xsZWN0aW9uLlxuICAgKi9cblxuICBwcml2YXRlIGluZGV4S2V5cyhrZXlzOiBLZXlbXSkge1xuICAgIGtleXMuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgaWYgKHRoaXMubG9hZGluZ0tleUluZGV4LmhhcyhrZXkpKSB7XG4gICAgICAgIGNvbnN0IGN1cnIgPSB0aGlzLmxvYWRpbmdLZXlJbmRleC5nZXQoa2V5KSE7XG4gICAgICAgIHRoaXMubG9hZGluZ0tleUluZGV4LnNldChrZXksIGN1cnIgKyAxKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IHN1YmplY3QgPSBuZXcgQmVoYXZpb3JTdWJqZWN0KGZhbHNlKTtcblxuICAgICAgICB0aGlzLmxvYWRpbmdLZXlJbmRleC5zZXQoa2V5LCAxKTtcbiAgICAgICAgdGhpcy5sb2FkaW5nU3ViamVjdHMuc2V0KGtleSwgc3ViamVjdCk7XG4gICAgICAgIHRoaXMubG9hZGluZ1N0YWNrcy5zZXQoa2V5LCBbXSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBwcml2YXRlIGRlSW5kZXhLZXkoa2V5OiBLZXkpIHtcbiAgICBjb25zdCBjdXJyID0gdGhpcy5sb2FkaW5nS2V5SW5kZXguZ2V0KGtleSkhO1xuXG4gICAgaWYgKGN1cnIgPT09IDEpIHtcbiAgICAgIHRoaXMubG9hZGluZ0tleUluZGV4LmRlbGV0ZShrZXkpO1xuICAgICAgdGhpcy5sb2FkaW5nU3ViamVjdHMuZGVsZXRlKGtleSk7XG4gICAgICB0aGlzLmxvYWRpbmdTdGFja3MuZGVsZXRlKGtleSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMubG9hZGluZ0tleUluZGV4LnNldChrZXksIGN1cnIgLSAxKTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIHVwZGF0ZUxvYWRpbmdTdGF0dXMoa2V5OiBLZXkpIHtcbiAgICBjb25zdCBsb2FkaW5nU3RhdHVzID0gdGhpcy5sb2FkaW5nU3RhY2tzLmdldChrZXkpIS5sZW5ndGggPiAwO1xuXG4gICAgdGhpcy5sb2FkaW5nU3ViamVjdHMuZ2V0KGtleSkhLm5leHQobG9hZGluZ1N0YXR1cyk7XG4gIH1cbn1cbiJdfQ==