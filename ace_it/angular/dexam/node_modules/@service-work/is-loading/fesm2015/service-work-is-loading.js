import { distinctUntilChanged, debounceTime, take } from 'rxjs/operators';
import { BehaviorSubject, Subscription, Observable } from 'rxjs';
import { Injectable, Component, ChangeDetectorRef, ElementRef, NgModule, InjectionToken, Pipe, Directive, Input, Renderer2, ComponentFactoryResolver, Injector, Inject, Optional, defineInjectable } from '@angular/core';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class IsLoadingService {
    constructor() {
        this.defaultKey = 'default';
        // provides an observable indicating if a particular key is loading
        this.loadingSubjects = new Map();
        // tracks how many "things" are loading for each key
        this.loadingStacks = new Map();
        // tracks which keys are being watched so that unused keys
        // can be deleted/garbage collected.
        this.loadingKeyIndex = new Map();
    }
    /**
     * Used to determine if something is loading or not.
     *
     * When called without arguments, returns the default *isLoading*
     * observable for your app. When called with an options object
     * containing a `key` property, returns the *isLoading* observable
     * corresponding to that key.
     *
     * Internally, *isLoading* observables are `BehaviorSubject`s, so
     * they will return values immediately upon subscription.
     *
     * When called, this method creates a new observable and returns it.
     * This means that you should not use this method directly in an Angular
     * template because each time the method is called it will look
     * (to Angular change detection) like the value has changed. To make
     * subscribing in templates easier, check out the `IsLoadingPipe`.
     * Alternatively, store the observable returned from this method in
     * a variable on your component and use that variable inside your
     * template.
     *
     * Example:
     *
     * ```ts
     *  class MyCustomComponent implements OnInit {
     *    variableForUseInTemplate: Observable<boolean>;
     *
     *    constructor(private loadingService: IsLoadingService) {}
     *
     *    ngOnInit() {
     *      this.variableForUseInTemplate =
     *        this.loadingService.isLoading$({key: 'button'});
     *
     *      this.loadingService.isLoading$().subscribe(value => {
     *        // ... do stuff
     *      });
     *
     *      this.loadingService
     *        .isLoading$({key: MyCustomComponent})
     *        .subscribe(value => {
     *          // ... do stuff
     *        });
     *    }
     *  }
     * ```
     *
     * @param {?=} args
     * @return {?}
     */
    isLoading$(args = {}) {
        /** @type {?} */
        const keys = this.normalizeKeys(args.key);
        return new Observable((/**
         * @param {?} observer
         * @return {?}
         */
        observer => {
            // this function will called each time this
            // Observable is subscribed to.
            this.indexKeys(keys);
            /** @type {?} */
            const subscription = (/** @type {?} */ (this.loadingSubjects
                .get(keys[0]))).pipe(distinctUntilChanged(), debounceTime(10), distinctUntilChanged())
                .subscribe({
                /**
                 * @param {?} value
                 * @return {?}
                 */
                next(value) {
                    observer.next(value);
                },
                /**
                 * @param {?} err
                 * @return {?}
                 */
                error(err) {
                    observer.error(err);
                },
                /**
                 * @return {?}
                 */
                complete() {
                    observer.complete();
                },
            });
            // the return value is the teardown function,
            // which will be invoked when the new
            // Observable is unsubscribed from.
            return (/**
             * @return {?}
             */
            () => {
                subscription.unsubscribe();
                keys.forEach((/**
                 * @param {?} key
                 * @return {?}
                 */
                key => this.deIndexKey(key)));
            });
        }));
    }
    /**
     * Same as `isLoading$()` except a boolean is returned,
     * rather than an observable.
     *
     * @param {?=} args
     * @return {?}
     */
    isLoading(args = {}) {
        /** @type {?} */
        const key = this.normalizeKeys(args.key)[0];
        /** @type {?} */
        const obs = this.loadingSubjects.get(key);
        return (obs && obs.value) || false;
    }
    /**
     * @param {?=} first
     * @param {?=} second
     * @return {?}
     */
    add(first, second) {
        /** @type {?} */
        let keyParam;
        /** @type {?} */
        let sub;
        if (first instanceof Subscription) {
            if (first.closed)
                return first;
            sub = first;
            first.add((/**
             * @return {?}
             */
            () => this.remove(first, second)));
        }
        else if (first instanceof Promise) {
            sub = first;
            // If the promise is already resolved, this executes syncronously
            first.then((/**
             * @return {?}
             */
            () => this.remove(first, second)), (/**
             * @return {?}
             */
            () => this.remove(first, second)));
        }
        else if (first instanceof Observable) {
            sub = first.pipe(take(1)).subscribe();
            if (sub.closed)
                return first;
            sub.add((/**
             * @return {?}
             */
            () => this.remove((/** @type {?} */ (sub)), second)));
        }
        else if (first) {
            keyParam = first.key;
        }
        if (second && second.key) {
            keyParam = second.key;
        }
        /** @type {?} */
        const keys = this.normalizeKeys(keyParam);
        this.indexKeys(keys);
        keys.forEach((/**
         * @param {?} key
         * @return {?}
         */
        key => {
            (/** @type {?} */ (this.loadingStacks.get(key))).push(sub || true);
            this.updateLoadingStatus(key);
        }));
        return first instanceof Observable ? first : sub;
    }
    /**
     * @param {?=} first
     * @param {?=} second
     * @return {?}
     */
    remove(first, second) {
        /** @type {?} */
        let keyParam;
        /** @type {?} */
        let sub;
        if (first instanceof Subscription) {
            sub = first;
        }
        else if (first instanceof Promise) {
            sub = first;
        }
        else if (first) {
            keyParam = first.key;
        }
        if (second && second.key) {
            keyParam = second.key;
        }
        /** @type {?} */
        const keys = this.normalizeKeys(keyParam);
        keys.forEach((/**
         * @param {?} key
         * @return {?}
         */
        key => {
            /** @type {?} */
            const loadingStack = this.loadingStacks.get(key);
            // !loadingStack means that a user has called remove() needlessly
            if (!loadingStack)
                return;
            /** @type {?} */
            const index = loadingStack.indexOf(sub || true);
            if (index >= 0) {
                loadingStack.splice(index, 1);
                this.updateLoadingStatus(key);
                this.deIndexKey(key);
            }
        }));
    }
    /**
     * @private
     * @param {?=} key
     * @return {?}
     */
    normalizeKeys(key) {
        if (!key)
            key = [this.defaultKey];
        else if (!Array.isArray(key))
            key = [key];
        return (/** @type {?} */ (key));
    }
    /**
     * `indexKeys()` along with `deIndexKeys()` helps us track which
     * keys are being watched so that unused keys can be deleted
     * / garbage collected.
     *
     * When `indexKeys()` is called with an array of keys, it means
     * that each of those keys has at least one "thing" interested
     * in it. Therefore, we need to make sure that a loadingSubject
     * and loadingStack exists for that key. We also need to index
     * the number of "things" interested in that key in the
     * `loadingKeyIndex` map.
     *
     * When `deIndexKeys()` is called with an array of keys, it
     * means that some "thing" is no longer interested in each
     * of those keys. Therefore, we need to re-index
     * the number of "things" interested in each key. For keys
     * that no longer have anything interested in them, we need
     * to delete the associated `loadingKeyIndex`, `loadingSubject`,
     * and `loadingStack`. So that the `key` can be properly
     * released for garbage collection.
     * @private
     * @param {?} keys
     * @return {?}
     */
    indexKeys(keys) {
        keys.forEach((/**
         * @param {?} key
         * @return {?}
         */
        key => {
            if (this.loadingKeyIndex.has(key)) {
                /** @type {?} */
                const curr = (/** @type {?} */ (this.loadingKeyIndex.get(key)));
                this.loadingKeyIndex.set(key, curr + 1);
            }
            else {
                /** @type {?} */
                const subject = new BehaviorSubject(false);
                this.loadingKeyIndex.set(key, 1);
                this.loadingSubjects.set(key, subject);
                this.loadingStacks.set(key, []);
            }
        }));
    }
    /**
     * @private
     * @param {?} key
     * @return {?}
     */
    deIndexKey(key) {
        /** @type {?} */
        const curr = (/** @type {?} */ (this.loadingKeyIndex.get(key)));
        if (curr === 1) {
            this.loadingKeyIndex.delete(key);
            this.loadingSubjects.delete(key);
            this.loadingStacks.delete(key);
        }
        else {
            this.loadingKeyIndex.set(key, curr - 1);
        }
    }
    /**
     * @private
     * @param {?} key
     * @return {?}
     */
    updateLoadingStatus(key) {
        /** @type {?} */
        const loadingStatus = (/** @type {?} */ (this.loadingStacks.get(key))).length > 0;
        (/** @type {?} */ (this.loadingSubjects.get(key))).next(loadingStatus);
    }
}
IsLoadingService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root',
            },] }
];
/** @nocollapse */
IsLoadingService.ctorParameters = () => [];
/** @nocollapse */ IsLoadingService.ngInjectableDef = defineInjectable({ factory: function IsLoadingService_Factory() { return new IsLoadingService(); }, token: IsLoadingService, providedIn: "root" });

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class IsLoadingSpinnerComponent {
    // don't need change detection for this component
    /**
     * @param {?} cdr
     * @param {?} el
     */
    constructor(cdr, el) {
        this.cdr = cdr;
        this.el = el;
        this.cdr.detach();
    }
}
IsLoadingSpinnerComponent.decorators = [
    { type: Component, args: [{
                selector: 'sw-is-loading-spinner',
                template: ``,
                host: { class: 'sw-is-loading-spinner' }
            }] }
];
/** @nocollapse */
IsLoadingSpinnerComponent.ctorParameters = () => [
    { type: ChangeDetectorRef },
    { type: ElementRef }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const SW_IS_LOADING_DIRECTIVE_CONFIG = new InjectionToken('SW_IS_LOADING_DIRECTIVE_CONFIG');

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
// This code was inspired by angular2-promise-buttons
// https://github.com/johannesjo/angular2-promise-buttons
class IsLoadingDirective {
    /**
     * @param {?} config
     * @param {?} renderer
     * @param {?} isLoadingService
     * @param {?} el
     * @param {?} componentFactoryResolver
     * @param {?} injector
     */
    constructor(config, renderer, isLoadingService, el, componentFactoryResolver, injector) {
        this.renderer = renderer;
        this.isLoadingService = isLoadingService;
        this.el = el;
        this.componentFactoryResolver = componentFactoryResolver;
        this.injector = injector;
        this._isLoading = false;
        this.config = {};
        this._swIsLoadingDisableEl = this.config.disableEl === undefined ? true : this.config.disableEl;
        this._swIsLoadingSpinner = this.config.addSpinnerEl !== undefined
            ? this.config.addSpinnerEl
            : this.el.nativeElement instanceof HTMLButtonElement ||
                this.el.nativeElement instanceof HTMLAnchorElement;
        this.loadingClass = this.config.loadingClass
            ? this.config.loadingClass
            : 'sw-is-loading';
        this.config = config || {};
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set swIsLoading(value) {
        if (typeof value === 'string') {
            this.stringValue(value);
        }
        else {
            this.notStringValue();
        }
        if (value instanceof Subscription) {
            this.subscriptionValue(value);
        }
        else {
            this.notSubscriptionValue();
        }
        if (value instanceof Promise) {
            this.promiseValue(value);
        }
        else {
            this.notPromiseValue();
        }
        if (typeof value === 'boolean') {
            this.booleanValue(value);
        }
        else {
            this.notBooleanValue();
        }
        if (value instanceof Observable) {
            this.observableValue();
        }
        else {
            this.notObservableValue();
        }
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set swIsLoadingDisableEl(value) {
        this._swIsLoadingDisableEl = coerceBooleanValue(value);
    }
    /**
     * @return {?}
     */
    get swIsLoadingDisableEl() {
        return this._swIsLoadingDisableEl;
    }
    // By default, if this directive is attached to an anchor or a button
    // element, add a `sw-is-loading-spinner` element to the dom (for styling)
    /**
     * @param {?} value
     * @return {?}
     */
    set swIsLoadingSpinner(value) {
        this._swIsLoadingSpinner = coerceBooleanValue(value);
    }
    /**
     * @return {?}
     */
    get swIsLoadingSpinner() {
        return this._swIsLoadingSpinner;
    }
    /**
     * @return {?}
     */
    get isLoading() {
        return this._isLoading;
    }
    /**
     * @private
     * @param {?} value
     * @return {?}
     */
    set pending(value) {
        this.startLoading();
        value.finally((/**
         * @return {?}
         */
        () => this.stopLoading()));
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        if (changes.swIsLoadingSpinner &&
            !changes.swIsLoadingSpinner.isFirstChange() &&
            !changes.swIsLoadingSpinner.currentValue) {
            this.removeSpinnerEl();
        }
        if (changes.swIsLoadingDisableEl &&
            !changes.swIsLoadingDisableEl.isFirstChange() &&
            !changes.swIsLoadingDisableEl.currentValue) {
            this.renderer.removeAttribute(this.el.nativeElement, 'disabled');
        }
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        if (this.swIsLoadingSpinner) {
            this.addSpinnerEl();
        }
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        if (this.textValueSubscription) {
            this.textValueSubscription.unsubscribe();
        }
    }
    /**
     * @private
     * @return {?}
     */
    startLoading() {
        this.renderer.addClass(this.el.nativeElement, this.loadingClass);
        if (this.swIsLoadingDisableEl) {
            this.renderer.setAttribute(this.el.nativeElement, 'disabled', 'disabled');
        }
        this._isLoading = true;
    }
    /**
     * @private
     * @return {?}
     */
    stopLoading() {
        this.renderer.removeClass(this.el.nativeElement, this.loadingClass);
        if (this.swIsLoadingDisableEl) {
            this.renderer.removeAttribute(this.el.nativeElement, 'disabled');
        }
        this._isLoading = false;
    }
    /**
     * @private
     * @return {?}
     */
    addSpinnerEl() {
        this.spinnerEl = this.componentFactoryResolver
            .resolveComponentFactory(IsLoadingSpinnerComponent)
            .create(this.injector);
        // need to use Renderer2#appendChild instead of
        // ViewContainerRef#createComponent because the injected
        // view container is not for the element this directive
        // is applied to
        this.renderer.appendChild(this.el.nativeElement, this.spinnerEl.instance.el.nativeElement);
    }
    /**
     * @private
     * @return {?}
     */
    removeSpinnerEl() {
        if (!this.spinnerEl)
            return;
        this.renderer.removeChild(this.el.nativeElement, this.spinnerEl.instance.el.nativeElement);
        this.spinnerEl.destroy();
        this.spinnerEl = undefined;
    }
    /**
     * Input value handlers
     * @private
     * @param {?} value
     * @return {?}
     */
    stringValue(value) {
        if (this.textValueSubscription) {
            this.textValueSubscription.unsubscribe();
        }
        /** @type {?} */
        let obs;
        if (!value) {
            obs = this.isLoadingService.isLoading$();
        }
        else {
            obs = this.isLoadingService.isLoading$({
                key: value,
            });
        }
        this.textValueSubscription = obs.subscribe((/**
         * @param {?} loading
         * @return {?}
         */
        loading => {
            if (loading) {
                this.startLoading();
            }
            else if (this.isLoading) {
                this.stopLoading();
            }
        }));
    }
    /**
     * @private
     * @return {?}
     */
    notStringValue() {
        if (this.textValueSubscription) {
            this.textValueSubscription.unsubscribe();
        }
    }
    /**
     * @private
     * @return {?}
     */
    observableValue() {
        throw new TypeError('swBtnPending must be an instance of Subscription, instance of Observable given');
    }
    /**
     * @private
     * @return {?}
     */
    notObservableValue() { }
    /**
     * @private
     * @param {?} value
     * @return {?}
     */
    subscriptionValue(value) {
        this.pending = new Promise((/**
         * @param {?} resolve
         * @return {?}
         */
        resolve => value.add(resolve)));
    }
    /**
     * @private
     * @return {?}
     */
    notSubscriptionValue() { }
    /**
     * @private
     * @param {?} value
     * @return {?}
     */
    promiseValue(value) {
        this.pending = value;
    }
    /**
     * @private
     * @return {?}
     */
    notPromiseValue() { }
    /**
     * @private
     * @param {?} value
     * @return {?}
     */
    booleanValue(value) {
        if (value) {
            this.pending = new Promise((/**
             * @param {?} resolve
             * @return {?}
             */
            resolve => {
                this.booleanValueResolveFn = resolve;
            }));
        }
        else if (this.booleanValueResolveFn) {
            this.booleanValueResolveFn();
        }
        else {
            this.stopLoading();
        }
    }
    /**
     * @private
     * @return {?}
     */
    notBooleanValue() {
        if (this.booleanValueResolveFn) {
            this.booleanValueResolveFn();
        }
    }
}
IsLoadingDirective.decorators = [
    { type: Directive, args: [{
                selector: '[swIsLoading]',
                exportAs: 'swIsLoading',
            },] }
];
/** @nocollapse */
IsLoadingDirective.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [SW_IS_LOADING_DIRECTIVE_CONFIG,] }] },
    { type: Renderer2 },
    { type: IsLoadingService },
    { type: ElementRef },
    { type: ComponentFactoryResolver },
    { type: Injector }
];
IsLoadingDirective.propDecorators = {
    swIsLoading: [{ type: Input }],
    swIsLoadingDisableEl: [{ type: Input }],
    swIsLoadingSpinner: [{ type: Input }]
};
/**
 * @param {?} val
 * @return {?}
 */
function coerceBooleanValue(val) {
    if (typeof val === 'boolean')
        return val;
    if (['', 'true'].includes(val))
        return true;
    return false;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class IsLoadingDirectiveModule {
}
IsLoadingDirectiveModule.decorators = [
    { type: NgModule, args: [{
                declarations: [IsLoadingDirective, IsLoadingSpinnerComponent],
                entryComponents: [IsLoadingSpinnerComponent],
                exports: [IsLoadingDirective],
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class IsLoadingPipe {
    /**
     * @param {?} isLoadingService
     */
    constructor(isLoadingService) {
        this.isLoadingService = isLoadingService;
    }
    /**
     * @param {?} key
     * @return {?}
     */
    transform(key) {
        return this.isLoadingService.isLoading$({ key });
    }
}
IsLoadingPipe.decorators = [
    { type: Pipe, args: [{
                name: 'swIsLoading',
            },] }
];
/** @nocollapse */
IsLoadingPipe.ctorParameters = () => [
    { type: IsLoadingService }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class IsLoadingPipeModule {
}
IsLoadingPipeModule.decorators = [
    { type: NgModule, args: [{
                declarations: [IsLoadingPipe],
                exports: [IsLoadingPipe],
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class IsLoadingModule {
}
IsLoadingModule.decorators = [
    { type: NgModule, args: [{
                imports: [IsLoadingDirectiveModule, IsLoadingPipeModule],
                providers: [],
                exports: [IsLoadingDirectiveModule, IsLoadingPipeModule],
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

export { IsLoadingService, IsLoadingModule, IsLoadingDirectiveModule, IsLoadingDirective, SW_IS_LOADING_DIRECTIVE_CONFIG, IsLoadingPipeModule, IsLoadingPipe, IsLoadingSpinnerComponent as ɵa };

//# sourceMappingURL=service-work-is-loading.js.map