(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('rxjs/operators'), require('rxjs'), require('@angular/core')) :
    typeof define === 'function' && define.amd ? define('@service-work/is-loading', ['exports', 'rxjs/operators', 'rxjs', '@angular/core'], factory) :
    (factory((global['service-work'] = global['service-work'] || {}, global['service-work']['is-loading'] = {}),global.rxjs.operators,global.rxjs,global.ng.core));
}(this, (function (exports,operators,rxjs,i0) { 'use strict';

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var IsLoadingService = /** @class */ (function () {
        function IsLoadingService() {
            this.defaultKey = 'default';
            // provides an observable indicating if a particular key is loading
            this.loadingSubjects = new Map();
            // tracks how many "things" are loading for each key
            this.loadingStacks = new Map();
            // tracks which keys are being watched so that unused keys
            // can be deleted/garbage collected.
            this.loadingKeyIndex = new Map();
        }
        /**
         * Used to determine if something is loading or not.
         *
         * When called without arguments, returns the default *isLoading*
         * observable for your app. When called with an options object
         * containing a `key` property, returns the *isLoading* observable
         * corresponding to that key.
         *
         * Internally, *isLoading* observables are `BehaviorSubject`s, so
         * they will return values immediately upon subscription.
         *
         * When called, this method creates a new observable and returns it.
         * This means that you should not use this method directly in an Angular
         * template because each time the method is called it will look
         * (to Angular change detection) like the value has changed. To make
         * subscribing in templates easier, check out the `IsLoadingPipe`.
         * Alternatively, store the observable returned from this method in
         * a variable on your component and use that variable inside your
         * template.
         *
         * Example:
         *
         * ```ts
         *  class MyCustomComponent implements OnInit {
         *    variableForUseInTemplate: Observable<boolean>;
         *
         *    constructor(private loadingService: IsLoadingService) {}
         *
         *    ngOnInit() {
         *      this.variableForUseInTemplate =
         *        this.loadingService.isLoading$({key: 'button'});
         *
         *      this.loadingService.isLoading$().subscribe(value => {
         *        // ... do stuff
         *      });
         *
         *      this.loadingService
         *        .isLoading$({key: MyCustomComponent})
         *        .subscribe(value => {
         *          // ... do stuff
         *        });
         *    }
         *  }
         * ```
         *
         * @param args.key optionally specify the key to subscribe to
         */
        /**
         * Used to determine if something is loading or not.
         *
         * When called without arguments, returns the default *isLoading*
         * observable for your app. When called with an options object
         * containing a `key` property, returns the *isLoading* observable
         * corresponding to that key.
         *
         * Internally, *isLoading* observables are `BehaviorSubject`s, so
         * they will return values immediately upon subscription.
         *
         * When called, this method creates a new observable and returns it.
         * This means that you should not use this method directly in an Angular
         * template because each time the method is called it will look
         * (to Angular change detection) like the value has changed. To make
         * subscribing in templates easier, check out the `IsLoadingPipe`.
         * Alternatively, store the observable returned from this method in
         * a variable on your component and use that variable inside your
         * template.
         *
         * Example:
         *
         * ```ts
         *  class MyCustomComponent implements OnInit {
         *    variableForUseInTemplate: Observable<boolean>;
         *
         *    constructor(private loadingService: IsLoadingService) {}
         *
         *    ngOnInit() {
         *      this.variableForUseInTemplate =
         *        this.loadingService.isLoading$({key: 'button'});
         *
         *      this.loadingService.isLoading$().subscribe(value => {
         *        // ... do stuff
         *      });
         *
         *      this.loadingService
         *        .isLoading$({key: MyCustomComponent})
         *        .subscribe(value => {
         *          // ... do stuff
         *        });
         *    }
         *  }
         * ```
         *
         * @param {?=} args
         * @return {?}
         */
        IsLoadingService.prototype.isLoading$ = /**
         * Used to determine if something is loading or not.
         *
         * When called without arguments, returns the default *isLoading*
         * observable for your app. When called with an options object
         * containing a `key` property, returns the *isLoading* observable
         * corresponding to that key.
         *
         * Internally, *isLoading* observables are `BehaviorSubject`s, so
         * they will return values immediately upon subscription.
         *
         * When called, this method creates a new observable and returns it.
         * This means that you should not use this method directly in an Angular
         * template because each time the method is called it will look
         * (to Angular change detection) like the value has changed. To make
         * subscribing in templates easier, check out the `IsLoadingPipe`.
         * Alternatively, store the observable returned from this method in
         * a variable on your component and use that variable inside your
         * template.
         *
         * Example:
         *
         * ```ts
         *  class MyCustomComponent implements OnInit {
         *    variableForUseInTemplate: Observable<boolean>;
         *
         *    constructor(private loadingService: IsLoadingService) {}
         *
         *    ngOnInit() {
         *      this.variableForUseInTemplate =
         *        this.loadingService.isLoading$({key: 'button'});
         *
         *      this.loadingService.isLoading$().subscribe(value => {
         *        // ... do stuff
         *      });
         *
         *      this.loadingService
         *        .isLoading$({key: MyCustomComponent})
         *        .subscribe(value => {
         *          // ... do stuff
         *        });
         *    }
         *  }
         * ```
         *
         * @param {?=} args
         * @return {?}
         */
            function (args) {
                var _this = this;
                if (args === void 0) {
                    args = {};
                }
                /** @type {?} */
                var keys = this.normalizeKeys(args.key);
                return new rxjs.Observable(( /**
                 * @param {?} observer
                 * @return {?}
                 */function (observer) {
                    // this function will called each time this
                    // Observable is subscribed to.
                    _this.indexKeys(keys);
                    /** @type {?} */
                    var subscription = ( /** @type {?} */(_this.loadingSubjects
                        .get(keys[0]))).pipe(operators.distinctUntilChanged(), operators.debounceTime(10), operators.distinctUntilChanged())
                        .subscribe({
                        next: /**
                         * @param {?} value
                         * @return {?}
                         */ function (value) {
                            observer.next(value);
                        },
                        error: /**
                         * @param {?} err
                         * @return {?}
                         */ function (err) {
                            observer.error(err);
                        },
                        complete: /**
                         * @return {?}
                         */ function () {
                            observer.complete();
                        },
                    });
                    // the return value is the teardown function,
                    // which will be invoked when the new
                    // Observable is unsubscribed from.
                    return ( /**
                     * @return {?}
                     */function () {
                        subscription.unsubscribe();
                        keys.forEach(( /**
                         * @param {?} key
                         * @return {?}
                         */function (key) { return _this.deIndexKey(key); }));
                    });
                }));
            };
        /**
         * Same as `isLoading$()` except a boolean is returned,
         * rather than an observable.
         *
         * @param args.key optionally specify the key to check
         */
        /**
         * Same as `isLoading$()` except a boolean is returned,
         * rather than an observable.
         *
         * @param {?=} args
         * @return {?}
         */
        IsLoadingService.prototype.isLoading = /**
         * Same as `isLoading$()` except a boolean is returned,
         * rather than an observable.
         *
         * @param {?=} args
         * @return {?}
         */
            function (args) {
                if (args === void 0) {
                    args = {};
                }
                /** @type {?} */
                var key = this.normalizeKeys(args.key)[0];
                /** @type {?} */
                var obs = this.loadingSubjects.get(key);
                return (obs && obs.value) || false;
            };
        /**
         * @param {?=} first
         * @param {?=} second
         * @return {?}
         */
        IsLoadingService.prototype.add = /**
         * @param {?=} first
         * @param {?=} second
         * @return {?}
         */
            function (first, second) {
                var _this = this;
                /** @type {?} */
                var keyParam;
                /** @type {?} */
                var sub;
                if (first instanceof rxjs.Subscription) {
                    if (first.closed)
                        return first;
                    sub = first;
                    first.add(( /**
                     * @return {?}
                     */function () { return _this.remove(first, second); }));
                }
                else if (first instanceof Promise) {
                    sub = first;
                    // If the promise is already resolved, this executes syncronously
                    first.then(( /**
                     * @return {?}
                     */function () { return _this.remove(first, second); }), ( /**
                     * @return {?}
                     */function () { return _this.remove(first, second); }));
                }
                else if (first instanceof rxjs.Observable) {
                    sub = first.pipe(operators.take(1)).subscribe();
                    if (sub.closed)
                        return first;
                    sub.add(( /**
                     * @return {?}
                     */function () { return _this.remove(( /** @type {?} */(sub)), second); }));
                }
                else if (first) {
                    keyParam = first.key;
                }
                if (second && second.key) {
                    keyParam = second.key;
                }
                /** @type {?} */
                var keys = this.normalizeKeys(keyParam);
                this.indexKeys(keys);
                keys.forEach(( /**
                 * @param {?} key
                 * @return {?}
                 */function (key) {
                    ( /** @type {?} */(_this.loadingStacks.get(key))).push(sub || true);
                    _this.updateLoadingStatus(key);
                }));
                return first instanceof rxjs.Observable ? first : sub;
            };
        /**
         * @param {?=} first
         * @param {?=} second
         * @return {?}
         */
        IsLoadingService.prototype.remove = /**
         * @param {?=} first
         * @param {?=} second
         * @return {?}
         */
            function (first, second) {
                var _this = this;
                /** @type {?} */
                var keyParam;
                /** @type {?} */
                var sub;
                if (first instanceof rxjs.Subscription) {
                    sub = first;
                }
                else if (first instanceof Promise) {
                    sub = first;
                }
                else if (first) {
                    keyParam = first.key;
                }
                if (second && second.key) {
                    keyParam = second.key;
                }
                /** @type {?} */
                var keys = this.normalizeKeys(keyParam);
                keys.forEach(( /**
                 * @param {?} key
                 * @return {?}
                 */function (key) {
                    /** @type {?} */
                    var loadingStack = _this.loadingStacks.get(key);
                    // !loadingStack means that a user has called remove() needlessly
                    if (!loadingStack)
                        return;
                    /** @type {?} */
                    var index = loadingStack.indexOf(sub || true);
                    if (index >= 0) {
                        loadingStack.splice(index, 1);
                        _this.updateLoadingStatus(key);
                        _this.deIndexKey(key);
                    }
                }));
            };
        /**
         * @private
         * @param {?=} key
         * @return {?}
         */
        IsLoadingService.prototype.normalizeKeys = /**
         * @private
         * @param {?=} key
         * @return {?}
         */
            function (key) {
                if (!key)
                    key = [this.defaultKey];
                else if (!Array.isArray(key))
                    key = [key];
                return ( /** @type {?} */(key));
            };
        /**
         * `indexKeys()` along with `deIndexKeys()` helps us track which
         * keys are being watched so that unused keys can be deleted
         * / garbage collected.
         *
         * When `indexKeys()` is called with an array of keys, it means
         * that each of those keys has at least one "thing" interested
         * in it. Therefore, we need to make sure that a loadingSubject
         * and loadingStack exists for that key. We also need to index
         * the number of "things" interested in that key in the
         * `loadingKeyIndex` map.
         *
         * When `deIndexKeys()` is called with an array of keys, it
         * means that some "thing" is no longer interested in each
         * of those keys. Therefore, we need to re-index
         * the number of "things" interested in each key. For keys
         * that no longer have anything interested in them, we need
         * to delete the associated `loadingKeyIndex`, `loadingSubject`,
         * and `loadingStack`. So that the `key` can be properly
         * released for garbage collection.
         */
        /**
         * `indexKeys()` along with `deIndexKeys()` helps us track which
         * keys are being watched so that unused keys can be deleted
         * / garbage collected.
         *
         * When `indexKeys()` is called with an array of keys, it means
         * that each of those keys has at least one "thing" interested
         * in it. Therefore, we need to make sure that a loadingSubject
         * and loadingStack exists for that key. We also need to index
         * the number of "things" interested in that key in the
         * `loadingKeyIndex` map.
         *
         * When `deIndexKeys()` is called with an array of keys, it
         * means that some "thing" is no longer interested in each
         * of those keys. Therefore, we need to re-index
         * the number of "things" interested in each key. For keys
         * that no longer have anything interested in them, we need
         * to delete the associated `loadingKeyIndex`, `loadingSubject`,
         * and `loadingStack`. So that the `key` can be properly
         * released for garbage collection.
         * @private
         * @param {?} keys
         * @return {?}
         */
        IsLoadingService.prototype.indexKeys = /**
         * `indexKeys()` along with `deIndexKeys()` helps us track which
         * keys are being watched so that unused keys can be deleted
         * / garbage collected.
         *
         * When `indexKeys()` is called with an array of keys, it means
         * that each of those keys has at least one "thing" interested
         * in it. Therefore, we need to make sure that a loadingSubject
         * and loadingStack exists for that key. We also need to index
         * the number of "things" interested in that key in the
         * `loadingKeyIndex` map.
         *
         * When `deIndexKeys()` is called with an array of keys, it
         * means that some "thing" is no longer interested in each
         * of those keys. Therefore, we need to re-index
         * the number of "things" interested in each key. For keys
         * that no longer have anything interested in them, we need
         * to delete the associated `loadingKeyIndex`, `loadingSubject`,
         * and `loadingStack`. So that the `key` can be properly
         * released for garbage collection.
         * @private
         * @param {?} keys
         * @return {?}
         */
            function (keys) {
                var _this = this;
                keys.forEach(( /**
                 * @param {?} key
                 * @return {?}
                 */function (key) {
                    if (_this.loadingKeyIndex.has(key)) {
                        /** @type {?} */
                        var curr = ( /** @type {?} */(_this.loadingKeyIndex.get(key)));
                        _this.loadingKeyIndex.set(key, curr + 1);
                    }
                    else {
                        /** @type {?} */
                        var subject = new rxjs.BehaviorSubject(false);
                        _this.loadingKeyIndex.set(key, 1);
                        _this.loadingSubjects.set(key, subject);
                        _this.loadingStacks.set(key, []);
                    }
                }));
            };
        /**
         * @private
         * @param {?} key
         * @return {?}
         */
        IsLoadingService.prototype.deIndexKey = /**
         * @private
         * @param {?} key
         * @return {?}
         */
            function (key) {
                /** @type {?} */
                var curr = ( /** @type {?} */(this.loadingKeyIndex.get(key)));
                if (curr === 1) {
                    this.loadingKeyIndex.delete(key);
                    this.loadingSubjects.delete(key);
                    this.loadingStacks.delete(key);
                }
                else {
                    this.loadingKeyIndex.set(key, curr - 1);
                }
            };
        /**
         * @private
         * @param {?} key
         * @return {?}
         */
        IsLoadingService.prototype.updateLoadingStatus = /**
         * @private
         * @param {?} key
         * @return {?}
         */
            function (key) {
                /** @type {?} */
                var loadingStatus = ( /** @type {?} */(this.loadingStacks.get(key))).length > 0;
                ( /** @type {?} */(this.loadingSubjects.get(key))).next(loadingStatus);
            };
        IsLoadingService.decorators = [
            { type: i0.Injectable, args: [{
                        providedIn: 'root',
                    },] }
        ];
        /** @nocollapse */
        IsLoadingService.ctorParameters = function () { return []; };
        /** @nocollapse */ IsLoadingService.ngInjectableDef = i0.defineInjectable({ factory: function IsLoadingService_Factory() { return new IsLoadingService(); }, token: IsLoadingService, providedIn: "root" });
        return IsLoadingService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var IsLoadingSpinnerComponent = /** @class */ (function () {
        // don't need change detection for this component
        function IsLoadingSpinnerComponent(cdr, el) {
            this.cdr = cdr;
            this.el = el;
            this.cdr.detach();
        }
        IsLoadingSpinnerComponent.decorators = [
            { type: i0.Component, args: [{
                        selector: 'sw-is-loading-spinner',
                        template: "",
                        host: { class: 'sw-is-loading-spinner' }
                    }] }
        ];
        /** @nocollapse */
        IsLoadingSpinnerComponent.ctorParameters = function () {
            return [
                { type: i0.ChangeDetectorRef },
                { type: i0.ElementRef }
            ];
        };
        return IsLoadingSpinnerComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /** @type {?} */
    var SW_IS_LOADING_DIRECTIVE_CONFIG = new i0.InjectionToken('SW_IS_LOADING_DIRECTIVE_CONFIG');

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    // This code was inspired by angular2-promise-buttons
    // https://github.com/johannesjo/angular2-promise-buttons
    var IsLoadingDirective = /** @class */ (function () {
        function IsLoadingDirective(config, renderer, isLoadingService, el, componentFactoryResolver, injector) {
            this.renderer = renderer;
            this.isLoadingService = isLoadingService;
            this.el = el;
            this.componentFactoryResolver = componentFactoryResolver;
            this.injector = injector;
            this._isLoading = false;
            this.config = {};
            this._swIsLoadingDisableEl = this.config.disableEl === undefined ? true : this.config.disableEl;
            this._swIsLoadingSpinner = this.config.addSpinnerEl !== undefined
                ? this.config.addSpinnerEl
                : this.el.nativeElement instanceof HTMLButtonElement ||
                    this.el.nativeElement instanceof HTMLAnchorElement;
            this.loadingClass = this.config.loadingClass
                ? this.config.loadingClass
                : 'sw-is-loading';
            this.config = config || {};
        }
        Object.defineProperty(IsLoadingDirective.prototype, "swIsLoading", {
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                if (typeof value === 'string') {
                    this.stringValue(value);
                }
                else {
                    this.notStringValue();
                }
                if (value instanceof rxjs.Subscription) {
                    this.subscriptionValue(value);
                }
                else {
                    this.notSubscriptionValue();
                }
                if (value instanceof Promise) {
                    this.promiseValue(value);
                }
                else {
                    this.notPromiseValue();
                }
                if (typeof value === 'boolean') {
                    this.booleanValue(value);
                }
                else {
                    this.notBooleanValue();
                }
                if (value instanceof rxjs.Observable) {
                    this.observableValue();
                }
                else {
                    this.notObservableValue();
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IsLoadingDirective.prototype, "swIsLoadingDisableEl", {
            get: /**
             * @return {?}
             */ function () {
                return this._swIsLoadingDisableEl;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._swIsLoadingDisableEl = coerceBooleanValue(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IsLoadingDirective.prototype, "swIsLoadingSpinner", {
            get: /**
             * @return {?}
             */ function () {
                return this._swIsLoadingSpinner;
            },
            // By default, if this directive is attached to an anchor or a button
            // element, add a `sw-is-loading-spinner` element to the dom (for styling)
            set: 
            // By default, if this directive is attached to an anchor or a button
            // element, add a `sw-is-loading-spinner` element to the dom (for styling)
            /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                this._swIsLoadingSpinner = coerceBooleanValue(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IsLoadingDirective.prototype, "isLoading", {
            get: /**
             * @return {?}
             */ function () {
                return this._isLoading;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IsLoadingDirective.prototype, "pending", {
            set: /**
             * @private
             * @param {?} value
             * @return {?}
             */ function (value) {
                var _this = this;
                this.startLoading();
                value.finally(( /**
                 * @return {?}
                 */function () { return _this.stopLoading(); }));
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @param {?} changes
         * @return {?}
         */
        IsLoadingDirective.prototype.ngOnChanges = /**
         * @param {?} changes
         * @return {?}
         */
            function (changes) {
                if (changes.swIsLoadingSpinner &&
                    !changes.swIsLoadingSpinner.isFirstChange() &&
                    !changes.swIsLoadingSpinner.currentValue) {
                    this.removeSpinnerEl();
                }
                if (changes.swIsLoadingDisableEl &&
                    !changes.swIsLoadingDisableEl.isFirstChange() &&
                    !changes.swIsLoadingDisableEl.currentValue) {
                    this.renderer.removeAttribute(this.el.nativeElement, 'disabled');
                }
            };
        /**
         * @return {?}
         */
        IsLoadingDirective.prototype.ngAfterViewInit = /**
         * @return {?}
         */
            function () {
                if (this.swIsLoadingSpinner) {
                    this.addSpinnerEl();
                }
            };
        /**
         * @return {?}
         */
        IsLoadingDirective.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                if (this.textValueSubscription) {
                    this.textValueSubscription.unsubscribe();
                }
            };
        /**
         * @private
         * @return {?}
         */
        IsLoadingDirective.prototype.startLoading = /**
         * @private
         * @return {?}
         */
            function () {
                this.renderer.addClass(this.el.nativeElement, this.loadingClass);
                if (this.swIsLoadingDisableEl) {
                    this.renderer.setAttribute(this.el.nativeElement, 'disabled', 'disabled');
                }
                this._isLoading = true;
            };
        /**
         * @private
         * @return {?}
         */
        IsLoadingDirective.prototype.stopLoading = /**
         * @private
         * @return {?}
         */
            function () {
                this.renderer.removeClass(this.el.nativeElement, this.loadingClass);
                if (this.swIsLoadingDisableEl) {
                    this.renderer.removeAttribute(this.el.nativeElement, 'disabled');
                }
                this._isLoading = false;
            };
        /**
         * @private
         * @return {?}
         */
        IsLoadingDirective.prototype.addSpinnerEl = /**
         * @private
         * @return {?}
         */
            function () {
                this.spinnerEl = this.componentFactoryResolver
                    .resolveComponentFactory(IsLoadingSpinnerComponent)
                    .create(this.injector);
                // need to use Renderer2#appendChild instead of
                // ViewContainerRef#createComponent because the injected
                // view container is not for the element this directive
                // is applied to
                this.renderer.appendChild(this.el.nativeElement, this.spinnerEl.instance.el.nativeElement);
            };
        /**
         * @private
         * @return {?}
         */
        IsLoadingDirective.prototype.removeSpinnerEl = /**
         * @private
         * @return {?}
         */
            function () {
                if (!this.spinnerEl)
                    return;
                this.renderer.removeChild(this.el.nativeElement, this.spinnerEl.instance.el.nativeElement);
                this.spinnerEl.destroy();
                this.spinnerEl = undefined;
            };
        /**
         * Input value handlers
         */
        /**
         * Input value handlers
         * @private
         * @param {?} value
         * @return {?}
         */
        IsLoadingDirective.prototype.stringValue = /**
         * Input value handlers
         * @private
         * @param {?} value
         * @return {?}
         */
            function (value) {
                var _this = this;
                if (this.textValueSubscription) {
                    this.textValueSubscription.unsubscribe();
                }
                /** @type {?} */
                var obs;
                if (!value) {
                    obs = this.isLoadingService.isLoading$();
                }
                else {
                    obs = this.isLoadingService.isLoading$({
                        key: value,
                    });
                }
                this.textValueSubscription = obs.subscribe(( /**
                 * @param {?} loading
                 * @return {?}
                 */function (loading) {
                    if (loading) {
                        _this.startLoading();
                    }
                    else if (_this.isLoading) {
                        _this.stopLoading();
                    }
                }));
            };
        /**
         * @private
         * @return {?}
         */
        IsLoadingDirective.prototype.notStringValue = /**
         * @private
         * @return {?}
         */
            function () {
                if (this.textValueSubscription) {
                    this.textValueSubscription.unsubscribe();
                }
            };
        /**
         * @private
         * @return {?}
         */
        IsLoadingDirective.prototype.observableValue = /**
         * @private
         * @return {?}
         */
            function () {
                throw new TypeError('swBtnPending must be an instance of Subscription, instance of Observable given');
            };
        /**
         * @private
         * @return {?}
         */
        IsLoadingDirective.prototype.notObservableValue = /**
         * @private
         * @return {?}
         */
            function () { };
        /**
         * @private
         * @param {?} value
         * @return {?}
         */
        IsLoadingDirective.prototype.subscriptionValue = /**
         * @private
         * @param {?} value
         * @return {?}
         */
            function (value) {
                this.pending = new Promise(( /**
                 * @param {?} resolve
                 * @return {?}
                 */function (resolve) { return value.add(resolve); }));
            };
        /**
         * @private
         * @return {?}
         */
        IsLoadingDirective.prototype.notSubscriptionValue = /**
         * @private
         * @return {?}
         */
            function () { };
        /**
         * @private
         * @param {?} value
         * @return {?}
         */
        IsLoadingDirective.prototype.promiseValue = /**
         * @private
         * @param {?} value
         * @return {?}
         */
            function (value) {
                this.pending = value;
            };
        /**
         * @private
         * @return {?}
         */
        IsLoadingDirective.prototype.notPromiseValue = /**
         * @private
         * @return {?}
         */
            function () { };
        /**
         * @private
         * @param {?} value
         * @return {?}
         */
        IsLoadingDirective.prototype.booleanValue = /**
         * @private
         * @param {?} value
         * @return {?}
         */
            function (value) {
                var _this = this;
                if (value) {
                    this.pending = new Promise(( /**
                     * @param {?} resolve
                     * @return {?}
                     */function (resolve) {
                        _this.booleanValueResolveFn = resolve;
                    }));
                }
                else if (this.booleanValueResolveFn) {
                    this.booleanValueResolveFn();
                }
                else {
                    this.stopLoading();
                }
            };
        /**
         * @private
         * @return {?}
         */
        IsLoadingDirective.prototype.notBooleanValue = /**
         * @private
         * @return {?}
         */
            function () {
                if (this.booleanValueResolveFn) {
                    this.booleanValueResolveFn();
                }
            };
        IsLoadingDirective.decorators = [
            { type: i0.Directive, args: [{
                        selector: '[swIsLoading]',
                        exportAs: 'swIsLoading',
                    },] }
        ];
        /** @nocollapse */
        IsLoadingDirective.ctorParameters = function () {
            return [
                { type: undefined, decorators: [{ type: i0.Optional }, { type: i0.Inject, args: [SW_IS_LOADING_DIRECTIVE_CONFIG,] }] },
                { type: i0.Renderer2 },
                { type: IsLoadingService },
                { type: i0.ElementRef },
                { type: i0.ComponentFactoryResolver },
                { type: i0.Injector }
            ];
        };
        IsLoadingDirective.propDecorators = {
            swIsLoading: [{ type: i0.Input }],
            swIsLoadingDisableEl: [{ type: i0.Input }],
            swIsLoadingSpinner: [{ type: i0.Input }]
        };
        return IsLoadingDirective;
    }());
    /**
     * @param {?} val
     * @return {?}
     */
    function coerceBooleanValue(val) {
        if (typeof val === 'boolean')
            return val;
        if (['', 'true'].includes(val))
            return true;
        return false;
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var IsLoadingDirectiveModule = /** @class */ (function () {
        function IsLoadingDirectiveModule() {
        }
        IsLoadingDirectiveModule.decorators = [
            { type: i0.NgModule, args: [{
                        declarations: [IsLoadingDirective, IsLoadingSpinnerComponent],
                        entryComponents: [IsLoadingSpinnerComponent],
                        exports: [IsLoadingDirective],
                    },] }
        ];
        return IsLoadingDirectiveModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var IsLoadingPipe = /** @class */ (function () {
        function IsLoadingPipe(isLoadingService) {
            this.isLoadingService = isLoadingService;
        }
        /**
         * @param {?} key
         * @return {?}
         */
        IsLoadingPipe.prototype.transform = /**
         * @param {?} key
         * @return {?}
         */
            function (key) {
                return this.isLoadingService.isLoading$({ key: key });
            };
        IsLoadingPipe.decorators = [
            { type: i0.Pipe, args: [{
                        name: 'swIsLoading',
                    },] }
        ];
        /** @nocollapse */
        IsLoadingPipe.ctorParameters = function () {
            return [
                { type: IsLoadingService }
            ];
        };
        return IsLoadingPipe;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var IsLoadingPipeModule = /** @class */ (function () {
        function IsLoadingPipeModule() {
        }
        IsLoadingPipeModule.decorators = [
            { type: i0.NgModule, args: [{
                        declarations: [IsLoadingPipe],
                        exports: [IsLoadingPipe],
                    },] }
        ];
        return IsLoadingPipeModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var IsLoadingModule = /** @class */ (function () {
        function IsLoadingModule() {
        }
        IsLoadingModule.decorators = [
            { type: i0.NgModule, args: [{
                        imports: [IsLoadingDirectiveModule, IsLoadingPipeModule],
                        providers: [],
                        exports: [IsLoadingDirectiveModule, IsLoadingPipeModule],
                    },] }
        ];
        return IsLoadingModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    exports.IsLoadingService = IsLoadingService;
    exports.IsLoadingModule = IsLoadingModule;
    exports.IsLoadingDirectiveModule = IsLoadingDirectiveModule;
    exports.IsLoadingDirective = IsLoadingDirective;
    exports.SW_IS_LOADING_DIRECTIVE_CONFIG = SW_IS_LOADING_DIRECTIVE_CONFIG;
    exports.IsLoadingPipeModule = IsLoadingPipeModule;
    exports.IsLoadingPipe = IsLoadingPipe;
    exports.ɵa = IsLoadingSpinnerComponent;

    Object.defineProperty(exports, '__esModule', { value: true });

})));

//# sourceMappingURL=service-work-is-loading.umd.js.map