{"version":3,"sources":["ng://@service-work/is-loading/lib/is-loading.service.ts","ng://@service-work/is-loading/lib/module/directive/is-loading-spinner.component.ts","ng://@service-work/is-loading/lib/module/directive/is-loading.directive.config.ts","ng://@service-work/is-loading/lib/module/directive/is-loading.directive.ts","ng://@service-work/is-loading/lib/module/directive/is-loading.directive.module.ts","ng://@service-work/is-loading/lib/module/pipe/is-loading.pipe.ts","ng://@service-work/is-loading/lib/module/pipe/is-loading.pipe.module.ts","ng://@service-work/is-loading/lib/module/is-loading.module.ts"],"names":["IsLoadingService","prototype","isLoading$","args","_this","this","keys","normalizeKeys","key","Observable","observer","indexKeys","subscription","loadingSubjects","get","pipe","distinctUntilChanged","debounceTime","subscribe","next","value","error","err","complete","unsubscribe","forEach","deIndexKey","isLoading","obs","add","first","second","keyParam","sub","Subscription","closed","remove","Promise","then","take","loadingStacks","push","updateLoadingStatus","loadingStack","index","indexOf","splice","Array","isArray","defaultKey","loadingKeyIndex","has","curr","set","subject","BehaviorSubject","delete","loadingStatus","length","Injectable","providedIn","Map","IsLoadingSpinnerComponent","Component","selector","template","host","class","ChangeDetectorRef","ElementRef","cdr","el","detach","SW_IS_LOADING_DIRECTIVE_CONFIG","InjectionToken","IsLoadingDirective","Object","defineProperty","stringValue","notStringValue","subscriptionValue","notSubscriptionValue","promiseValue","notPromiseValue","booleanValue","notBooleanValue","observableValue","notObservableValue","_swIsLoadingDisableEl","coerceBooleanValue","_swIsLoadingSpinner","_isLoading","startLoading","finally","stopLoading","ngOnChanges","changes","swIsLoadingSpinner","isFirstChange","currentValue","removeSpinnerEl","swIsLoadingDisableEl","renderer","removeAttribute","nativeElement","ngAfterViewInit","addSpinnerEl","ngOnDestroy","textValueSubscription","addClass","loadingClass","setAttribute","removeClass","spinnerEl","componentFactoryResolver","resolveComponentFactory","create","injector","appendChild","instance","removeChild","destroy","undefined","isLoadingService","loading","TypeError","pending","resolve","booleanValueResolveFn","Directive","exportAs","Optional","type","Inject","Renderer2","ComponentFactoryResolver","Injector","Input","config","disableEl","HTMLButtonElement","HTMLAnchorElement","val","includes","IsLoadingDirectiveModule","NgModule","declarations","entryComponents","exports","IsLoadingPipe","transform","Pipe","name","IsLoadingPipeModule","IsLoadingModule","imports","providers"],"mappings":"waAAA,IAAAA,GAkFEA,EAAAC,UAAAC,WAAA,SAAWC,GAAX,IAAAC,EAAAC,UAAW,IAAAF,IAAAA,EAAA,QACHG,EAAOD,KAAKE,cAAcJ,EAAKK,KAErC,OAAO,IAAIC,EAAAA,WAAU,SAAUC,GAG7BN,EAAKO,UAAUL,OAETM,EAAeR,EAAKS,gBACvBC,IAAIR,EAAK,IACTS,KACCC,EAAAA,uBACAC,EAAAA,aAAa,IACbD,EAAAA,wBAEDE,UAAU,CACTC,cAAKC,GACHV,EAASS,KAAKC,IAEhBC,eAAMC,GACJZ,EAASW,MAAMC,IAEjBC,oBACEb,EAASa,cAOf,OAAA,WACEX,EAAaY,cACblB,EAAKmB,QAAO,SAACjB,GAAO,OAAAJ,EAAKsB,WAAWlB,SAW1CR,EAAAC,UAAA0B,UAAA,SAAUxB,QAAA,IAAAA,IAAAA,EAAA,QACFK,EAAMH,KAAKE,cAAcJ,EAAKK,KAAK,GACnCoB,EAAMvB,KAAKQ,gBAAgBC,IAAIN,GAErC,OAAQoB,GAAOA,EAAIR,QAAU,GAgG/BpB,EAAAC,UAAA4B,IAAA,SACEC,EACAC,GAFF,IAIMC,EACAC,EALN7B,EAAAC,KAOE,GAAIyB,aAAiBI,EAAAA,aAAc,CACjC,GAAIJ,EAAMK,OAAQ,OAAOL,GAEzBG,EAAMH,GAEAD,IAAG,WAAO,OAAAzB,EAAKgC,OAAON,EAAOC,UAC9B,GAAID,aAAiBO,SAC1BJ,EAAMH,GAGAQ,KAAI,WACF,OAAAlC,EAAKgC,OAAON,EAAOC,IAAO,WAC1B,OAAA3B,EAAKgC,OAAON,EAAOC,UAEtB,GAAID,aAAiBrB,EAAAA,WAAY,CAGtC,IAFAwB,EAAMH,EAAMf,KAAKwB,EAAAA,KAAK,IAAIrB,aAElBiB,OAAQ,OAAOL,EAEvBG,EAAIJ,IAAG,WAAO,OAAAzB,EAAKgC,OAAM,EAAsBL,UACtCD,IACTE,EAAWF,EAAMtB,KAGfuB,GAAUA,EAAOvB,MACnBwB,EAAWD,EAAOvB,SAGdF,EAAOD,KAAKE,cAAcyB,GAUhC,OARA3B,KAAKM,UAAUL,GAEfA,EAAKmB,QAAO,SAACjB,GACXJ,EAAKoC,cAAc1B,IAAIN,GAAMiC,KAAKR,IAAO,GAEzC7B,EAAKsC,oBAAoBlC,KAGpBsB,aAAiBrB,EAAAA,WAAaqB,EAAQG,GA+D/CjC,EAAAC,UAAAmC,OAAA,SACEN,EACAC,GAFF,IAIMC,EACAC,EALN7B,EAAAC,KAOMyB,aAAiBI,EAAAA,aACnBD,EAAMH,EACGA,aAAiBO,QAC1BJ,EAAMH,EACGA,IACTE,EAAWF,EAAMtB,KAGfuB,GAAUA,EAAOvB,MACnBwB,EAAWD,EAAOvB,KAGPH,KAAKE,cAAcyB,GAE3BP,QAAO,SAACjB,OACLmC,EAAevC,EAAKoC,cAAc1B,IAAIN,GAG5C,GAAKmC,EAAL,KAEMC,EAAQD,EAAaE,QAAQZ,IAAO,GAE7B,GAATW,IACFD,EAAaG,OAAOF,EAAO,GAE3BxC,EAAKsC,oBAAoBlC,GAEzBJ,EAAKsB,WAAWlB,QAKdR,EAAAC,UAAAM,cAAR,SAAsBC,GAGpB,OAFKA,EACKuC,MAAMC,QAAQxC,KAAMA,EAAM,CAACA,IAD3BA,EAAM,CAACH,KAAK4C,YAEtB,GAyBMjD,EAAAC,UAAAU,UAAR,SAAkBL,GAAlB,IAAAF,EAAAC,KACEC,EAAKmB,QAAO,SAACjB,GACX,GAAIJ,EAAK8C,gBAAgBC,IAAI3C,GAAM,KAC3B4C,EAAOhD,EAAK8C,gBAAgBpC,IAAIN,GACtCJ,EAAK8C,gBAAgBG,IAAI7C,EAAK4C,EAAO,OAChC,KACCE,EAAU,IAAIC,EAAAA,iBAAgB,GAEpCnD,EAAK8C,gBAAgBG,IAAI7C,EAAK,GAC9BJ,EAAKS,gBAAgBwC,IAAI7C,EAAK8C,GAC9BlD,EAAKoC,cAAca,IAAI7C,EAAK,QAK1BR,EAAAC,UAAAyB,WAAR,SAAmBlB,OACX4C,EAAO/C,KAAK6C,gBAAgBpC,IAAIN,GAEzB,IAAT4C,GACF/C,KAAK6C,gBAAgBM,UAAOhD,GAC5BH,KAAKQ,gBAAgB2C,UAAOhD,GAC5BH,KAAKmC,cAAcgB,UAAOhD,IAE1BH,KAAK6C,gBAAgBG,IAAI7C,EAAK4C,EAAO,IAIjCpD,EAAAC,UAAAyC,oBAAR,SAA4BlC,OACpBiD,EAAsD,EAAtCpD,KAAKmC,cAAc1B,IAAIN,GAAMkD,OAEnDrD,KAAKQ,gBAAgBC,IAAIN,GAAMW,KAAKsC,wBAhavCE,EAAAA,WAAUxD,KAAA,CAAC,CACVyD,WAAY,uJAkBZ,SAAA5D,IAfUK,KAAA4C,WAAa,UAGf5C,KAAAQ,gBAAkB,IAAIgD,IAGtBxD,KAAAmC,cAAgB,IAAIqB,IAOpBxD,KAAA6C,gBAAkB,IAAIW,IC/BhC,IAAAC,uBAECC,EAAAA,UAAS5D,KAAA,CAAC,CACT6D,SAAU,wBACVC,SAAU,GACVC,KAAM,CAAEC,QAAO,sEALGC,EAAAA,yBAAmBC,EAAAA,cAYvCP,GAHE,SAAAA,EAAoBQ,EAA+BC,GAA/BlE,KAAAiE,IAAAA,EAA+BjE,KAAAkE,GAAAA,EACjDlE,KAAKiE,IAAIE,SCRb,IAAaC,EAAiC,IAAIC,EAAAA,eAChD,kCCuBFC,GAKEC,OAAAC,eACIF,EAAA1E,UAAA,cAAW,KADf,SACgBmB,GACO,iBAAVA,EACTf,KAAKyE,YAAY1D,GAEjBf,KAAK0E,iBAGH3D,aAAiBc,EAAAA,aACnB7B,KAAK2E,kBAAkB5D,GAEvBf,KAAK4E,uBAGH7D,aAAiBiB,QACnBhC,KAAK6E,aAAa9D,GAElBf,KAAK8E,kBAGc,kBAAV/D,EACTf,KAAK+E,aAAahE,GAElBf,KAAKgF,kBAGHjE,aAAiBX,EAAAA,WACnBJ,KAAKiF,kBAELjF,KAAKkF,sDAITX,OAAAC,eAAaF,EAAA1E,UAAA,uBAAoB,KAGjC,WACE,OAAOI,KAAKmF,2BAJd,SAAkCpE,GAChCf,KAAKmF,sBAAwBC,EAAmBrE,oCAQlDwD,OAAAC,eAAaF,EAAA1E,UAAA,qBAAkB,KAG/B,WACE,OAAOI,KAAKqF,yBAJd,SAAgCtE,GAC9Bf,KAAKqF,oBAAsBD,EAAmBrE,oCAMhDwD,OAAAC,eAAIF,EAAA1E,UAAA,YAAS,KAAb,WACE,OAAOI,KAAKsF,4CAsBdf,OAAAC,eAAYF,EAAA1E,UAAA,UAAO,KAAnB,SAAoBmB,GAApB,IAAAhB,EAAAC,KACEA,KAAKuF,eACLxE,EAAMyE,WAAO,WAAO,OAAAzF,EAAK0F,iDAmB3BnB,EAAA1E,UAAA8F,YAAA,SAAYC,IAKRA,EAAQC,oBACPD,EAAQC,mBAAmBC,iBAC3BF,EAAQC,mBAAmBE,cAE5B9F,KAAK+F,mBAILJ,EAAQK,sBACPL,EAAQK,qBAAqBH,iBAC7BF,EAAQK,qBAAqBF,cAE9B9F,KAAKiG,SAASC,gBAAgBlG,KAAKkE,GAAGiC,cAAe,aAIzD7B,EAAA1E,UAAAwG,gBAAA,WACMpG,KAAK4F,oBACP5F,KAAKqG,gBAIT/B,EAAA1E,UAAA0G,YAAA,WACMtG,KAAKuG,uBACPvG,KAAKuG,sBAAsBpF,eAIvBmD,EAAA1E,UAAA2F,aAAR,WACEvF,KAAKiG,SAASO,SAASxG,KAAKkE,GAAGiC,cAAenG,KAAKyG,cAC/CzG,KAAKgG,sBACPhG,KAAKiG,SAASS,aAAa1G,KAAKkE,GAAGiC,cAAe,WAAY,YAEhEnG,KAAKsF,YAAa,GAGZhB,EAAA1E,UAAA6F,YAAR,WACEzF,KAAKiG,SAASU,YAAY3G,KAAKkE,GAAGiC,cAAenG,KAAKyG,cAClDzG,KAAKgG,sBACPhG,KAAKiG,SAASC,gBAAgBlG,KAAKkE,GAAGiC,cAAe,YAEvDnG,KAAKsF,YAAa,GAGZhB,EAAA1E,UAAAyG,aAAR,WACErG,KAAK4G,UAAY5G,KAAK6G,yBACnBC,wBAAwBrD,GACxBsD,OAAO/G,KAAKgH,UAMfhH,KAAKiG,SAASgB,YACZjH,KAAKkE,GAAGiC,cACRnG,KAAK4G,UAAUM,SAAShD,GAAGiC,gBAIvB7B,EAAA1E,UAAAmG,gBAAR,WACO/F,KAAK4G,YAEV5G,KAAKiG,SAASkB,YACZnH,KAAKkE,GAAGiC,cACRnG,KAAK4G,UAAUM,SAAShD,GAAGiC,eAG7BnG,KAAK4G,UAAUQ,UACfpH,KAAK4G,UAAYS,YAOX/C,EAAA1E,UAAA6E,YAAR,SAAoB1D,GAApB,IAKMQ,EALNxB,EAAAC,KACMA,KAAKuG,uBACPvG,KAAKuG,sBAAsBpF,cAQ3BI,EAHGR,EAGGf,KAAKsH,iBAAiBzH,WAAW,CACrCM,IAAKY,IAHDf,KAAKsH,iBAAiBzH,aAO9BG,KAAKuG,sBAAwBhF,EAAIV,UAAS,SAAC0G,GACrCA,EACFxH,EAAKwF,eACIxF,EAAKuB,WACdvB,EAAK0F,iBAKHnB,EAAA1E,UAAA8E,eAAR,WACM1E,KAAKuG,uBACPvG,KAAKuG,sBAAsBpF,eAIvBmD,EAAA1E,UAAAqF,gBAAR,WACE,MAAM,IAAIuC,UACR,mFAIIlD,EAAA1E,UAAAsF,mBAAR,aAEQZ,EAAA1E,UAAA+E,kBAAR,SAA0B5D,GACxBf,KAAKyH,QAAU,IAAIzF,QAAO,SAAC0F,GAAW,OAAA3G,EAAMS,IAAIkG,MAG1CpD,EAAA1E,UAAAgF,qBAAR,aAEQN,EAAA1E,UAAAiF,aAAR,SAAqB9D,GACnBf,KAAKyH,QAAU1G,GAGTuD,EAAA1E,UAAAkF,gBAAR,aAEQR,EAAA1E,UAAAmF,aAAR,SAAqBhE,GAArB,IAAAhB,EAAAC,KACMe,EACFf,KAAKyH,QAAU,IAAIzF,QAAO,SAAC0F,GACzB3H,EAAK4H,sBAAwBD,IAEtB1H,KAAK2H,sBACd3H,KAAK2H,wBAEL3H,KAAKyF,eAIDnB,EAAA1E,UAAAoF,gBAAR,WACMhF,KAAK2H,uBACP3H,KAAK2H,6CAlPVC,EAAAA,UAAS9H,KAAA,CAAC,CACT6D,SAAU,gBACVkE,SAAU,uFAoFPC,EAAAA,UAAQ,CAAAC,KACRC,EAAAA,OAAMlI,KAAA,CAACsE,YA9GV6D,EAAAA,iBAaOtI,SAZPqE,EAAAA,kBAGAkE,EAAAA,gCAIAC,EAAAA,iDAoBCC,EAAAA,oCAiCAA,EAAAA,kCASAA,EAAAA,SAsMH9D,GAhKE,SAAAA,EAGE+D,EACQpC,EACAqB,EACApD,EACA2C,EACAG,GAJAhH,KAAAiG,SAAAA,EACAjG,KAAAsH,iBAAAA,EACAtH,KAAAkE,GAAAA,EACAlE,KAAA6G,yBAAAA,EACA7G,KAAAgH,SAAAA,EAnCFhH,KAAAsF,YAAa,EAIbtF,KAAAqI,OAAsC,GAEtCrI,KAAAmF,sBACNnF,KAAKqI,OAAOC,YAAcjB,WAAmBrH,KAAKqI,OAAOC,UAEnDtI,KAAAqF,oBACNrF,KAAKqI,OAAOhC,eAAiBgB,UACzBrH,KAAKqI,OAAOhC,aACZrG,KAAKkE,GAAGiC,yBAAyBoC,mBACjCvI,KAAKkE,GAAGiC,yBAAyBqC,kBAE/BxI,KAAAyG,aAAezG,KAAKqI,OAAO5B,aAC/BzG,KAAKqI,OAAO5B,aACZ,gBAoBFzG,KAAKqI,OAASA,GAAU,GAwJ5B,SAASjD,EAAmBqD,GAC1B,MAAmB,kBAARA,EAA0BA,IACjC,CAAC,GAAI,QAAQC,SAASD,GCnR5B,IAAAE,uBAICC,EAAAA,SAAQ9I,KAAA,CAAC,CACR+I,aAAc,CAACvE,EAAoBb,GACnCqF,gBAAiB,CAACrF,GAClBsF,QAAS,CAACzE,OAE2BqE,GALvC,SAAAA,KCJA,IAAAK,GAUEA,EAAApJ,UAAAqJ,UAAA,SAAU9I,GACR,OAAOH,KAAKsH,iBAAiBzH,WAAW,CAAEM,IAAGA,yBAPhD+I,EAAAA,KAAIpJ,KAAA,CAAC,CACJqJ,KAAM,2DAHCxJ,KAWTqJ,GALE,SAAAA,EAAoB1B,GAAAtH,KAAAsH,iBAAAA,ECRtB,IAAA8B,uBAGCR,EAAAA,SAAQ9I,KAAA,CAAC,CACR+I,aAAc,CAACG,GACfD,QAAS,CAACC,OAEsBI,GAJlC,SAAAA,KCHA,IAAAC,uBAICT,EAAAA,SAAQ9I,KAAA,CAAC,CACRwJ,QAAS,CAACX,EAA0BS,GACpCG,UAAW,GACXR,QAAS,CAACJ,EAA0BS,OAERC,GAL9B,SAAAA","sourcesContent":["import { Injectable } from '@angular/core';\nimport { BehaviorSubject, Subscription, Observable } from 'rxjs';\nimport { distinctUntilChanged, debounceTime, take } from 'rxjs/operators';\n\nexport type Key = string | object | symbol;\n\nexport interface IGetLoadingOptions {\n  key?: Key;\n}\n\nexport interface IUpdateLoadingOptions {\n  key?: Key | Key[];\n}\n\n@Injectable({\n  providedIn: 'root',\n})\nexport class IsLoadingService {\n  protected defaultKey = 'default';\n\n  // provides an observable indicating if a particular key is loading\n  private loadingSubjects = new Map<Key, BehaviorSubject<boolean>>();\n\n  // tracks how many \"things\" are loading for each key\n  private loadingStacks = new Map<\n    unknown,\n    (true | Subscription | Promise<unknown>)[]\n  >();\n\n  // tracks which keys are being watched so that unused keys\n  // can be deleted/garbage collected.\n  private loadingKeyIndex = new Map<Key, number>();\n\n  constructor() {}\n\n  /**\n   * Used to determine if something is loading or not.\n   *\n   * When called without arguments, returns the default *isLoading*\n   * observable for your app. When called with an options object\n   * containing a `key` property, returns the *isLoading* observable\n   * corresponding to that key.\n   *\n   * Internally, *isLoading* observables are `BehaviorSubject`s, so\n   * they will return values immediately upon subscription.\n   *\n   * When called, this method creates a new observable and returns it.\n   * This means that you should not use this method directly in an Angular\n   * template because each time the method is called it will look\n   * (to Angular change detection) like the value has changed. To make\n   * subscribing in templates easier, check out the `IsLoadingPipe`.\n   * Alternatively, store the observable returned from this method in\n   * a variable on your component and use that variable inside your\n   * template.\n   *\n   * Example:\n   *\n   * ```ts\n   *  class MyCustomComponent implements OnInit {\n   *    variableForUseInTemplate: Observable<boolean>;\n   *\n   *    constructor(private loadingService: IsLoadingService) {}\n   *\n   *    ngOnInit() {\n   *      this.variableForUseInTemplate =\n   *        this.loadingService.isLoading$({key: 'button'});\n   *\n   *      this.loadingService.isLoading$().subscribe(value => {\n   *        // ... do stuff\n   *      });\n   *\n   *      this.loadingService\n   *        .isLoading$({key: MyCustomComponent})\n   *        .subscribe(value => {\n   *          // ... do stuff\n   *        });\n   *    }\n   *  }\n   * ```\n   *\n   * @param args.key optionally specify the key to subscribe to\n   */\n  isLoading$(args: IGetLoadingOptions = {}): Observable<boolean> {\n    const keys = this.normalizeKeys(args.key);\n\n    return new Observable<boolean>(observer => {\n      // this function will called each time this\n      // Observable is subscribed to.\n      this.indexKeys(keys);\n\n      const subscription = this.loadingSubjects\n        .get(keys[0])!\n        .pipe(\n          distinctUntilChanged(),\n          debounceTime(10),\n          distinctUntilChanged(),\n        )\n        .subscribe({\n          next(value) {\n            observer.next(value);\n          },\n          error(err) {\n            observer.error(err);\n          },\n          complete() {\n            observer.complete();\n          },\n        });\n\n      // the return value is the teardown function,\n      // which will be invoked when the new\n      // Observable is unsubscribed from.\n      return () => {\n        subscription.unsubscribe();\n        keys.forEach(key => this.deIndexKey(key));\n      };\n    });\n  }\n\n  /**\n   * Same as `isLoading$()` except a boolean is returned,\n   * rather than an observable.\n   *\n   * @param args.key optionally specify the key to check\n   */\n  isLoading(args: IGetLoadingOptions = {}): boolean {\n    const key = this.normalizeKeys(args.key)[0];\n    const obs = this.loadingSubjects.get(key);\n\n    return (obs && obs.value) || false;\n  }\n\n  /**\n   * Used to indicate that *something* has started loading.\n   *\n   * Optionally, a key or keys can be passed to track the loading\n   * of different things.\n   *\n   * You can pass a `Subscription`, `Promise`, or `Observable`\n   * argument, or you can call `add()` without arguments. If\n   * this method is called with a `Subscription`, `Promise`,\n   * or `Observable` argument, this method returns that argument.\n   * This is to make it easier for you to chain off of `add()`.\n   *\n   * Example: `await isLoadingService.add(promise);`\n   *\n   * Options:\n   *\n   * - If called without arguments, the `\"default\"` key is\n   *   marked as loading. It will remain loading until you\n   *   manually call `remove()` once. If you call `add()`\n   *   twice without arguments, you will need to call\n   *   `remove()` twice without arguments for loading to\n   *   stop. Etc.\n   * - If called with a `Subscription` or `Promise`\n   *   argument, the appropriate key is marked as loading\n   *   until the `Subscription` or `Promise` resolves, at\n   *   which point it is automatically marked as no longer\n   *   loading. There is no need to call `remove()` in this\n   *   scenerio.\n   * - If called with an `Observable` argument, the\n   *   appropriate key is marked as loading until the\n   *   next emission of the `Observable`, at which point\n   *   IsLoadingService will unsubscribe from the\n   *   observable and mark the key as no longer loading.\n   *\n   * Finally, as previously noted the key option allows you\n   * to track the loading of different things seperately.\n   * Any truthy value can be used as a key. The key option\n   * for `add()` is intended to be used in conjunction with\n   * the `key` option for `isLoading$()` and `remove()`. If\n   * you pass multiple keys to `add()`, each key will be\n   * marked as loading.\n   *\n   * Example:\n   *\n   * ```ts\n   *  class MyCustomComponent implements OnInit, AfterViewInit {\n   *    constructor(\n   *      private loadingService: IsLoadingService,\n   *      private myCustomDataService: MyCustomDataService,\n   *    ) {}\n   *\n   *    ngOnInit() {\n   *      const subscription = this.myCustomDataService.getData().subscribe();\n   *\n   *      // Note, we don't need to call remove() when calling\n   *      // add() with a subscription\n   *      this.loadingService.add(subscription, {\n   *        key: 'getting-data'\n   *      });\n   *\n   *      // Here we mark `MyCustomComponent` as well as the \"default\" key\n   *      // as loading, and then mark them as no longer loading in\n   *      // ngAfterViewInit()\n   *      this.loadingService.add({key: [MyCustomComponent, 'default']});\n   *    }\n   *\n   *    ngAfterViewInit() {\n   *      this.loadingService.remove({key: [MyCustomComponent, 'default']})\n   *    }\n   *\n   *    async submit(data: any) {\n   *      // here we take advantage of the fact that `add()` returns the\n   *      // Promise passed to it.\n   *      await this.loadingService.add(\n   *        this.myCustomDataService.updateData(data),\n   *        { key: 'button' }\n   *      )\n   *\n   *      // do stuff...\n   *    }\n   *  }\n   * ```\n   *\n   * @return If called with a `Subscription`, `Promise` or `Observable`,\n   *         the Subscription/Promise/Observable is returned.\n   *         This allows code like `await this.isLoadingService.add(promise)`.\n   */\n  add(): void;\n  add(options: IUpdateLoadingOptions): void;\n  add<T extends Subscription | Promise<unknown> | Observable<unknown>>(\n    sub: T,\n    options?: IUpdateLoadingOptions,\n  ): T;\n  add(\n    first?: Subscription | Promise<unknown> | IUpdateLoadingOptions,\n    second?: IUpdateLoadingOptions,\n  ) {\n    let keyParam: Key | Key[] | undefined;\n    let sub: Subscription | Promise<unknown> | undefined;\n\n    if (first instanceof Subscription) {\n      if (first.closed) return first;\n\n      sub = first;\n\n      first.add(() => this.remove(first, second));\n    } else if (first instanceof Promise) {\n      sub = first;\n\n      // If the promise is already resolved, this executes syncronously\n      first.then(\n        () => this.remove(first, second),\n        () => this.remove(first, second),\n      );\n    } else if (first instanceof Observable) {\n      sub = first.pipe(take(1)).subscribe();\n\n      if (sub.closed) return first;\n\n      sub.add(() => this.remove(sub as Subscription, second));\n    } else if (first) {\n      keyParam = first.key;\n    }\n\n    if (second && second.key) {\n      keyParam = second.key;\n    }\n\n    const keys = this.normalizeKeys(keyParam);\n\n    this.indexKeys(keys);\n\n    keys.forEach(key => {\n      this.loadingStacks.get(key)!.push(sub || true);\n\n      this.updateLoadingStatus(key);\n    });\n\n    return first instanceof Observable ? first : sub;\n  }\n\n  /**\n   * Used to indicate that something has stopped loading.\n   *\n   * - Note: if you call `add()` with a `Subscription`,\n   *   `Promise`, or `Observable` argument, you do not need\n   *   to manually call `remove().\n   *\n   * When called without arguments, `remove()`\n   * removes a loading indicator from the default\n   * *isLoading* observable's stack. So long as any items\n   * are in an *isLoading* observable's stack, that\n   * observable will be marked as loading.\n   *\n   * In more advanced usage, you can call `remove()` with\n   * an options object which accepts a `key` property.\n   * The key allows you to track the loading of different\n   * things seperately. Any truthy value can be used as a\n   * key. The key option for `remove()` is intended to be\n   * used in conjunction with the `key` option for\n   * `isLoading$()` and `add()`. If you pass an array of\n   * keys to `remove()`, then each key will be marked as\n   * no longer loading.\n   *\n   * Example:\n   *\n   * ```ts\n   *  class MyCustomComponent implements OnInit, AfterViewInit {\n   *    constructor(private loadingService: IsLoadingService) {}\n   *\n   *    ngOnInit() {\n   *      // Pushes a loading indicator onto the `\"default\"` stack\n   *      this.loadingService.add()\n   *    }\n   *\n   *    ngAfterViewInit() {\n   *      // Removes a loading indicator from the default stack\n   *      this.loadingService.remove()\n   *    }\n   *\n   *    performLongAction() {\n   *      // Pushes a loading indicator onto the `'long-action'`\n   *      // stack\n   *      this.loadingService.add({key: 'long-action'})\n   *    }\n   *\n   *    finishLongAction() {\n   *      // Removes a loading indicator from the `'long-action'`\n   *      // stack\n   *      this.loadingService.remove({key: 'long-action'})\n   *    }\n   *  }\n   * ```\n   *\n   */\n  remove(): void;\n  remove(options: IUpdateLoadingOptions): void;\n  remove(\n    sub: Subscription | Promise<unknown>,\n    options?: IUpdateLoadingOptions,\n  ): void;\n  remove(\n    first?: Subscription | Promise<unknown> | IUpdateLoadingOptions,\n    second?: IUpdateLoadingOptions,\n  ) {\n    let keyParam: Key | Key[] | undefined;\n    let sub: Subscription | Promise<unknown> | undefined;\n\n    if (first instanceof Subscription) {\n      sub = first;\n    } else if (first instanceof Promise) {\n      sub = first;\n    } else if (first) {\n      keyParam = first.key;\n    }\n\n    if (second && second.key) {\n      keyParam = second.key;\n    }\n\n    const keys = this.normalizeKeys(keyParam);\n\n    keys.forEach(key => {\n      const loadingStack = this.loadingStacks.get(key);\n\n      // !loadingStack means that a user has called remove() needlessly\n      if (!loadingStack) return;\n\n      const index = loadingStack.indexOf(sub || true);\n\n      if (index >= 0) {\n        loadingStack.splice(index, 1);\n\n        this.updateLoadingStatus(key);\n\n        this.deIndexKey(key);\n      }\n    });\n  }\n\n  private normalizeKeys(key?: Key | Key[]): Key[] {\n    if (!key) key = [this.defaultKey];\n    else if (!Array.isArray(key)) key = [key];\n    return key as Key[];\n  }\n\n  /**\n   * `indexKeys()` along with `deIndexKeys()` helps us track which\n   * keys are being watched so that unused keys can be deleted\n   * / garbage collected.\n   *\n   * When `indexKeys()` is called with an array of keys, it means\n   * that each of those keys has at least one \"thing\" interested\n   * in it. Therefore, we need to make sure that a loadingSubject\n   * and loadingStack exists for that key. We also need to index\n   * the number of \"things\" interested in that key in the\n   * `loadingKeyIndex` map.\n   *\n   * When `deIndexKeys()` is called with an array of keys, it\n   * means that some \"thing\" is no longer interested in each\n   * of those keys. Therefore, we need to re-index\n   * the number of \"things\" interested in each key. For keys\n   * that no longer have anything interested in them, we need\n   * to delete the associated `loadingKeyIndex`, `loadingSubject`,\n   * and `loadingStack`. So that the `key` can be properly\n   * released for garbage collection.\n   */\n\n  private indexKeys(keys: Key[]) {\n    keys.forEach(key => {\n      if (this.loadingKeyIndex.has(key)) {\n        const curr = this.loadingKeyIndex.get(key)!;\n        this.loadingKeyIndex.set(key, curr + 1);\n      } else {\n        const subject = new BehaviorSubject(false);\n\n        this.loadingKeyIndex.set(key, 1);\n        this.loadingSubjects.set(key, subject);\n        this.loadingStacks.set(key, []);\n      }\n    });\n  }\n\n  private deIndexKey(key: Key) {\n    const curr = this.loadingKeyIndex.get(key)!;\n\n    if (curr === 1) {\n      this.loadingKeyIndex.delete(key);\n      this.loadingSubjects.delete(key);\n      this.loadingStacks.delete(key);\n    } else {\n      this.loadingKeyIndex.set(key, curr - 1);\n    }\n  }\n\n  private updateLoadingStatus(key: Key) {\n    const loadingStatus = this.loadingStacks.get(key)!.length > 0;\n\n    this.loadingSubjects.get(key)!.next(loadingStatus);\n  }\n}\n","import { Component, ChangeDetectorRef, ElementRef } from '@angular/core';\n\n@Component({\n  selector: 'sw-is-loading-spinner',\n  template: ``,\n  host: { class: 'sw-is-loading-spinner' },\n})\nexport class IsLoadingSpinnerComponent {\n  // don't need change detection for this component\n  constructor(private cdr: ChangeDetectorRef, public el: ElementRef) {\n    this.cdr.detach();\n  }\n}\n","import { InjectionToken } from '@angular/core';\n\nexport const SW_IS_LOADING_DIRECTIVE_CONFIG = new InjectionToken(\n  'SW_IS_LOADING_DIRECTIVE_CONFIG',\n);\n\n/**\n * Config object for IsLoadingDirective\n * \n * @param disableEl disable element while loading?\n * @param loadingClass the class used to indicate loading\n * @param addSpinnerEl should a spinner element be added to the dom?\n */\nexport interface ISWIsLoadingDirectiveConfig {\n  // disable element while loading\n  disableEl?: boolean;\n  // the class used to indicate loading\n  loadingClass?: string;\n  // should a spinner element be added to the dom\n  addSpinnerEl?: boolean;\n}\n","import {\n  Directive,\n  Input,\n  Renderer2,\n  ElementRef,\n  OnDestroy,\n  AfterViewInit,\n  ComponentFactoryResolver,\n  SimpleChange,\n  OnChanges,\n  ComponentRef,\n  Injector,\n  Inject,\n  Optional,\n} from '@angular/core';\nimport { Observable, Subscription } from 'rxjs';\nimport { IsLoadingService } from '../../is-loading.service';\nimport { IsLoadingSpinnerComponent } from './is-loading-spinner.component';\nimport {\n  SW_IS_LOADING_DIRECTIVE_CONFIG,\n  ISWIsLoadingDirectiveConfig,\n} from './is-loading.directive.config';\n\n// This code was inspired by angular2-promise-buttons\n// https://github.com/johannesjo/angular2-promise-buttons\n\n@Directive({\n  selector: '[swIsLoading]',\n  exportAs: 'swIsLoading',\n})\nexport class IsLoadingDirective implements OnChanges, AfterViewInit, OnDestroy {\n  @Input()\n  set swIsLoading(value: unknown) {\n    if (typeof value === 'string') {\n      this.stringValue(value);\n    } else {\n      this.notStringValue();\n    }\n\n    if (value instanceof Subscription) {\n      this.subscriptionValue(value);\n    } else {\n      this.notSubscriptionValue();\n    }\n\n    if (value instanceof Promise) {\n      this.promiseValue(value);\n    } else {\n      this.notPromiseValue();\n    }\n\n    if (typeof value === 'boolean') {\n      this.booleanValue(value);\n    } else {\n      this.notBooleanValue();\n    }\n\n    if (value instanceof Observable) {\n      this.observableValue();\n    } else {\n      this.notObservableValue();\n    }\n  }\n\n  @Input() set swIsLoadingDisableEl(value: boolean) {\n    this._swIsLoadingDisableEl = coerceBooleanValue(value);\n  }\n  get swIsLoadingDisableEl() {\n    return this._swIsLoadingDisableEl;\n  }\n\n  // By default, if this directive is attached to an anchor or a button\n  // element, add a `sw-is-loading-spinner` element to the dom (for styling)\n  @Input() set swIsLoadingSpinner(value: boolean) {\n    this._swIsLoadingSpinner = coerceBooleanValue(value);\n  }\n  get swIsLoadingSpinner() {\n    return this._swIsLoadingSpinner;\n  }\n\n  get isLoading() {\n    return this._isLoading;\n  }\n\n  private _isLoading = false;\n\n  private spinnerEl?: ComponentRef<IsLoadingSpinnerComponent>;\n\n  private config: ISWIsLoadingDirectiveConfig = {};\n\n  private _swIsLoadingDisableEl =\n    this.config.disableEl === undefined ? true : this.config.disableEl;\n\n  private _swIsLoadingSpinner =\n    this.config.addSpinnerEl !== undefined\n      ? this.config.addSpinnerEl\n      : this.el.nativeElement instanceof HTMLButtonElement ||\n        this.el.nativeElement instanceof HTMLAnchorElement;\n\n  private loadingClass = this.config.loadingClass\n    ? this.config.loadingClass\n    : 'sw-is-loading';\n\n  private set pending(value: Promise<unknown>) {\n    this.startLoading();\n    value.finally(() => this.stopLoading());\n  }\n\n  private textValueSubscription?: Subscription;\n  private booleanValueResolveFn?: () => void;\n\n  constructor(\n    @Optional()\n    @Inject(SW_IS_LOADING_DIRECTIVE_CONFIG)\n    config: ISWIsLoadingDirectiveConfig | null,\n    private renderer: Renderer2,\n    private isLoadingService: IsLoadingService,\n    private el: ElementRef<HTMLElement>,\n    private componentFactoryResolver: ComponentFactoryResolver,\n    private injector: Injector,\n  ) {\n    this.config = config || {};\n  }\n\n  ngOnChanges(changes: {\n    swIsLoadingSpinner?: SimpleChange;\n    swIsLoadingDisableEl?: SimpleChange;\n  }) {\n    if (\n      changes.swIsLoadingSpinner &&\n      !changes.swIsLoadingSpinner.isFirstChange() &&\n      !changes.swIsLoadingSpinner.currentValue\n    ) {\n      this.removeSpinnerEl();\n    }\n\n    if (\n      changes.swIsLoadingDisableEl &&\n      !changes.swIsLoadingDisableEl.isFirstChange() &&\n      !changes.swIsLoadingDisableEl.currentValue\n    ) {\n      this.renderer.removeAttribute(this.el.nativeElement, 'disabled');\n    }\n  }\n\n  ngAfterViewInit() {\n    if (this.swIsLoadingSpinner) {\n      this.addSpinnerEl();\n    }\n  }\n\n  ngOnDestroy() {\n    if (this.textValueSubscription) {\n      this.textValueSubscription.unsubscribe();\n    }\n  }\n\n  private startLoading() {\n    this.renderer.addClass(this.el.nativeElement, this.loadingClass);\n    if (this.swIsLoadingDisableEl) {\n      this.renderer.setAttribute(this.el.nativeElement, 'disabled', 'disabled');\n    }\n    this._isLoading = true;\n  }\n\n  private stopLoading() {\n    this.renderer.removeClass(this.el.nativeElement, this.loadingClass);\n    if (this.swIsLoadingDisableEl) {\n      this.renderer.removeAttribute(this.el.nativeElement, 'disabled');\n    }\n    this._isLoading = false;\n  }\n\n  private addSpinnerEl() {\n    this.spinnerEl = this.componentFactoryResolver\n      .resolveComponentFactory(IsLoadingSpinnerComponent)\n      .create(this.injector);\n\n    // need to use Renderer2#appendChild instead of\n    // ViewContainerRef#createComponent because the injected\n    // view container is not for the element this directive\n    // is applied to\n    this.renderer.appendChild(\n      this.el.nativeElement,\n      this.spinnerEl.instance.el.nativeElement,\n    );\n  }\n\n  private removeSpinnerEl() {\n    if (!this.spinnerEl) return;\n\n    this.renderer.removeChild(\n      this.el.nativeElement,\n      this.spinnerEl.instance.el.nativeElement,\n    );\n\n    this.spinnerEl.destroy();\n    this.spinnerEl = undefined;\n  }\n\n  /**\n   * Input value handlers\n   */\n\n  private stringValue(value: string) {\n    if (this.textValueSubscription) {\n      this.textValueSubscription.unsubscribe();\n    }\n\n    let obs: Observable<boolean>;\n\n    if (!value) {\n      obs = this.isLoadingService.isLoading$();\n    } else {\n      obs = this.isLoadingService.isLoading$({\n        key: value,\n      });\n    }\n\n    this.textValueSubscription = obs.subscribe(loading => {\n      if (loading) {\n        this.startLoading();\n      } else if (this.isLoading) {\n        this.stopLoading();\n      }\n    });\n  }\n\n  private notStringValue() {\n    if (this.textValueSubscription) {\n      this.textValueSubscription.unsubscribe();\n    }\n  }\n\n  private observableValue() {\n    throw new TypeError(\n      'swBtnPending must be an instance of Subscription, instance of Observable given',\n    );\n  }\n\n  private notObservableValue() {}\n\n  private subscriptionValue(value: Subscription) {\n    this.pending = new Promise(resolve => value.add(resolve));\n  }\n\n  private notSubscriptionValue() {}\n\n  private promiseValue(value: Promise<unknown>) {\n    this.pending = value;\n  }\n\n  private notPromiseValue() {}\n\n  private booleanValue(value: boolean) {\n    if (value) {\n      this.pending = new Promise(resolve => {\n        this.booleanValueResolveFn = resolve;\n      });\n    } else if (this.booleanValueResolveFn) {\n      this.booleanValueResolveFn();\n    } else {\n      this.stopLoading();\n    }\n  }\n\n  private notBooleanValue() {\n    if (this.booleanValueResolveFn) {\n      this.booleanValueResolveFn();\n    }\n  }\n}\n\nfunction coerceBooleanValue(val: string | boolean) {\n  if (typeof val === 'boolean') return val;\n  if (['', 'true'].includes(val)) return true;\n  return false;\n}\n","import { NgModule } from '@angular/core';\nimport { IsLoadingSpinnerComponent } from './is-loading-spinner.component';\nimport { IsLoadingDirective } from './is-loading.directive';\n\n@NgModule({\n  declarations: [IsLoadingDirective, IsLoadingSpinnerComponent],\n  entryComponents: [IsLoadingSpinnerComponent],\n  exports: [IsLoadingDirective],\n})\nexport class IsLoadingDirectiveModule {}\n","import { Pipe, PipeTransform } from '@angular/core';\nimport { Observable } from 'rxjs';\nimport { IsLoadingService, Key } from '../../is-loading.service';\n\n@Pipe({\n  name: 'swIsLoading',\n})\nexport class IsLoadingPipe implements PipeTransform {\n  constructor(private isLoadingService: IsLoadingService) {}\n\n  transform(key: Key): Observable<boolean> {\n    return this.isLoadingService.isLoading$({ key });\n  }\n}\n","import { NgModule } from '@angular/core';\nimport { IsLoadingPipe } from './is-loading.pipe';\n\n@NgModule({\n  declarations: [IsLoadingPipe],\n  exports: [IsLoadingPipe],\n})\nexport class IsLoadingPipeModule {}\n","import { NgModule } from '@angular/core';\nimport { IsLoadingDirectiveModule } from './directive/is-loading.directive.module';\nimport { IsLoadingPipeModule } from './pipe/is-loading.pipe.module';\n\n@NgModule({\n  imports: [IsLoadingDirectiveModule, IsLoadingPipeModule],\n  providers: [],\n  exports: [IsLoadingDirectiveModule, IsLoadingPipeModule],\n})\nexport class IsLoadingModule {}\n"]}