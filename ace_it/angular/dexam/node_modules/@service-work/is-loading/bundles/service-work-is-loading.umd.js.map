{"version":3,"file":"service-work-is-loading.umd.js.map","sources":["ng://@service-work/is-loading/lib/is-loading.service.ts","ng://@service-work/is-loading/lib/module/directive/is-loading-spinner.component.ts","ng://@service-work/is-loading/lib/module/directive/is-loading.directive.config.ts","ng://@service-work/is-loading/lib/module/directive/is-loading.directive.ts","ng://@service-work/is-loading/lib/module/directive/is-loading.directive.module.ts","ng://@service-work/is-loading/lib/module/pipe/is-loading.pipe.ts","ng://@service-work/is-loading/lib/module/pipe/is-loading.pipe.module.ts","ng://@service-work/is-loading/lib/module/is-loading.module.ts"],"sourcesContent":["import { Injectable } from '@angular/core';\nimport { BehaviorSubject, Subscription, Observable } from 'rxjs';\nimport { distinctUntilChanged, debounceTime, take } from 'rxjs/operators';\n\nexport type Key = string | object | symbol;\n\nexport interface IGetLoadingOptions {\n  key?: Key;\n}\n\nexport interface IUpdateLoadingOptions {\n  key?: Key | Key[];\n}\n\n@Injectable({\n  providedIn: 'root',\n})\nexport class IsLoadingService {\n  protected defaultKey = 'default';\n\n  // provides an observable indicating if a particular key is loading\n  private loadingSubjects = new Map<Key, BehaviorSubject<boolean>>();\n\n  // tracks how many \"things\" are loading for each key\n  private loadingStacks = new Map<\n    unknown,\n    (true | Subscription | Promise<unknown>)[]\n  >();\n\n  // tracks which keys are being watched so that unused keys\n  // can be deleted/garbage collected.\n  private loadingKeyIndex = new Map<Key, number>();\n\n  constructor() {}\n\n  /**\n   * Used to determine if something is loading or not.\n   *\n   * When called without arguments, returns the default *isLoading*\n   * observable for your app. When called with an options object\n   * containing a `key` property, returns the *isLoading* observable\n   * corresponding to that key.\n   *\n   * Internally, *isLoading* observables are `BehaviorSubject`s, so\n   * they will return values immediately upon subscription.\n   *\n   * When called, this method creates a new observable and returns it.\n   * This means that you should not use this method directly in an Angular\n   * template because each time the method is called it will look\n   * (to Angular change detection) like the value has changed. To make\n   * subscribing in templates easier, check out the `IsLoadingPipe`.\n   * Alternatively, store the observable returned from this method in\n   * a variable on your component and use that variable inside your\n   * template.\n   *\n   * Example:\n   *\n   * ```ts\n   *  class MyCustomComponent implements OnInit {\n   *    variableForUseInTemplate: Observable<boolean>;\n   *\n   *    constructor(private loadingService: IsLoadingService) {}\n   *\n   *    ngOnInit() {\n   *      this.variableForUseInTemplate =\n   *        this.loadingService.isLoading$({key: 'button'});\n   *\n   *      this.loadingService.isLoading$().subscribe(value => {\n   *        // ... do stuff\n   *      });\n   *\n   *      this.loadingService\n   *        .isLoading$({key: MyCustomComponent})\n   *        .subscribe(value => {\n   *          // ... do stuff\n   *        });\n   *    }\n   *  }\n   * ```\n   *\n   * @param args.key optionally specify the key to subscribe to\n   */\n  isLoading$(args: IGetLoadingOptions = {}): Observable<boolean> {\n    const keys = this.normalizeKeys(args.key);\n\n    return new Observable<boolean>(observer => {\n      // this function will called each time this\n      // Observable is subscribed to.\n      this.indexKeys(keys);\n\n      const subscription = this.loadingSubjects\n        .get(keys[0])!\n        .pipe(\n          distinctUntilChanged(),\n          debounceTime(10),\n          distinctUntilChanged(),\n        )\n        .subscribe({\n          next(value) {\n            observer.next(value);\n          },\n          error(err) {\n            observer.error(err);\n          },\n          complete() {\n            observer.complete();\n          },\n        });\n\n      // the return value is the teardown function,\n      // which will be invoked when the new\n      // Observable is unsubscribed from.\n      return () => {\n        subscription.unsubscribe();\n        keys.forEach(key => this.deIndexKey(key));\n      };\n    });\n  }\n\n  /**\n   * Same as `isLoading$()` except a boolean is returned,\n   * rather than an observable.\n   *\n   * @param args.key optionally specify the key to check\n   */\n  isLoading(args: IGetLoadingOptions = {}): boolean {\n    const key = this.normalizeKeys(args.key)[0];\n    const obs = this.loadingSubjects.get(key);\n\n    return (obs && obs.value) || false;\n  }\n\n  /**\n   * Used to indicate that *something* has started loading.\n   *\n   * Optionally, a key or keys can be passed to track the loading\n   * of different things.\n   *\n   * You can pass a `Subscription`, `Promise`, or `Observable`\n   * argument, or you can call `add()` without arguments. If\n   * this method is called with a `Subscription`, `Promise`,\n   * or `Observable` argument, this method returns that argument.\n   * This is to make it easier for you to chain off of `add()`.\n   *\n   * Example: `await isLoadingService.add(promise);`\n   *\n   * Options:\n   *\n   * - If called without arguments, the `\"default\"` key is\n   *   marked as loading. It will remain loading until you\n   *   manually call `remove()` once. If you call `add()`\n   *   twice without arguments, you will need to call\n   *   `remove()` twice without arguments for loading to\n   *   stop. Etc.\n   * - If called with a `Subscription` or `Promise`\n   *   argument, the appropriate key is marked as loading\n   *   until the `Subscription` or `Promise` resolves, at\n   *   which point it is automatically marked as no longer\n   *   loading. There is no need to call `remove()` in this\n   *   scenerio.\n   * - If called with an `Observable` argument, the\n   *   appropriate key is marked as loading until the\n   *   next emission of the `Observable`, at which point\n   *   IsLoadingService will unsubscribe from the\n   *   observable and mark the key as no longer loading.\n   *\n   * Finally, as previously noted the key option allows you\n   * to track the loading of different things seperately.\n   * Any truthy value can be used as a key. The key option\n   * for `add()` is intended to be used in conjunction with\n   * the `key` option for `isLoading$()` and `remove()`. If\n   * you pass multiple keys to `add()`, each key will be\n   * marked as loading.\n   *\n   * Example:\n   *\n   * ```ts\n   *  class MyCustomComponent implements OnInit, AfterViewInit {\n   *    constructor(\n   *      private loadingService: IsLoadingService,\n   *      private myCustomDataService: MyCustomDataService,\n   *    ) {}\n   *\n   *    ngOnInit() {\n   *      const subscription = this.myCustomDataService.getData().subscribe();\n   *\n   *      // Note, we don't need to call remove() when calling\n   *      // add() with a subscription\n   *      this.loadingService.add(subscription, {\n   *        key: 'getting-data'\n   *      });\n   *\n   *      // Here we mark `MyCustomComponent` as well as the \"default\" key\n   *      // as loading, and then mark them as no longer loading in\n   *      // ngAfterViewInit()\n   *      this.loadingService.add({key: [MyCustomComponent, 'default']});\n   *    }\n   *\n   *    ngAfterViewInit() {\n   *      this.loadingService.remove({key: [MyCustomComponent, 'default']})\n   *    }\n   *\n   *    async submit(data: any) {\n   *      // here we take advantage of the fact that `add()` returns the\n   *      // Promise passed to it.\n   *      await this.loadingService.add(\n   *        this.myCustomDataService.updateData(data),\n   *        { key: 'button' }\n   *      )\n   *\n   *      // do stuff...\n   *    }\n   *  }\n   * ```\n   *\n   * @return If called with a `Subscription`, `Promise` or `Observable`,\n   *         the Subscription/Promise/Observable is returned.\n   *         This allows code like `await this.isLoadingService.add(promise)`.\n   */\n  add(): void;\n  add(options: IUpdateLoadingOptions): void;\n  add<T extends Subscription | Promise<unknown> | Observable<unknown>>(\n    sub: T,\n    options?: IUpdateLoadingOptions,\n  ): T;\n  add(\n    first?: Subscription | Promise<unknown> | IUpdateLoadingOptions,\n    second?: IUpdateLoadingOptions,\n  ) {\n    let keyParam: Key | Key[] | undefined;\n    let sub: Subscription | Promise<unknown> | undefined;\n\n    if (first instanceof Subscription) {\n      if (first.closed) return first;\n\n      sub = first;\n\n      first.add(() => this.remove(first, second));\n    } else if (first instanceof Promise) {\n      sub = first;\n\n      // If the promise is already resolved, this executes syncronously\n      first.then(\n        () => this.remove(first, second),\n        () => this.remove(first, second),\n      );\n    } else if (first instanceof Observable) {\n      sub = first.pipe(take(1)).subscribe();\n\n      if (sub.closed) return first;\n\n      sub.add(() => this.remove(sub as Subscription, second));\n    } else if (first) {\n      keyParam = first.key;\n    }\n\n    if (second && second.key) {\n      keyParam = second.key;\n    }\n\n    const keys = this.normalizeKeys(keyParam);\n\n    this.indexKeys(keys);\n\n    keys.forEach(key => {\n      this.loadingStacks.get(key)!.push(sub || true);\n\n      this.updateLoadingStatus(key);\n    });\n\n    return first instanceof Observable ? first : sub;\n  }\n\n  /**\n   * Used to indicate that something has stopped loading.\n   *\n   * - Note: if you call `add()` with a `Subscription`,\n   *   `Promise`, or `Observable` argument, you do not need\n   *   to manually call `remove().\n   *\n   * When called without arguments, `remove()`\n   * removes a loading indicator from the default\n   * *isLoading* observable's stack. So long as any items\n   * are in an *isLoading* observable's stack, that\n   * observable will be marked as loading.\n   *\n   * In more advanced usage, you can call `remove()` with\n   * an options object which accepts a `key` property.\n   * The key allows you to track the loading of different\n   * things seperately. Any truthy value can be used as a\n   * key. The key option for `remove()` is intended to be\n   * used in conjunction with the `key` option for\n   * `isLoading$()` and `add()`. If you pass an array of\n   * keys to `remove()`, then each key will be marked as\n   * no longer loading.\n   *\n   * Example:\n   *\n   * ```ts\n   *  class MyCustomComponent implements OnInit, AfterViewInit {\n   *    constructor(private loadingService: IsLoadingService) {}\n   *\n   *    ngOnInit() {\n   *      // Pushes a loading indicator onto the `\"default\"` stack\n   *      this.loadingService.add()\n   *    }\n   *\n   *    ngAfterViewInit() {\n   *      // Removes a loading indicator from the default stack\n   *      this.loadingService.remove()\n   *    }\n   *\n   *    performLongAction() {\n   *      // Pushes a loading indicator onto the `'long-action'`\n   *      // stack\n   *      this.loadingService.add({key: 'long-action'})\n   *    }\n   *\n   *    finishLongAction() {\n   *      // Removes a loading indicator from the `'long-action'`\n   *      // stack\n   *      this.loadingService.remove({key: 'long-action'})\n   *    }\n   *  }\n   * ```\n   *\n   */\n  remove(): void;\n  remove(options: IUpdateLoadingOptions): void;\n  remove(\n    sub: Subscription | Promise<unknown>,\n    options?: IUpdateLoadingOptions,\n  ): void;\n  remove(\n    first?: Subscription | Promise<unknown> | IUpdateLoadingOptions,\n    second?: IUpdateLoadingOptions,\n  ) {\n    let keyParam: Key | Key[] | undefined;\n    let sub: Subscription | Promise<unknown> | undefined;\n\n    if (first instanceof Subscription) {\n      sub = first;\n    } else if (first instanceof Promise) {\n      sub = first;\n    } else if (first) {\n      keyParam = first.key;\n    }\n\n    if (second && second.key) {\n      keyParam = second.key;\n    }\n\n    const keys = this.normalizeKeys(keyParam);\n\n    keys.forEach(key => {\n      const loadingStack = this.loadingStacks.get(key);\n\n      // !loadingStack means that a user has called remove() needlessly\n      if (!loadingStack) return;\n\n      const index = loadingStack.indexOf(sub || true);\n\n      if (index >= 0) {\n        loadingStack.splice(index, 1);\n\n        this.updateLoadingStatus(key);\n\n        this.deIndexKey(key);\n      }\n    });\n  }\n\n  private normalizeKeys(key?: Key | Key[]): Key[] {\n    if (!key) key = [this.defaultKey];\n    else if (!Array.isArray(key)) key = [key];\n    return key as Key[];\n  }\n\n  /**\n   * `indexKeys()` along with `deIndexKeys()` helps us track which\n   * keys are being watched so that unused keys can be deleted\n   * / garbage collected.\n   *\n   * When `indexKeys()` is called with an array of keys, it means\n   * that each of those keys has at least one \"thing\" interested\n   * in it. Therefore, we need to make sure that a loadingSubject\n   * and loadingStack exists for that key. We also need to index\n   * the number of \"things\" interested in that key in the\n   * `loadingKeyIndex` map.\n   *\n   * When `deIndexKeys()` is called with an array of keys, it\n   * means that some \"thing\" is no longer interested in each\n   * of those keys. Therefore, we need to re-index\n   * the number of \"things\" interested in each key. For keys\n   * that no longer have anything interested in them, we need\n   * to delete the associated `loadingKeyIndex`, `loadingSubject`,\n   * and `loadingStack`. So that the `key` can be properly\n   * released for garbage collection.\n   */\n\n  private indexKeys(keys: Key[]) {\n    keys.forEach(key => {\n      if (this.loadingKeyIndex.has(key)) {\n        const curr = this.loadingKeyIndex.get(key)!;\n        this.loadingKeyIndex.set(key, curr + 1);\n      } else {\n        const subject = new BehaviorSubject(false);\n\n        this.loadingKeyIndex.set(key, 1);\n        this.loadingSubjects.set(key, subject);\n        this.loadingStacks.set(key, []);\n      }\n    });\n  }\n\n  private deIndexKey(key: Key) {\n    const curr = this.loadingKeyIndex.get(key)!;\n\n    if (curr === 1) {\n      this.loadingKeyIndex.delete(key);\n      this.loadingSubjects.delete(key);\n      this.loadingStacks.delete(key);\n    } else {\n      this.loadingKeyIndex.set(key, curr - 1);\n    }\n  }\n\n  private updateLoadingStatus(key: Key) {\n    const loadingStatus = this.loadingStacks.get(key)!.length > 0;\n\n    this.loadingSubjects.get(key)!.next(loadingStatus);\n  }\n}\n","import { Component, ChangeDetectorRef, ElementRef } from '@angular/core';\n\n@Component({\n  selector: 'sw-is-loading-spinner',\n  template: ``,\n  host: { class: 'sw-is-loading-spinner' },\n})\nexport class IsLoadingSpinnerComponent {\n  // don't need change detection for this component\n  constructor(private cdr: ChangeDetectorRef, public el: ElementRef) {\n    this.cdr.detach();\n  }\n}\n","import { InjectionToken } from '@angular/core';\n\nexport const SW_IS_LOADING_DIRECTIVE_CONFIG = new InjectionToken(\n  'SW_IS_LOADING_DIRECTIVE_CONFIG',\n);\n\n/**\n * Config object for IsLoadingDirective\n * \n * @param disableEl disable element while loading?\n * @param loadingClass the class used to indicate loading\n * @param addSpinnerEl should a spinner element be added to the dom?\n */\nexport interface ISWIsLoadingDirectiveConfig {\n  // disable element while loading\n  disableEl?: boolean;\n  // the class used to indicate loading\n  loadingClass?: string;\n  // should a spinner element be added to the dom\n  addSpinnerEl?: boolean;\n}\n","import {\n  Directive,\n  Input,\n  Renderer2,\n  ElementRef,\n  OnDestroy,\n  AfterViewInit,\n  ComponentFactoryResolver,\n  SimpleChange,\n  OnChanges,\n  ComponentRef,\n  Injector,\n  Inject,\n  Optional,\n} from '@angular/core';\nimport { Observable, Subscription } from 'rxjs';\nimport { IsLoadingService } from '../../is-loading.service';\nimport { IsLoadingSpinnerComponent } from './is-loading-spinner.component';\nimport {\n  SW_IS_LOADING_DIRECTIVE_CONFIG,\n  ISWIsLoadingDirectiveConfig,\n} from './is-loading.directive.config';\n\n// This code was inspired by angular2-promise-buttons\n// https://github.com/johannesjo/angular2-promise-buttons\n\n@Directive({\n  selector: '[swIsLoading]',\n  exportAs: 'swIsLoading',\n})\nexport class IsLoadingDirective implements OnChanges, AfterViewInit, OnDestroy {\n  @Input()\n  set swIsLoading(value: unknown) {\n    if (typeof value === 'string') {\n      this.stringValue(value);\n    } else {\n      this.notStringValue();\n    }\n\n    if (value instanceof Subscription) {\n      this.subscriptionValue(value);\n    } else {\n      this.notSubscriptionValue();\n    }\n\n    if (value instanceof Promise) {\n      this.promiseValue(value);\n    } else {\n      this.notPromiseValue();\n    }\n\n    if (typeof value === 'boolean') {\n      this.booleanValue(value);\n    } else {\n      this.notBooleanValue();\n    }\n\n    if (value instanceof Observable) {\n      this.observableValue();\n    } else {\n      this.notObservableValue();\n    }\n  }\n\n  @Input() set swIsLoadingDisableEl(value: boolean) {\n    this._swIsLoadingDisableEl = coerceBooleanValue(value);\n  }\n  get swIsLoadingDisableEl() {\n    return this._swIsLoadingDisableEl;\n  }\n\n  // By default, if this directive is attached to an anchor or a button\n  // element, add a `sw-is-loading-spinner` element to the dom (for styling)\n  @Input() set swIsLoadingSpinner(value: boolean) {\n    this._swIsLoadingSpinner = coerceBooleanValue(value);\n  }\n  get swIsLoadingSpinner() {\n    return this._swIsLoadingSpinner;\n  }\n\n  get isLoading() {\n    return this._isLoading;\n  }\n\n  private _isLoading = false;\n\n  private spinnerEl?: ComponentRef<IsLoadingSpinnerComponent>;\n\n  private config: ISWIsLoadingDirectiveConfig = {};\n\n  private _swIsLoadingDisableEl =\n    this.config.disableEl === undefined ? true : this.config.disableEl;\n\n  private _swIsLoadingSpinner =\n    this.config.addSpinnerEl !== undefined\n      ? this.config.addSpinnerEl\n      : this.el.nativeElement instanceof HTMLButtonElement ||\n        this.el.nativeElement instanceof HTMLAnchorElement;\n\n  private loadingClass = this.config.loadingClass\n    ? this.config.loadingClass\n    : 'sw-is-loading';\n\n  private set pending(value: Promise<unknown>) {\n    this.startLoading();\n    value.finally(() => this.stopLoading());\n  }\n\n  private textValueSubscription?: Subscription;\n  private booleanValueResolveFn?: () => void;\n\n  constructor(\n    @Optional()\n    @Inject(SW_IS_LOADING_DIRECTIVE_CONFIG)\n    config: ISWIsLoadingDirectiveConfig | null,\n    private renderer: Renderer2,\n    private isLoadingService: IsLoadingService,\n    private el: ElementRef<HTMLElement>,\n    private componentFactoryResolver: ComponentFactoryResolver,\n    private injector: Injector,\n  ) {\n    this.config = config || {};\n  }\n\n  ngOnChanges(changes: {\n    swIsLoadingSpinner?: SimpleChange;\n    swIsLoadingDisableEl?: SimpleChange;\n  }) {\n    if (\n      changes.swIsLoadingSpinner &&\n      !changes.swIsLoadingSpinner.isFirstChange() &&\n      !changes.swIsLoadingSpinner.currentValue\n    ) {\n      this.removeSpinnerEl();\n    }\n\n    if (\n      changes.swIsLoadingDisableEl &&\n      !changes.swIsLoadingDisableEl.isFirstChange() &&\n      !changes.swIsLoadingDisableEl.currentValue\n    ) {\n      this.renderer.removeAttribute(this.el.nativeElement, 'disabled');\n    }\n  }\n\n  ngAfterViewInit() {\n    if (this.swIsLoadingSpinner) {\n      this.addSpinnerEl();\n    }\n  }\n\n  ngOnDestroy() {\n    if (this.textValueSubscription) {\n      this.textValueSubscription.unsubscribe();\n    }\n  }\n\n  private startLoading() {\n    this.renderer.addClass(this.el.nativeElement, this.loadingClass);\n    if (this.swIsLoadingDisableEl) {\n      this.renderer.setAttribute(this.el.nativeElement, 'disabled', 'disabled');\n    }\n    this._isLoading = true;\n  }\n\n  private stopLoading() {\n    this.renderer.removeClass(this.el.nativeElement, this.loadingClass);\n    if (this.swIsLoadingDisableEl) {\n      this.renderer.removeAttribute(this.el.nativeElement, 'disabled');\n    }\n    this._isLoading = false;\n  }\n\n  private addSpinnerEl() {\n    this.spinnerEl = this.componentFactoryResolver\n      .resolveComponentFactory(IsLoadingSpinnerComponent)\n      .create(this.injector);\n\n    // need to use Renderer2#appendChild instead of\n    // ViewContainerRef#createComponent because the injected\n    // view container is not for the element this directive\n    // is applied to\n    this.renderer.appendChild(\n      this.el.nativeElement,\n      this.spinnerEl.instance.el.nativeElement,\n    );\n  }\n\n  private removeSpinnerEl() {\n    if (!this.spinnerEl) return;\n\n    this.renderer.removeChild(\n      this.el.nativeElement,\n      this.spinnerEl.instance.el.nativeElement,\n    );\n\n    this.spinnerEl.destroy();\n    this.spinnerEl = undefined;\n  }\n\n  /**\n   * Input value handlers\n   */\n\n  private stringValue(value: string) {\n    if (this.textValueSubscription) {\n      this.textValueSubscription.unsubscribe();\n    }\n\n    let obs: Observable<boolean>;\n\n    if (!value) {\n      obs = this.isLoadingService.isLoading$();\n    } else {\n      obs = this.isLoadingService.isLoading$({\n        key: value,\n      });\n    }\n\n    this.textValueSubscription = obs.subscribe(loading => {\n      if (loading) {\n        this.startLoading();\n      } else if (this.isLoading) {\n        this.stopLoading();\n      }\n    });\n  }\n\n  private notStringValue() {\n    if (this.textValueSubscription) {\n      this.textValueSubscription.unsubscribe();\n    }\n  }\n\n  private observableValue() {\n    throw new TypeError(\n      'swBtnPending must be an instance of Subscription, instance of Observable given',\n    );\n  }\n\n  private notObservableValue() {}\n\n  private subscriptionValue(value: Subscription) {\n    this.pending = new Promise(resolve => value.add(resolve));\n  }\n\n  private notSubscriptionValue() {}\n\n  private promiseValue(value: Promise<unknown>) {\n    this.pending = value;\n  }\n\n  private notPromiseValue() {}\n\n  private booleanValue(value: boolean) {\n    if (value) {\n      this.pending = new Promise(resolve => {\n        this.booleanValueResolveFn = resolve;\n      });\n    } else if (this.booleanValueResolveFn) {\n      this.booleanValueResolveFn();\n    } else {\n      this.stopLoading();\n    }\n  }\n\n  private notBooleanValue() {\n    if (this.booleanValueResolveFn) {\n      this.booleanValueResolveFn();\n    }\n  }\n}\n\nfunction coerceBooleanValue(val: string | boolean) {\n  if (typeof val === 'boolean') return val;\n  if (['', 'true'].includes(val)) return true;\n  return false;\n}\n","import { NgModule } from '@angular/core';\nimport { IsLoadingSpinnerComponent } from './is-loading-spinner.component';\nimport { IsLoadingDirective } from './is-loading.directive';\n\n@NgModule({\n  declarations: [IsLoadingDirective, IsLoadingSpinnerComponent],\n  entryComponents: [IsLoadingSpinnerComponent],\n  exports: [IsLoadingDirective],\n})\nexport class IsLoadingDirectiveModule {}\n","import { Pipe, PipeTransform } from '@angular/core';\nimport { Observable } from 'rxjs';\nimport { IsLoadingService, Key } from '../../is-loading.service';\n\n@Pipe({\n  name: 'swIsLoading',\n})\nexport class IsLoadingPipe implements PipeTransform {\n  constructor(private isLoadingService: IsLoadingService) {}\n\n  transform(key: Key): Observable<boolean> {\n    return this.isLoadingService.isLoading$({ key });\n  }\n}\n","import { NgModule } from '@angular/core';\nimport { IsLoadingPipe } from './is-loading.pipe';\n\n@NgModule({\n  declarations: [IsLoadingPipe],\n  exports: [IsLoadingPipe],\n})\nexport class IsLoadingPipeModule {}\n","import { NgModule } from '@angular/core';\nimport { IsLoadingDirectiveModule } from './directive/is-loading.directive.module';\nimport { IsLoadingPipeModule } from './pipe/is-loading.pipe.module';\n\n@NgModule({\n  imports: [IsLoadingDirectiveModule, IsLoadingPipeModule],\n  providers: [],\n  exports: [IsLoadingDirectiveModule, IsLoadingPipeModule],\n})\nexport class IsLoadingModule {}\n"],"names":["Observable","distinctUntilChanged","debounceTime","Subscription","take","BehaviorSubject","Injectable","Component","ChangeDetectorRef","ElementRef","InjectionToken","Directive","Optional","Inject","Renderer2","ComponentFactoryResolver","Injector","Input","NgModule","Pipe"],"mappings":"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"}
