/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { Injectable } from '@angular/core';
import { BehaviorSubject, Subscription, Observable } from 'rxjs';
import { distinctUntilChanged, debounceTime, take } from 'rxjs/operators';
import * as i0 from "@angular/core";
/**
 * @record
 */
export function IGetLoadingOptions() { }
if (false) {
    /** @type {?|undefined} */
    IGetLoadingOptions.prototype.key;
}
/**
 * @record
 */
export function IUpdateLoadingOptions() { }
if (false) {
    /** @type {?|undefined} */
    IUpdateLoadingOptions.prototype.key;
}
export class IsLoadingService {
    constructor() {
        this.defaultKey = 'default';
        // provides an observable indicating if a particular key is loading
        this.loadingSubjects = new Map();
        // tracks how many "things" are loading for each key
        this.loadingStacks = new Map();
        // tracks which keys are being watched so that unused keys
        // can be deleted/garbage collected.
        this.loadingKeyIndex = new Map();
    }
    /**
     * Used to determine if something is loading or not.
     *
     * When called without arguments, returns the default *isLoading*
     * observable for your app. When called with an options object
     * containing a `key` property, returns the *isLoading* observable
     * corresponding to that key.
     *
     * Internally, *isLoading* observables are `BehaviorSubject`s, so
     * they will return values immediately upon subscription.
     *
     * When called, this method creates a new observable and returns it.
     * This means that you should not use this method directly in an Angular
     * template because each time the method is called it will look
     * (to Angular change detection) like the value has changed. To make
     * subscribing in templates easier, check out the `IsLoadingPipe`.
     * Alternatively, store the observable returned from this method in
     * a variable on your component and use that variable inside your
     * template.
     *
     * Example:
     *
     * ```ts
     *  class MyCustomComponent implements OnInit {
     *    variableForUseInTemplate: Observable<boolean>;
     *
     *    constructor(private loadingService: IsLoadingService) {}
     *
     *    ngOnInit() {
     *      this.variableForUseInTemplate =
     *        this.loadingService.isLoading$({key: 'button'});
     *
     *      this.loadingService.isLoading$().subscribe(value => {
     *        // ... do stuff
     *      });
     *
     *      this.loadingService
     *        .isLoading$({key: MyCustomComponent})
     *        .subscribe(value => {
     *          // ... do stuff
     *        });
     *    }
     *  }
     * ```
     *
     * @param {?=} args
     * @return {?}
     */
    isLoading$(args = {}) {
        /** @type {?} */
        const keys = this.normalizeKeys(args.key);
        return new Observable((/**
         * @param {?} observer
         * @return {?}
         */
        observer => {
            // this function will called each time this
            // Observable is subscribed to.
            this.indexKeys(keys);
            /** @type {?} */
            const subscription = (/** @type {?} */ (this.loadingSubjects
                .get(keys[0]))).pipe(distinctUntilChanged(), debounceTime(10), distinctUntilChanged())
                .subscribe({
                /**
                 * @param {?} value
                 * @return {?}
                 */
                next(value) {
                    observer.next(value);
                },
                /**
                 * @param {?} err
                 * @return {?}
                 */
                error(err) {
                    observer.error(err);
                },
                /**
                 * @return {?}
                 */
                complete() {
                    observer.complete();
                },
            });
            // the return value is the teardown function,
            // which will be invoked when the new
            // Observable is unsubscribed from.
            return (/**
             * @return {?}
             */
            () => {
                subscription.unsubscribe();
                keys.forEach((/**
                 * @param {?} key
                 * @return {?}
                 */
                key => this.deIndexKey(key)));
            });
        }));
    }
    /**
     * Same as `isLoading$()` except a boolean is returned,
     * rather than an observable.
     *
     * @param {?=} args
     * @return {?}
     */
    isLoading(args = {}) {
        /** @type {?} */
        const key = this.normalizeKeys(args.key)[0];
        /** @type {?} */
        const obs = this.loadingSubjects.get(key);
        return (obs && obs.value) || false;
    }
    /**
     * @param {?=} first
     * @param {?=} second
     * @return {?}
     */
    add(first, second) {
        /** @type {?} */
        let keyParam;
        /** @type {?} */
        let sub;
        if (first instanceof Subscription) {
            if (first.closed)
                return first;
            sub = first;
            first.add((/**
             * @return {?}
             */
            () => this.remove(first, second)));
        }
        else if (first instanceof Promise) {
            sub = first;
            // If the promise is already resolved, this executes syncronously
            first.then((/**
             * @return {?}
             */
            () => this.remove(first, second)), (/**
             * @return {?}
             */
            () => this.remove(first, second)));
        }
        else if (first instanceof Observable) {
            sub = first.pipe(take(1)).subscribe();
            if (sub.closed)
                return first;
            sub.add((/**
             * @return {?}
             */
            () => this.remove((/** @type {?} */ (sub)), second)));
        }
        else if (first) {
            keyParam = first.key;
        }
        if (second && second.key) {
            keyParam = second.key;
        }
        /** @type {?} */
        const keys = this.normalizeKeys(keyParam);
        this.indexKeys(keys);
        keys.forEach((/**
         * @param {?} key
         * @return {?}
         */
        key => {
            (/** @type {?} */ (this.loadingStacks.get(key))).push(sub || true);
            this.updateLoadingStatus(key);
        }));
        return first instanceof Observable ? first : sub;
    }
    /**
     * @param {?=} first
     * @param {?=} second
     * @return {?}
     */
    remove(first, second) {
        /** @type {?} */
        let keyParam;
        /** @type {?} */
        let sub;
        if (first instanceof Subscription) {
            sub = first;
        }
        else if (first instanceof Promise) {
            sub = first;
        }
        else if (first) {
            keyParam = first.key;
        }
        if (second && second.key) {
            keyParam = second.key;
        }
        /** @type {?} */
        const keys = this.normalizeKeys(keyParam);
        keys.forEach((/**
         * @param {?} key
         * @return {?}
         */
        key => {
            /** @type {?} */
            const loadingStack = this.loadingStacks.get(key);
            // !loadingStack means that a user has called remove() needlessly
            if (!loadingStack)
                return;
            /** @type {?} */
            const index = loadingStack.indexOf(sub || true);
            if (index >= 0) {
                loadingStack.splice(index, 1);
                this.updateLoadingStatus(key);
                this.deIndexKey(key);
            }
        }));
    }
    /**
     * @private
     * @param {?=} key
     * @return {?}
     */
    normalizeKeys(key) {
        if (!key)
            key = [this.defaultKey];
        else if (!Array.isArray(key))
            key = [key];
        return (/** @type {?} */ (key));
    }
    /**
     * `indexKeys()` along with `deIndexKeys()` helps us track which
     * keys are being watched so that unused keys can be deleted
     * / garbage collected.
     *
     * When `indexKeys()` is called with an array of keys, it means
     * that each of those keys has at least one "thing" interested
     * in it. Therefore, we need to make sure that a loadingSubject
     * and loadingStack exists for that key. We also need to index
     * the number of "things" interested in that key in the
     * `loadingKeyIndex` map.
     *
     * When `deIndexKeys()` is called with an array of keys, it
     * means that some "thing" is no longer interested in each
     * of those keys. Therefore, we need to re-index
     * the number of "things" interested in each key. For keys
     * that no longer have anything interested in them, we need
     * to delete the associated `loadingKeyIndex`, `loadingSubject`,
     * and `loadingStack`. So that the `key` can be properly
     * released for garbage collection.
     * @private
     * @param {?} keys
     * @return {?}
     */
    indexKeys(keys) {
        keys.forEach((/**
         * @param {?} key
         * @return {?}
         */
        key => {
            if (this.loadingKeyIndex.has(key)) {
                /** @type {?} */
                const curr = (/** @type {?} */ (this.loadingKeyIndex.get(key)));
                this.loadingKeyIndex.set(key, curr + 1);
            }
            else {
                /** @type {?} */
                const subject = new BehaviorSubject(false);
                this.loadingKeyIndex.set(key, 1);
                this.loadingSubjects.set(key, subject);
                this.loadingStacks.set(key, []);
            }
        }));
    }
    /**
     * @private
     * @param {?} key
     * @return {?}
     */
    deIndexKey(key) {
        /** @type {?} */
        const curr = (/** @type {?} */ (this.loadingKeyIndex.get(key)));
        if (curr === 1) {
            this.loadingKeyIndex.delete(key);
            this.loadingSubjects.delete(key);
            this.loadingStacks.delete(key);
        }
        else {
            this.loadingKeyIndex.set(key, curr - 1);
        }
    }
    /**
     * @private
     * @param {?} key
     * @return {?}
     */
    updateLoadingStatus(key) {
        /** @type {?} */
        const loadingStatus = (/** @type {?} */ (this.loadingStacks.get(key))).length > 0;
        (/** @type {?} */ (this.loadingSubjects.get(key))).next(loadingStatus);
    }
}
IsLoadingService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root',
            },] }
];
/** @nocollapse */
IsLoadingService.ctorParameters = () => [];
/** @nocollapse */ IsLoadingService.ngInjectableDef = i0.defineInjectable({ factory: function IsLoadingService_Factory() { return new IsLoadingService(); }, token: IsLoadingService, providedIn: "root" });
if (false) {
    /**
     * @type {?}
     * @protected
     */
    IsLoadingService.prototype.defaultKey;
    /**
     * @type {?}
     * @private
     */
    IsLoadingService.prototype.loadingSubjects;
    /**
     * @type {?}
     * @private
     */
    IsLoadingService.prototype.loadingStacks;
    /**
     * @type {?}
     * @private
     */
    IsLoadingService.prototype.loadingKeyIndex;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaXMtbG9hZGluZy5zZXJ2aWNlLmpzIiwic291cmNlUm9vdCI6Im5nOi8vQHNlcnZpY2Utd29yay9pcy1sb2FkaW5nLyIsInNvdXJjZXMiOlsibGliL2lzLWxvYWRpbmcuc2VydmljZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7O0FBQUEsT0FBTyxFQUFFLFVBQVUsRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUMzQyxPQUFPLEVBQUUsZUFBZSxFQUFFLFlBQVksRUFBRSxVQUFVLEVBQUUsTUFBTSxNQUFNLENBQUM7QUFDakUsT0FBTyxFQUFFLG9CQUFvQixFQUFFLFlBQVksRUFBRSxJQUFJLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQzs7Ozs7QUFJMUUsd0NBRUM7OztJQURDLGlDQUFVOzs7OztBQUdaLDJDQUVDOzs7SUFEQyxvQ0FBa0I7O0FBTXBCLE1BQU0sT0FBTyxnQkFBZ0I7SUFnQjNCO1FBZlUsZUFBVSxHQUFHLFNBQVMsQ0FBQzs7UUFHekIsb0JBQWUsR0FBRyxJQUFJLEdBQUcsRUFBaUMsQ0FBQzs7UUFHM0Qsa0JBQWEsR0FBRyxJQUFJLEdBQUcsRUFHNUIsQ0FBQzs7O1FBSUksb0JBQWUsR0FBRyxJQUFJLEdBQUcsRUFBZSxDQUFDO0lBRWxDLENBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7SUFpRGhCLFVBQVUsQ0FBQyxPQUEyQixFQUFFOztjQUNoQyxJQUFJLEdBQUcsSUFBSSxDQUFDLGFBQWEsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDO1FBRXpDLE9BQU8sSUFBSSxVQUFVOzs7O1FBQVUsUUFBUSxDQUFDLEVBQUU7WUFDeEMsMkNBQTJDO1lBQzNDLCtCQUErQjtZQUMvQixJQUFJLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxDQUFDOztrQkFFZixZQUFZLEdBQUcsbUJBQUEsSUFBSSxDQUFDLGVBQWU7aUJBQ3RDLEdBQUcsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBQyxDQUNiLElB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QUFDLENBQUM7SUFDTCxDQUFDOzs7Ozs7SUFFTyxVQUFVLENBQUMsR0FBUTs7Y0FDbkIsSUFBSSxHQUFHLG1CQUFBLElBQUksQ0FBQyxlQUFlLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxFQUFDO1FBRTNDLElBQUksSUFBSSxLQUFLLENBQUMsRUFBRTtZQUNkLElBQUksQ0FBQyxlQUFlLENBQUMsTUFBTSxDQUFDLEdBQUcsQ0FBQyxDQUFDO1lBQ2pDLElBQUksQ0FBQyxlQUFlLENBQUMsTUFBTSxDQUFDLEdBQUcsQ0FBQyxDQUFDO1lBQ2pDLElBQUksQ0FBQyxhQUFhLENBQUMsTUFBTSxDQUFDLEdBQUcsQ0FBQyxDQUFDO1NBQ2hDO2FBQU07WUFDTCxJQUFJLENBQUMsZUFBZSxDQUFDLEdBQUcsQ0FBQyxHQUFHLEVBQUUsSUFBSSxHQUFHLENBQUMsQ0FBQyxDQUFDO1NBQ3pDO0lBQ0gsQ0FBQzs7Ozs7O0lBRU8sbUJBQW1CLENBQUMsR0FBUTs7Y0FDNUIsYUFBYSxHQUFHLG1CQUFBLElBQUksQ0FBQyxhQUFhLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxFQUFDLENBQUMsTUFBTSxHQUFHLENBQUM7UUFFN0QsbUJBQUEsSUFBSSxDQUFDLGVBQWUsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLEVBQUMsQ0FBQyxJQUFJLENBQUMsYUFBYSxDQUFDLENBQUM7SUFDckQsQ0FBQzs7O1lBamFGLFVBQVUsU0FBQztnQkFDVixVQUFVLEVBQUUsTUFBTTthQUNuQjs7Ozs7Ozs7OztJQUVDLHNDQUFpQzs7Ozs7SUFHakMsMkNBQW1FOzs7OztJQUduRSx5Q0FHSTs7Ozs7SUFJSiwyQ0FBaUQiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBJbmplY3RhYmxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBCZWhhdmlvclN1YmplY3QsIFN1YnNjcmlwdGlvbiwgT2JzZXJ2YWJsZSB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgZGlzdGluY3RVbnRpbENoYW5nZWQsIGRlYm91bmNlVGltZSwgdGFrZSB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcblxuZXhwb3J0IHR5cGUgS2V5ID0gc3RyaW5nIHwgb2JqZWN0IHwgc3ltYm9sO1xuXG5leHBvcnQgaW50ZXJmYWNlIElHZXRMb2FkaW5nT3B0aW9ucyB7XG4gIGtleT86IEtleTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBJVXBkYXRlTG9hZGluZ09wdGlvbnMge1xuICBrZXk/OiBLZXkgfCBLZXlbXTtcbn1cblxuQEluamVjdGFibGUoe1xuICBwcm92aWRlZEluOiAncm9vdCcsXG59KVxuZXhwb3J0IGNsYXNzIElzTG9hZGluZ1NlcnZpY2Uge1xuICBwcm90ZWN0ZWQgZGVmYXVsdEtleSA9ICdkZWZhdWx0JztcblxuICAvLyBwcm92aWRlcyBhbiBvYnNlcnZhYmxlIGluZGljYXRpbmcgaWYgYSBwYXJ0aWN1bGFyIGtleSBpcyBsb2FkaW5nXG4gIHByaXZhdGUgbG9hZGluZ1N1YmplY3RzID0gbmV3IE1hcDxLZXksIEJlaGF2aW9yU3ViamVjdDxib29sZWFuPj4oKTtcblxuICAvLyB0cmFja3MgaG93IG1hbnkgXCJ0aGluZ3NcIiBhcmUgbG9hZGluZyBmb3IgZWFjaCBrZXlcbiAgcHJpdmF0ZSBsb2FkaW5nU3RhY2tzID0gbmV3IE1hcDxcbiAgICB1bmtub3duLFxuICAgICh0cnVlIHwgU3Vic2NyaXB0aW9uIHwgUHJvbWlzZTx1bmtub3duPilbXVxuICA+KCk7XG5cbiAgLy8gdHJhY2tzIHdoaWNoIGtleXMgYXJlIGJlaW5nIHdhdGNoZWQgc28gdGhhdCB1bnVzZWQga2V5c1xuICAvLyBjYW4gYmUgZGVsZXRlZC9nYXJiYWdlIGNvbGxlY3RlZC5cbiAgcHJpdmF0ZSBsb2FkaW5nS2V5SW5kZXggPSBuZXcgTWFwPEtleSwgbnVtYmVyPigpO1xuXG4gIGNvbnN0cnVjdG9yKCkge31cblxuICAvKipcbiAgICogVXNlZCB0byBkZXRlcm1pbmUgaWYgc29tZXRoaW5nIGlzIGxvYWRpbmcgb3Igbm90LlxuICAgKlxuICAgKiBXaGVuIGNhbGxlZCB3aXRob3V0IGFyZ3VtZW50cywgcmV0dXJucyB0aGUgZGVmYXVsdCAqaXNMb2FkaW5nKlxuICAgKiBvYnNlcnZhYmxlIGZvciB5b3VyIGFwcC4gV2hlbiBjYWxsZWQgd2l0aCBhbiBvcHRpb25zIG9iamVjdFxuICAgKiBjb250YWluaW5nIGEgYGtleWAgcHJvcGVydHksIHJldHVybnMgdGhlICppc0xvYWRpbmcqIG9ic2VydmFibGVcbiAgICogY29ycmVzcG9uZGluZyB0byB0aGF0IGtleS5cbiAgICpcbiAgICogSW50ZXJuYWxseSwgKmlzTG9hZGluZyogb2JzZXJ2YWJsZXMgYXJlIGBCZWhhdmlvclN1YmplY3Rgcywgc29cbiAgICogdGhleSB3aWxsIHJldHVybiB2YWx1ZXMgaW1tZWRpYXRlbHkgdXBvbiBzdWJzY3JpcHRpb24uXG4gICAqXG4gICAqIFdoZW4gY2FsbGVkLCB0aGlzIG1ldGhvZCBjcmVhdGVzIGEgbmV3IG9ic2VydmFibGUgYW5kIHJldHVybnMgaXQuXG4gICAqIFRoaXMgbWVhbnMgdGhhdCB5b3Ugc2hvdWxkIG5vdCB1c2UgdGhpcyBtZXRob2QgZGlyZWN0bHkgaW4gYW4gQW5ndWxhclxuICAgKiB0ZW1wbGF0ZSBiZWNhdXNlIGVhY2ggdGltZSB0aGUgbWV0aG9kIGlzIGNhbGxlZCBpdCB3aWxsIGxvb2tcbiAgICogKHRvIEFuZ3VsYXIgY2hhbmdlIGRldGVjdGlvbikgbGlrZSB0aGUgdmFsdWUgaGFzIGNoYW5nZWQuIFRvIG1ha2VcbiAgICogc3Vic2NyaWJpbmcgaW4gdGVtcGxhdGVzIGVhc2llciwgY2hlY2sgb3V0IHRoZSBgSXNMb2FkaW5nUGlwZWAuXG4gICAqIEFsdGVybmF0aXZlbHksIHN0b3JlIHRoZSBvYnNlcnZhYmxlIHJldHVybmVkIGZyb20gdGhpcyBtZXRob2QgaW5cbiAgICogYSB2YXJpYWJsZSBvbiB5b3VyIGNvbXBvbmVudCBhbmQgdXNlIHRoYXQgdmFyaWFibGUgaW5zaWRlIHlvdXJcbiAgICogdGVtcGxhdGUuXG4gICAqXG4gICAqIEV4YW1wbGU6XG4gICAqXG4gICAqIGBgYHRzXG4gICAqICBjbGFzcyBNeUN1c3RvbUNvbXBvbmVudCBpbXBsZW1lbnRzIE9uSW5pdCB7XG4gICAqICAgIHZhcmlhYmxlRm9yVXNlSW5UZW1wbGF0ZTogT2JzZXJ2YWJsZTxib29sZWFuPjtcbiAgICpcbiAgICogICAgY29uc3RydWN0b3IocHJpdmF0ZSBsb2FkaW5nU2VydmljZTogSXNMb2FkaW5nU2VydmljZSkge31cbiAgICpcbiAgICogICAgbmdPbkluaXQoKSB7XG4gICAqICAgICAgdGhpcy52YXJpYWJsZUZvclVzZUluVGVtcGxhdGUgPVxuICAgKiAgICAgICAgdGhpcy5sb2FkaW5nU2VydmljZS5pc0xvYWRpbmckKHtrZXk6ICdidXR0b24nfSk7XG4gICAqXG4gICAqICAgICAgdGhpcy5sb2FkaW5nU2VydmljZS5pc0xvYWRpbmckKCkuc3Vic2NyaWJlKHZhbHVlID0+IHtcbiAgICogICAgICAgIC8vIC4uLiBkbyBzdHVmZlxuICAgKiAgICAgIH0pO1xuICAgKlxuICAgKiAgICAgIHRoaXMubG9hZGluZ1NlcnZpY2VcbiAgICogICAgICAgIC5pc0xvYWRpbmckKHtrZXk6IE15Q3VzdG9tQ29tcG9uZW50fSlcbiAgICogICAgICAgIC5zdWJzY3JpYmUodmFsdWUgPT4ge1xuICAgKiAgICAgICAgICAvLyAuLi4gZG8gc3R1ZmZcbiAgICogICAgICAgIH0pO1xuICAgKiAgICB9XG4gICAqICB9XG4gICAqIGBgYFxuICAgKlxuICAgKiBAcGFyYW0gYXJncy5rZXkgb3B0aW9uYWxseSBzcGVjaWZ5IHRoZSBrZXkgdG8gc3Vic2NyaWJlIHRvXG4gICAqL1xuICBpc0xvYWRpbmckKGFyZ3M6IElHZXRMb2FkaW5nT3B0aW9ucyA9IHt9KTogT2JzZXJ2YWJsZTxib29sZWFuPiB7XG4gICAgY29uc3Qga2V5cyA9IHRoaXMubm9ybWFsaXplS2V5cyhhcmdzLmtleSk7XG5cbiAgICByZXR1cm4gbmV3IE9ic2VydmFibGU8Ym9vbGVhbj4ob2JzZXJ2ZXIgPT4ge1xuICAgICAgLy8gdGhpcyBmdW5jdGlvbiB3aWxsIGNhbGxlZCBlYWNoIHRpbWUgdGhpc1xuICAgICAgLy8gT2JzZXJ2YWJsZSBpcyBzdWJzY3JpYmVkIHRvLlxuICAgICAgdGhpcy5pbmRleEtleXMoa2V5cyk7XG5cbiAgICAgIGNvbnN0IHN1YnNjcmlwdGlvbiA9IHRoaXMubG9hZGluZ1N1YmplY3RzXG4gICAgICAgIC5nZXQoa2V5c1swXSkhXG4gICAgICAgIC5waXBlKFxuICAgICAgICAgIGRpc3RpbmN0VW50aWxDaGFuZ2VkKCksXG4gICAgICAgICAgZGVib3VuY2VUaW1lKDEwKSxcbiAgICAgICAgICBkaXN0aW5jdFVudGlsQ2hhbmdlZCgpLFxuICAgICAgICApXG4gICAgICAgIC5zdWJzY3JpYmUoe1xuICAgICAgICAgIG5leHQodmFsdWUpIHtcbiAgICAgICAgICAgIG9ic2VydmVyLm5leHQodmFsdWUpO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgZXJyb3IoZXJyKSB7XG4gICAgICAgICAgICBvYnNlcnZlci5lcnJvcihlcnIpO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgY29tcGxldGUoKSB7XG4gICAgICAgICAgICBvYnNlcnZlci5jb21wbGV0ZSgpO1xuICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuXG4gICAgICAvLyB0aGUgcmV0dXJuIHZhbHVlIGlzIHRoZSB0ZWFyZG93biBmdW5jdGlvbixcbiAgICAgIC8vIHdoaWNoIHdpbGwgYmUgaW52b2tlZCB3aGVuIHRoZSBuZXdcbiAgICAgIC8vIE9ic2VydmFibGUgaXMgdW5zdWJzY3JpYmVkIGZyb20uXG4gICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICBzdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICAgICAga2V5cy5mb3JFYWNoKGtleSA9PiB0aGlzLmRlSW5kZXhLZXkoa2V5KSk7XG4gICAgICB9O1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFNhbWUgYXMgYGlzTG9hZGluZyQoKWAgZXhjZXB0IGEgYm9vbGVhbiBpcyByZXR1cm5lZCxcbiAgICogcmF0aGVyIHRoYW4gYW4gb2JzZXJ2YWJsZS5cbiAgICpcbiAgICogQHBhcmFtIGFyZ3Mua2V5IG9wdGlvbmFsbHkgc3BlY2lmeSB0aGUga2V5IHRvIGNoZWNrXG4gICAqL1xuICBpc0xvYWRpbmcoYXJnczogSUdldExvYWRpbmdPcHRpb25zID0ge30pOiBib29sZWFuIHtcbiAgICBjb25zdCBrZXkgPSB0aGlzLm5vcm1hbGl6ZUtleXMoYXJncy5rZXkpWzBdO1xuICAgIGNvbnN0IG9icyA9IHRoaXMubG9hZGluZ1N1YmplY3RzLmdldChrZXkpO1xuXG4gICAgcmV0dXJuIChvYnMgJiYgb2JzLnZhbHVlKSB8fCBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVc2VkIHRvIGluZGljYXRlIHRoYXQgKnNvbWV0aGluZyogaGFzIHN0YXJ0ZWQgbG9hZGluZy5cbiAgICpcbiAgICogT3B0aW9uYWxseSwgYSBrZXkgb3Iga2V5cyBjYW4gYmUgcGFzc2VkIHRvIHRyYWNrIHRoZSBsb2FkaW5nXG4gICAqIG9mIGRpZmZlcmVudCB0aGluZ3MuXG4gICAqXG4gICAqIFlvdSBjYW4gcGFzcyBhIGBTdWJzY3JpcHRpb25gLCBgUHJvbWlzZWAsIG9yIGBPYnNlcnZhYmxlYFxuICAgKiBhcmd1bWVudCwgb3IgeW91IGNhbiBjYWxsIGBhZGQoKWAgd2l0aG91dCBhcmd1bWVudHMuIElmXG4gICAqIHRoaXMgbWV0aG9kIGlzIGNhbGxlZCB3aXRoIGEgYFN1YnNjcmlwdGlvbmAsIGBQcm9taXNlYCxcbiAgICogb3IgYE9ic2VydmFibGVgIGFyZ3VtZW50LCB0aGlzIG1ldGhvZCByZXR1cm5zIHRoYXQgYXJndW1lbnQuXG4gICAqIFRoaXMgaXMgdG8gbWFrZSBpdCBlYXNpZXIgZm9yIHlvdSB0byBjaGFpbiBvZmYgb2YgYGFkZCgpYC5cbiAgICpcbiAgICogRXhhbXBsZTogYGF3YWl0IGlzTG9hZGluZ1NlcnZpY2UuYWRkKHByb21pc2UpO2BcbiAgICpcbiAgICogT3B0aW9uczpcbiAgICpcbiAgICogLSBJZiBjYWxsZWQgd2l0aG91dCBhcmd1bWVudHMsIHRoZSBgXCJkZWZhdWx0XCJgIGtleSBpc1xuICAgKiAgIG1hcmtlZCBhcyBsb2FkaW5nLiBJdCB3aWxsIHJlbWFpbiBsb2FkaW5nIHVudGlsIHlvdVxuICAgKiAgIG1hbnVhbGx5IGNhbGwgYHJlbW92ZSgpYCBvbmNlLiBJZiB5b3UgY2FsbCBgYWRkKClgXG4gICAqICAgdHdpY2Ugd2l0aG91dCBhcmd1bWVudHMsIHlvdSB3aWxsIG5lZWQgdG8gY2FsbFxuICAgKiAgIGByZW1vdmUoKWAgdHdpY2Ugd2l0aG91dCBhcmd1bWVudHMgZm9yIGxvYWRpbmcgdG9cbiAgICogICBzdG9wLiBFdGMuXG4gICAqIC0gSWYgY2FsbGVkIHdpdGggYSBgU3Vic2NyaXB0aW9uYCBvciBgUHJvbWlzZWBcbiAgICogICBhcmd1bWVudCwgdGhlIGFwcHJvcHJpYXRlIGtleSBpcyBtYXJrZWQgYXMgbG9hZGluZ1xuICAgKiAgIHVudGlsIHRoZSBgU3Vic2NyaXB0aW9uYCBvciBgUHJvbWlzZWAgcmVzb2x2ZXMsIGF0XG4gICAqICAgd2hpY2ggcG9pbnQgaXQgaXMgYXV0b21hdGljYWxseSBtYXJrZWQgYXMgbm8gbG9uZ2VyXG4gICAqICAgbG9hZGluZy4gVGhlcmUgaXMgbm8gbmVlZCB0byBjYWxsIGByZW1vdmUoKWAgaW4gdGhpc1xuICAgKiAgIHNjZW5lcmlvLlxuICAgKiAtIElmIGNhbGxlZCB3aXRoIGFuIGBPYnNlcnZhYmxlYCBhcmd1bWVudCwgdGhlXG4gICAqICAgYXBwcm9wcmlhdGUga2V5IGlzIG1hcmtlZCBhcyBsb2FkaW5nIHVudGlsIHRoZVxuICAgKiAgIG5leHQgZW1pc3Npb24gb2YgdGhlIGBPYnNlcnZhYmxlYCwgYXQgd2hpY2ggcG9pbnRcbiAgICogICBJc0xvYWRpbmdTZXJ2aWNlIHdpbGwgdW5zdWJzY3JpYmUgZnJvbSB0aGVcbiAgICogICBvYnNlcnZhYmxlIGFuZCBtYXJrIHRoZSBrZXkgYXMgbm8gbG9uZ2VyIGxvYWRpbmcuXG4gICAqXG4gICAqIEZpbmFsbHksIGFzIHByZXZpb3VzbHkgbm90ZWQgdGhlIGtleSBvcHRpb24gYWxsb3dzIHlvdVxuICAgKiB0byB0cmFjayB0aGUgbG9hZGluZyBvZiBkaWZmZXJlbnQgdGhpbmdzIHNlcGVyYXRlbHkuXG4gICAqIEFueSB0cnV0aHkgdmFsdWUgY2FuIGJlIHVzZWQgYXMgYSBrZXkuIFRoZSBrZXkgb3B0aW9uXG4gICAqIGZvciBgYWRkKClgIGlzIGludGVuZGVkIHRvIGJlIHVzZWQgaW4gY29uanVuY3Rpb24gd2l0aFxuICAgKiB0aGUgYGtleWAgb3B0aW9uIGZvciBgaXNMb2FkaW5nJCgpYCBhbmQgYHJlbW92ZSgpYC4gSWZcbiAgICogeW91IHBhc3MgbXVsdGlwbGUga2V5cyB0byBgYWRkKClgLCBlYWNoIGtleSB3aWxsIGJlXG4gICAqIG1hcmtlZCBhcyBsb2FkaW5nLlxuICAgKlxuICAgKiBFeGFtcGxlOlxuICAgKlxuICAgKiBgYGB0c1xuICAgKiAgY2xhc3MgTXlDdXN0b21Db21wb25lbnQgaW1wbGVtZW50cyBPbkluaXQsIEFmdGVyVmlld0luaXQge1xuICAgKiAgICBjb25zdHJ1Y3RvcihcbiAgICogICAgICBwcml2YXRlIGxvYWRpbmdTZXJ2aWNlOiBJc0xvYWRpbmdTZXJ2aWNlLFxuICAgKiAgICAgIHByaXZhdGUgbXlDdXN0b21EYXRhU2VydmljZTogTXlDdXN0b21EYXRhU2VydmljZSxcbiAgICogICAgKSB7fVxuICAgKlxuICAgKiAgICBuZ09uSW5pdCgpIHtcbiAgICogICAgICBjb25zdCBzdWJzY3JpcHRpb24gPSB0aGlzLm15Q3VzdG9tRGF0YVNlcnZpY2UuZ2V0RGF0YSgpLnN1YnNjcmliZSgpO1xuICAgKlxuICAgKiAgICAgIC8vIE5vdGUsIHdlIGRvbid0IG5lZWQgdG8gY2FsbCByZW1vdmUoKSB3aGVuIGNhbGxpbmdcbiAgICogICAgICAvLyBhZGQoKSB3aXRoIGEgc3Vic2NyaXB0aW9uXG4gICAqICAgICAgdGhpcy5sb2FkaW5nU2VydmljZS5hZGQoc3Vic2NyaXB0aW9uLCB7XG4gICAqICAgICAgICBrZXk6ICdnZXR0aW5nLWRhdGEnXG4gICAqICAgICAgfSk7XG4gICAqXG4gICAqICAgICAgLy8gSGVyZSB3ZSBtYXJrIGBNeUN1c3RvbUNvbXBvbmVudGAgYXMgd2VsbCBhcyB0aGUgXCJkZWZhdWx0XCIga2V5XG4gICAqICAgICAgLy8gYXMgbG9hZGluZywgYW5kIHRoZW4gbWFyayB0aGVtIGFzIG5vIGxvbmdlciBsb2FkaW5nIGluXG4gICAqICAgICAgLy8gbmdBZnRlclZpZXdJbml0KClcbiAgICogICAgICB0aGlzLmxvYWRpbmdTZXJ2aWNlLmFkZCh7a2V5OiBbTXlDdXN0b21Db21wb25lbnQsICdkZWZhdWx0J119KTtcbiAgICogICAgfVxuICAgKlxuICAgKiAgICBuZ0FmdGVyVmlld0luaXQoKSB7XG4gICAqICAgICAgdGhpcy5sb2FkaW5nU2VydmljZS5yZW1vdmUoe2tleTogW015Q3VzdG9tQ29tcG9uZW50LCAnZGVmYXVsdCddfSlcbiAgICogICAgfVxuICAgKlxuICAgKiAgICBhc3luYyBzdWJtaXQoZGF0YTogYW55KSB7XG4gICAqICAgICAgLy8gaGVyZSB3ZSB0YWtlIGFkdmFudGFnZSBvZiB0aGUgZmFjdCB0aGF0IGBhZGQoKWAgcmV0dXJucyB0aGVcbiAgICogICAgICAvLyBQcm9taXNlIHBhc3NlZCB0byBpdC5cbiAgICogICAgICBhd2FpdCB0aGlzLmxvYWRpbmdTZXJ2aWNlLmFkZChcbiAgICogICAgICAgIHRoaXMubXlDdXN0b21EYXRhU2VydmljZS51cGRhdGVEYXRhKGRhdGEpLFxuICAgKiAgICAgICAgeyBrZXk6ICdidXR0b24nIH1cbiAgICogICAgICApXG4gICAqXG4gICAqICAgICAgLy8gZG8gc3R1ZmYuLi5cbiAgICogICAgfVxuICAgKiAgfVxuICAgKiBgYGBcbiAgICpcbiAgICogQHJldHVybiBJZiBjYWxsZWQgd2l0aCBhIGBTdWJzY3JpcHRpb25gLCBgUHJvbWlzZWAgb3IgYE9ic2VydmFibGVgLFxuICAgKiAgICAgICAgIHRoZSBTdWJzY3JpcHRpb24vUHJvbWlzZS9PYnNlcnZhYmxlIGlzIHJldHVybmVkLlxuICAgKiAgICAgICAgIFRoaXMgYWxsb3dzIGNvZGUgbGlrZSBgYXdhaXQgdGhpcy5pc0xvYWRpbmdTZXJ2aWNlLmFkZChwcm9taXNlKWAuXG4gICAqL1xuICBhZGQoKTogdm9pZDtcbiAgYWRkKG9wdGlvbnM6IElVcGRhdGVMb2FkaW5nT3B0aW9ucyk6IHZvaWQ7XG4gIGFkZDxUIGV4dGVuZHMgU3Vic2NyaXB0aW9uIHwgUHJvbWlzZTx1bmtub3duPiB8IE9ic2VydmFibGU8dW5rbm93bj4+KFxuICAgIHN1YjogVCxcbiAgICBvcHRpb25zPzogSVVwZGF0ZUxvYWRpbmdPcHRpb25zLFxuICApOiBUO1xuICBhZGQoXG4gICAgZmlyc3Q/OiBTdWJzY3JpcHRpb24gfCBQcm9taXNlPHVua25vd24+IHwgSVVwZGF0ZUxvYWRpbmdPcHRpb25zLFxuICAgIHNlY29uZD86IElVcGRhdGVMb2FkaW5nT3B0aW9ucyxcbiAgKSB7XG4gICAgbGV0IGtleVBhcmFtOiBLZXkgfCBLZXlbXSB8IHVuZGVmaW5lZDtcbiAgICBsZXQgc3ViOiBTdWJzY3JpcHRpb24gfCBQcm9taXNlPHVua25vd24+IHwgdW5kZWZpbmVkO1xuXG4gICAgaWYgKGZpcnN0IGluc3RhbmNlb2YgU3Vic2NyaXB0aW9uKSB7XG4gICAgICBpZiAoZmlyc3QuY2xvc2VkKSByZXR1cm4gZmlyc3Q7XG5cbiAgICAgIHN1YiA9IGZpcnN0O1xuXG4gICAgICBmaXJzdC5hZGQoKCkgPT4gdGhpcy5yZW1vdmUoZmlyc3QsIHNlY29uZCkpO1xuICAgIH0gZWxzZSBpZiAoZmlyc3QgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICBzdWIgPSBmaXJzdDtcblxuICAgICAgLy8gSWYgdGhlIHByb21pc2UgaXMgYWxyZWFkeSByZXNvbHZlZCwgdGhpcyBleGVjdXRlcyBzeW5jcm9ub3VzbHlcbiAgICAgIGZpcnN0LnRoZW4oXG4gICAgICAgICgpID0+IHRoaXMucmVtb3ZlKGZpcnN0LCBzZWNvbmQpLFxuICAgICAgICAoKSA9PiB0aGlzLnJlbW92ZShmaXJzdCwgc2Vjb25kKSxcbiAgICAgICk7XG4gICAgfSBlbHNlIGlmIChmaXJzdCBpbnN0YW5jZW9mIE9ic2VydmFibGUpIHtcbiAgICAgIHN1YiA9IGZpcnN0LnBpcGUodGFrZSgxKSkuc3Vic2NyaWJlKCk7XG5cbiAgICAgIGlmIChzdWIuY2xvc2VkKSByZXR1cm4gZmlyc3Q7XG5cbiAgICAgIHN1Yi5hZGQoKCkgPT4gdGhpcy5yZW1vdmUoc3ViIGFzIFN1YnNjcmlwdGlvbiwgc2Vjb25kKSk7XG4gICAgfSBlbHNlIGlmIChmaXJzdCkge1xuICAgICAga2V5UGFyYW0gPSBmaXJzdC5rZXk7XG4gICAgfVxuXG4gICAgaWYgKHNlY29uZCAmJiBzZWNvbmQua2V5KSB7XG4gICAgICBrZXlQYXJhbSA9IHNlY29uZC5rZXk7XG4gICAgfVxuXG4gICAgY29uc3Qga2V5cyA9IHRoaXMubm9ybWFsaXplS2V5cyhrZXlQYXJhbSk7XG5cbiAgICB0aGlzLmluZGV4S2V5cyhrZXlzKTtcblxuICAgIGtleXMuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgdGhpcy5sb2FkaW5nU3RhY2tzLmdldChrZXkpIS5wdXNoKHN1YiB8fCB0cnVlKTtcblxuICAgICAgdGhpcy51cGRhdGVMb2FkaW5nU3RhdHVzKGtleSk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gZmlyc3QgaW5zdGFuY2VvZiBPYnNlcnZhYmxlID8gZmlyc3QgOiBzdWI7XG4gIH1cblxuICAvKipcbiAgICogVXNlZCB0byBpbmRpY2F0ZSB0aGF0IHNvbWV0aGluZyBoYXMgc3RvcHBlZCBsb2FkaW5nLlxuICAgKlxuICAgKiAtIE5vdGU6IGlmIHlvdSBjYWxsIGBhZGQoKWAgd2l0aCBhIGBTdWJzY3JpcHRpb25gLFxuICAgKiAgIGBQcm9taXNlYCwgb3IgYE9ic2VydmFibGVgIGFyZ3VtZW50LCB5b3UgZG8gbm90IG5lZWRcbiAgICogICB0byBtYW51YWxseSBjYWxsIGByZW1vdmUoKS5cbiAgICpcbiAgICogV2hlbiBjYWxsZWQgd2l0aG91dCBhcmd1bWVudHMsIGByZW1vdmUoKWBcbiAgICogcmVtb3ZlcyBhIGxvYWRpbmcgaW5kaWNhdG9yIGZyb20gdGhlIGRlZmF1bHRcbiAgICogKmlzTG9hZGluZyogb2JzZXJ2YWJsZSdzIHN0YWNrLiBTbyBsb25nIGFzIGFueSBpdGVtc1xuICAgKiBhcmUgaW4gYW4gKmlzTG9hZGluZyogb2JzZXJ2YWJsZSdzIHN0YWNrLCB0aGF0XG4gICAqIG9ic2VydmFibGUgd2lsbCBiZSBtYXJrZWQgYXMgbG9hZGluZy5cbiAgICpcbiAgICogSW4gbW9yZSBhZHZhbmNlZCB1c2FnZSwgeW91IGNhbiBjYWxsIGByZW1vdmUoKWAgd2l0aFxuICAgKiBhbiBvcHRpb25zIG9iamVjdCB3aGljaCBhY2NlcHRzIGEgYGtleWAgcHJvcGVydHkuXG4gICAqIFRoZSBrZXkgYWxsb3dzIHlvdSB0byB0cmFjayB0aGUgbG9hZGluZyBvZiBkaWZmZXJlbnRcbiAgICogdGhpbmdzIHNlcGVyYXRlbHkuIEFueSB0cnV0aHkgdmFsdWUgY2FuIGJlIHVzZWQgYXMgYVxuICAgKiBrZXkuIFRoZSBrZXkgb3B0aW9uIGZvciBgcmVtb3ZlKClgIGlzIGludGVuZGVkIHRvIGJlXG4gICAqIHVzZWQgaW4gY29uanVuY3Rpb24gd2l0aCB0aGUgYGtleWAgb3B0aW9uIGZvclxuICAgKiBgaXNMb2FkaW5nJCgpYCBhbmQgYGFkZCgpYC4gSWYgeW91IHBhc3MgYW4gYXJyYXkgb2ZcbiAgICoga2V5cyB0byBgcmVtb3ZlKClgLCB0aGVuIGVhY2gga2V5IHdpbGwgYmUgbWFya2VkIGFzXG4gICAqIG5vIGxvbmdlciBsb2FkaW5nLlxuICAgKlxuICAgKiBFeGFtcGxlOlxuICAgKlxuICAgKiBgYGB0c1xuICAgKiAgY2xhc3MgTXlDdXN0b21Db21wb25lbnQgaW1wbGVtZW50cyBPbkluaXQsIEFmdGVyVmlld0luaXQge1xuICAgKiAgICBjb25zdHJ1Y3Rvcihwcml2YXRlIGxvYWRpbmdTZXJ2aWNlOiBJc0xvYWRpbmdTZXJ2aWNlKSB7fVxuICAgKlxuICAgKiAgICBuZ09uSW5pdCgpIHtcbiAgICogICAgICAvLyBQdXNoZXMgYSBsb2FkaW5nIGluZGljYXRvciBvbnRvIHRoZSBgXCJkZWZhdWx0XCJgIHN0YWNrXG4gICAqICAgICAgdGhpcy5sb2FkaW5nU2VydmljZS5hZGQoKVxuICAgKiAgICB9XG4gICAqXG4gICAqICAgIG5nQWZ0ZXJWaWV3SW5pdCgpIHtcbiAgICogICAgICAvLyBSZW1vdmVzIGEgbG9hZGluZyBpbmRpY2F0b3IgZnJvbSB0aGUgZGVmYXVsdCBzdGFja1xuICAgKiAgICAgIHRoaXMubG9hZGluZ1NlcnZpY2UucmVtb3ZlKClcbiAgICogICAgfVxuICAgKlxuICAgKiAgICBwZXJmb3JtTG9uZ0FjdGlvbigpIHtcbiAgICogICAgICAvLyBQdXNoZXMgYSBsb2FkaW5nIGluZGljYXRvciBvbnRvIHRoZSBgJ2xvbmctYWN0aW9uJ2BcbiAgICogICAgICAvLyBzdGFja1xuICAgKiAgICAgIHRoaXMubG9hZGluZ1NlcnZpY2UuYWRkKHtrZXk6ICdsb25nLWFjdGlvbid9KVxuICAgKiAgICB9XG4gICAqXG4gICAqICAgIGZpbmlzaExvbmdBY3Rpb24oKSB7XG4gICAqICAgICAgLy8gUmVtb3ZlcyBhIGxvYWRpbmcgaW5kaWNhdG9yIGZyb20gdGhlIGAnbG9uZy1hY3Rpb24nYFxuICAgKiAgICAgIC8vIHN0YWNrXG4gICAqICAgICAgdGhpcy5sb2FkaW5nU2VydmljZS5yZW1vdmUoe2tleTogJ2xvbmctYWN0aW9uJ30pXG4gICAqICAgIH1cbiAgICogIH1cbiAgICogYGBgXG4gICAqXG4gICAqL1xuICByZW1vdmUoKTogdm9pZDtcbiAgcmVtb3ZlKG9wdGlvbnM6IElVcGRhdGVMb2FkaW5nT3B0aW9ucyk6IHZvaWQ7XG4gIHJlbW92ZShcbiAgICBzdWI6IFN1YnNjcmlwdGlvbiB8IFByb21pc2U8dW5rbm93bj4sXG4gICAgb3B0aW9ucz86IElVcGRhdGVMb2FkaW5nT3B0aW9ucyxcbiAgKTogdm9pZDtcbiAgcmVtb3ZlKFxuICAgIGZpcnN0PzogU3Vic2NyaXB0aW9uIHwgUHJvbWlzZTx1bmtub3duPiB8IElVcGRhdGVMb2FkaW5nT3B0aW9ucyxcbiAgICBzZWNvbmQ/OiBJVXBkYXRlTG9hZGluZ09wdGlvbnMsXG4gICkge1xuICAgIGxldCBrZXlQYXJhbTogS2V5IHwgS2V5W10gfCB1bmRlZmluZWQ7XG4gICAgbGV0IHN1YjogU3Vic2NyaXB0aW9uIHwgUHJvbWlzZTx1bmtub3duPiB8IHVuZGVmaW5lZDtcblxuICAgIGlmIChmaXJzdCBpbnN0YW5jZW9mIFN1YnNjcmlwdGlvbikge1xuICAgICAgc3ViID0gZmlyc3Q7XG4gICAgfSBlbHNlIGlmIChmaXJzdCBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgIHN1YiA9IGZpcnN0O1xuICAgIH0gZWxzZSBpZiAoZmlyc3QpIHtcbiAgICAgIGtleVBhcmFtID0gZmlyc3Qua2V5O1xuICAgIH1cblxuICAgIGlmIChzZWNvbmQgJiYgc2Vjb25kLmtleSkge1xuICAgICAga2V5UGFyYW0gPSBzZWNvbmQua2V5O1xuICAgIH1cblxuICAgIGNvbnN0IGtleXMgPSB0aGlzLm5vcm1hbGl6ZUtleXMoa2V5UGFyYW0pO1xuXG4gICAga2V5cy5mb3JFYWNoKGtleSA9PiB7XG4gICAgICBjb25zdCBsb2FkaW5nU3RhY2sgPSB0aGlzLmxvYWRpbmdTdGFja3MuZ2V0KGtleSk7XG5cbiAgICAgIC8vICFsb2FkaW5nU3RhY2sgbWVhbnMgdGhhdCBhIHVzZXIgaGFzIGNhbGxlZCByZW1vdmUoKSBuZWVkbGVzc2x5XG4gICAgICBpZiAoIWxvYWRpbmdTdGFjaykgcmV0dXJuO1xuXG4gICAgICBjb25zdCBpbmRleCA9IGxvYWRpbmdTdGFjay5pbmRleE9mKHN1YiB8fCB0cnVlKTtcblxuICAgICAgaWYgKGluZGV4ID49IDApIHtcbiAgICAgICAgbG9hZGluZ1N0YWNrLnNwbGljZShpbmRleCwgMSk7XG5cbiAgICAgICAgdGhpcy51cGRhdGVMb2FkaW5nU3RhdHVzKGtleSk7XG5cbiAgICAgICAgdGhpcy5kZUluZGV4S2V5KGtleSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBwcml2YXRlIG5vcm1hbGl6ZUtleXMoa2V5PzogS2V5IHwgS2V5W10pOiBLZXlbXSB7XG4gICAgaWYgKCFrZXkpIGtleSA9IFt0aGlzLmRlZmF1bHRLZXldO1xuICAgIGVsc2UgaWYgKCFBcnJheS5pc0FycmF5KGtleSkpIGtleSA9IFtrZXldO1xuICAgIHJldHVybiBrZXkgYXMgS2V5W107XG4gIH1cblxuICAvKipcbiAgICogYGluZGV4S2V5cygpYCBhbG9uZyB3aXRoIGBkZUluZGV4S2V5cygpYCBoZWxwcyB1cyB0cmFjayB3aGljaFxuICAgKiBrZXlzIGFyZSBiZWluZyB3YXRjaGVkIHNvIHRoYXQgdW51c2VkIGtleXMgY2FuIGJlIGRlbGV0ZWRcbiAgICogLyBnYXJiYWdlIGNvbGxlY3RlZC5cbiAgICpcbiAgICogV2hlbiBgaW5kZXhLZXlzKClgIGlzIGNhbGxlZCB3aXRoIGFuIGFycmF5IG9mIGtleXMsIGl0IG1lYW5zXG4gICAqIHRoYXQgZWFjaCBvZiB0aG9zZSBrZXlzIGhhcyBhdCBsZWFzdCBvbmUgXCJ0aGluZ1wiIGludGVyZXN0ZWRcbiAgICogaW4gaXQuIFRoZXJlZm9yZSwgd2UgbmVlZCB0byBtYWtlIHN1cmUgdGhhdCBhIGxvYWRpbmdTdWJqZWN0XG4gICAqIGFuZCBsb2FkaW5nU3RhY2sgZXhpc3RzIGZvciB0aGF0IGtleS4gV2UgYWxzbyBuZWVkIHRvIGluZGV4XG4gICAqIHRoZSBudW1iZXIgb2YgXCJ0aGluZ3NcIiBpbnRlcmVzdGVkIGluIHRoYXQga2V5IGluIHRoZVxuICAgKiBgbG9hZGluZ0tleUluZGV4YCBtYXAuXG4gICAqXG4gICAqIFdoZW4gYGRlSW5kZXhLZXlzKClgIGlzIGNhbGxlZCB3aXRoIGFuIGFycmF5IG9mIGtleXMsIGl0XG4gICAqIG1lYW5zIHRoYXQgc29tZSBcInRoaW5nXCIgaXMgbm8gbG9uZ2VyIGludGVyZXN0ZWQgaW4gZWFjaFxuICAgKiBvZiB0aG9zZSBrZXlzLiBUaGVyZWZvcmUsIHdlIG5lZWQgdG8gcmUtaW5kZXhcbiAgICogdGhlIG51bWJlciBvZiBcInRoaW5nc1wiIGludGVyZXN0ZWQgaW4gZWFjaCBrZXkuIEZvciBrZXlzXG4gICAqIHRoYXQgbm8gbG9uZ2VyIGhhdmUgYW55dGhpbmcgaW50ZXJlc3RlZCBpbiB0aGVtLCB3ZSBuZWVkXG4gICAqIHRvIGRlbGV0ZSB0aGUgYXNzb2NpYXRlZCBgbG9hZGluZ0tleUluZGV4YCwgYGxvYWRpbmdTdWJqZWN0YCxcbiAgICogYW5kIGBsb2FkaW5nU3RhY2tgLiBTbyB0aGF0IHRoZSBga2V5YCBjYW4gYmUgcHJvcGVybHlcbiAgICogcmVsZWFzZWQgZm9yIGdhcmJhZ2UgY29sbGVjdGlvbi5cbiAgICovXG5cbiAgcHJpdmF0ZSBpbmRleEtleXMoa2V5czogS2V5W10pIHtcbiAgICBrZXlzLmZvckVhY2goa2V5ID0+IHtcbiAgICAgIGlmICh0aGlzLmxvYWRpbmdLZXlJbmRleC5oYXMoa2V5KSkge1xuICAgICAgICBjb25zdCBjdXJyID0gdGhpcy5sb2FkaW5nS2V5SW5kZXguZ2V0KGtleSkhO1xuICAgICAgICB0aGlzLmxvYWRpbmdLZXlJbmRleC5zZXQoa2V5LCBjdXJyICsgMSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBzdWJqZWN0ID0gbmV3IEJlaGF2aW9yU3ViamVjdChmYWxzZSk7XG5cbiAgICAgICAgdGhpcy5sb2FkaW5nS2V5SW5kZXguc2V0KGtleSwgMSk7XG4gICAgICAgIHRoaXMubG9hZGluZ1N1YmplY3RzLnNldChrZXksIHN1YmplY3QpO1xuICAgICAgICB0aGlzLmxvYWRpbmdTdGFja3Muc2V0KGtleSwgW10pO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgcHJpdmF0ZSBkZUluZGV4S2V5KGtleTogS2V5KSB7XG4gICAgY29uc3QgY3VyciA9IHRoaXMubG9hZGluZ0tleUluZGV4LmdldChrZXkpITtcblxuICAgIGlmIChjdXJyID09PSAxKSB7XG4gICAgICB0aGlzLmxvYWRpbmdLZXlJbmRleC5kZWxldGUoa2V5KTtcbiAgICAgIHRoaXMubG9hZGluZ1N1YmplY3RzLmRlbGV0ZShrZXkpO1xuICAgICAgdGhpcy5sb2FkaW5nU3RhY2tzLmRlbGV0ZShrZXkpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmxvYWRpbmdLZXlJbmRleC5zZXQoa2V5LCBjdXJyIC0gMSk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSB1cGRhdGVMb2FkaW5nU3RhdHVzKGtleTogS2V5KSB7XG4gICAgY29uc3QgbG9hZGluZ1N0YXR1cyA9IHRoaXMubG9hZGluZ1N0YWNrcy5nZXQoa2V5KSEubGVuZ3RoID4gMDtcblxuICAgIHRoaXMubG9hZGluZ1N1YmplY3RzLmdldChrZXkpIS5uZXh0KGxvYWRpbmdTdGF0dXMpO1xuICB9XG59XG4iXX0=