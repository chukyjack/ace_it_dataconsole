"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const schematics_1 = require("@angular-devkit/schematics");
const config_1 = require("@schematics/angular/utility/config");
const hammerJsMinAddress = './node_modules/hammerjs/hammer.min.js';
function logIncludingDependency(context, pkg, version) {
    context.logger.info(`Including ${pkg} - Version: ${version}`);
}
function overwriteJsonFile(tree, targetFile, data) {
    tree.overwrite(targetFile, JSON.stringify(data, null, 2) + '\n');
}
exports.overwriteJsonFile = overwriteJsonFile;
function logSuccess(options) {
    return (tree, context) => {
        context.logger.info('');
        context.logger.warn('Ignite UI for Angular installed');
        context.logger.info('Learn more: https://www.infragistics.com/products/ignite-ui-angular');
        context.logger.info('');
    };
}
exports.logSuccess = logSuccess;
function addDependencies(options) {
    return (tree, context) => {
        const pkgJson = require('../../package.json');
        const dependencies = 'dependencies';
        const devDependencies = 'devDependencies';
        Object.keys(pkgJson.dependencies).forEach(pkg => {
            const version = pkgJson.dependencies[pkg];
            switch (pkg) {
                case 'hammerjs':
                    addPackageToPkgJson(tree, pkg, version, dependencies);
                    addHammerJsToWorkspace(tree);
                    logIncludingDependency(context, pkg, version);
                    break;
                default:
                    addPackageToPkgJson(tree, pkg, version, dependencies);
                    logIncludingDependency(context, pkg, version);
                    break;
            }
        });
        // Add web-animations-js to dependencies
        Object.keys(pkgJson.peerDependencies).forEach(pkg => {
            const version = pkgJson.peerDependencies[pkg];
            if (pkg.includes('web-animations')) {
                addPackageToPkgJson(tree, pkg, version, dependencies);
                logIncludingDependency(context, pkg, version);
                return;
            }
        });
        addPackageToPkgJson(tree, 'igniteui-cli', pkgJson.devDependencies['igniteui-cli'], devDependencies);
        return tree;
    };
}
exports.addDependencies = addDependencies;
function addHammerJsToWorkspace(tree) {
    try {
        const workspace = config_1.getWorkspace(tree);
        const addedtoBuildScripts = addHammerToAngularWorkspace(workspace, 'build');
        const addedtoToTestScripts = addHammerToAngularWorkspace(workspace, 'test');
        if (addedtoBuildScripts || addedtoToTestScripts) {
            overwriteJsonFile(tree, 'angular.json', workspace);
        }
        return tree;
    }
    catch (e) {
        if (e.toString().includes('Could not find (undefined)')) {
            throw new schematics_1.SchematicsException('angular.json was not found in the project\'s root');
        }
        throw new Error(e.message);
    }
}
/**
 * Add Hammer script to angular.json section
 * @param workspace Angular Workspace Schema (angular.json)
 * @param key Architect tool key to add option to
 */
function addHammerToAngularWorkspace(workspace, key) {
    const currentProjectName = workspace.defaultProject;
    if (currentProjectName) {
        if (!workspace.projects[currentProjectName].architect) {
            workspace.projects[currentProjectName].architect = {};
        }
        if (!workspace.projects[currentProjectName].architect[key]) {
            workspace.projects[currentProjectName].architect[key] = {};
        }
        if (!workspace.projects[currentProjectName].architect[key].options) {
            workspace.projects[currentProjectName].architect[key].options = {};
        }
        if (!workspace.projects[currentProjectName].architect[key].options.scripts) {
            workspace.projects[currentProjectName].architect[key].options.scripts = [];
        }
        if (!workspace.projects[currentProjectName].architect[key].options.scripts.includes(hammerJsMinAddress)) {
            workspace.projects[currentProjectName].architect[key].options.scripts.push(hammerJsMinAddress);
            return true;
        }
        return false;
    }
}
function addPackageToPkgJson(tree, pkg, version, target) {
    const targetFile = 'package.json';
    if (tree.exists(targetFile)) {
        const sourceText = tree.read(targetFile).toString();
        const json = JSON.parse(sourceText);
        if (!json[target]) {
            json[target] = {};
        }
        if (!json.dependencies[pkg]) {
            json[target][pkg] = version;
            json[target] =
                Object.keys(json[target])
                    .sort()
                    .reduce((result, key) => (result[key] = json[target][key]) && result, {});
            tree.overwrite(targetFile, JSON.stringify(json, null, 2) + '\n');
        }
    }
    return tree;
}
