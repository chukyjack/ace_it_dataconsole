/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import * as tslib_1 from "tslib";
/**
 * @hidden
 * @param {?} array
 * @param {?=} deep
 * @return {?}
 */
export function cloneArray(array, deep) {
    /** @type {?} */
    var arr = [];
    if (!array) {
        return arr;
    }
    /** @type {?} */
    var i = array.length;
    while (i--) {
        arr[i] = deep ? cloneValue(array[i]) : array[i];
    }
    return arr;
}
/**
 * Doesn't clone leaf items
 * @hidden
 * @param {?} array
 * @param {?} childDataKey
 * @return {?}
 */
export function cloneHierarchicalArray(array, childDataKey) {
    var e_1, _a;
    /** @type {?} */
    var result = [];
    if (!array) {
        return result;
    }
    try {
        for (var array_1 = tslib_1.__values(array), array_1_1 = array_1.next(); !array_1_1.done; array_1_1 = array_1.next()) {
            var item = array_1_1.value;
            /** @type {?} */
            var clonedItem = cloneValue(item);
            if (Array.isArray(item[childDataKey])) {
                clonedItem[childDataKey] = cloneHierarchicalArray(clonedItem[childDataKey], childDataKey);
            }
            result.push(clonedItem);
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (array_1_1 && !array_1_1.done && (_a = array_1.return)) _a.call(array_1);
        }
        finally { if (e_1) throw e_1.error; }
    }
    return result;
}
/**
 * Deep clones all first level keys of Obj2 and merges them to Obj1
 * @hidden
 * @param {?} obj1 Object to merge into
 * @param {?} obj2 Object to merge from
 * @return {?} Obj1 with merged cloned keys from Obj2
 */
export function mergeObjects(obj1, obj2) {
    var e_2, _a;
    if (!isObject(obj1)) {
        throw new Error("Cannot merge into " + obj1 + ". First param must be an object.");
    }
    if (!isObject(obj2)) {
        return obj1;
    }
    try {
        for (var _b = tslib_1.__values(Object.keys(obj2)), _c = _b.next(); !_c.done; _c = _b.next()) {
            var key = _c.value;
            obj1[key] = cloneValue(obj2[key]);
        }
    }
    catch (e_2_1) { e_2 = { error: e_2_1 }; }
    finally {
        try {
            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
        }
        finally { if (e_2) throw e_2.error; }
    }
    return obj1;
}
/**
 * Creates deep clone of provided value.
 * Supports primitive values, dates and objects.
 * If passed value is array returns shallow copy of the array.
 * @hidden
 * @param {?} value value to clone
 * @return {?} Deep copy of provided value
 */
export function cloneValue(value) {
    var e_3, _a;
    if (isDate(value)) {
        return new Date(value.getTime());
    }
    if (Array.isArray(value)) {
        return tslib_1.__spread(value);
    }
    if (value instanceof Map || value instanceof Set) {
        return value;
    }
    if (isObject(value)) {
        /** @type {?} */
        var result = {};
        try {
            for (var _b = tslib_1.__values(Object.keys(value)), _c = _b.next(); !_c.done; _c = _b.next()) {
                var key = _c.value;
                result[key] = cloneValue(value[key]);
            }
        }
        catch (e_3_1) { e_3 = { error: e_3_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_3) throw e_3.error; }
        }
        return result;
    }
    return value;
}
/**
 * Checks if provided variable is Object
 * @hidden
 * @param {?} value Value to check
 * @return {?} true if provided variable is Object
 */
export function isObject(value) {
    return value && value.toString() === '[object Object]';
}
/**
 * Checks if provided variable is Date
 * @hidden
 * @param {?} value Value to check
 * @return {?} true if provided variable is Date
 */
export function isDate(value) {
    return Object.prototype.toString.call(value) === '[object Date]';
}
/**
 * Checks if the two passed arguments are equal
 * Currently supports date objects
 * \@returns: `boolean`
 * @hidden
 * @param {?} obj1
 * @param {?} obj2
 * @return {?}
 */
export function isEqual(obj1, obj2) {
    if (isDate(obj1) && isDate(obj2)) {
        return obj1.getTime() === obj2.getTime();
    }
    return obj1 === obj2;
}
/** @enum {number} */
var KEYCODES = {
    ENTER: 13,
    SPACE: 32,
    ESCAPE: 27,
    LEFT_ARROW: 37,
    UP_ARROW: 38,
    RIGHT_ARROW: 39,
    DOWN_ARROW: 40,
    F2: 113,
    TAB: 9,
};
export { KEYCODES };
/** @enum {string} */
var KEYS = {
    ENTER: 'Enter',
    SPACE: ' ',
    SPACE_IE: 'Spacebar',
    ESCAPE: 'Escape',
    ESCAPE_IE: 'Esc',
    LEFT_ARROW: 'ArrowLeft',
    LEFT_ARROW_IE: 'Left',
    UP_ARROW: 'ArrowUp',
    UP_ARROW_IE: 'Up',
    RIGHT_ARROW: 'ArrowRight',
    RIGHT_ARROW_IE: 'Right',
    DOWN_ARROW: 'ArrowDown',
    DOWN_ARROW_IE: 'Down',
    F2: 'F2',
    TAB: 'Tab',
};
export { KEYS };
/**
 * @hidden
 * Returns the actual size of the node content, using Range
 * ```typescript
 * let range = document.createRange();
 * let column = this.grid.columnList.filter(c => c.field === 'ID')[0];
 *
 * let size = getNodeSizeViaRange(range, column.cells[0].nativeElement);
 * ```
 * @param {?} range
 * @param {?} node
 * @return {?}
 */
export function getNodeSizeViaRange(range, node) {
    /** @type {?} */
    var overflow = null;
    if (!isFirefox()) {
        overflow = node.style.overflow;
        // we need that hack - otherwise content won't be measured correctly in IE/Edge
        node.style.overflow = 'visible';
    }
    range.selectNodeContents(node);
    /** @type {?} */
    var width = range.getBoundingClientRect().width;
    if (!isFirefox()) {
        // we need that hack - otherwise content won't be measured correctly in IE/Edge
        node.style.overflow = overflow;
    }
    return width;
}
/**
 * @hidden
 * Returns the actual size of the node content, using Canvas
 * ```typescript
 * let ctx = document.createElement('canvas').getContext('2d');
 * let column = this.grid.columnList.filter(c => c.field === 'ID')[0];
 *
 * let size = valToPxlsUsingCanvas(ctx, column.cells[0].nativeElement);
 * ```
 * @param {?} canvas2dCtx
 * @param {?} node
 * @return {?}
 */
export function getNodeSizeViaCanvas(canvas2dCtx, node) {
    /** @type {?} */
    var s = this.grid.document.defaultView.getComputedStyle(node);
    // need to set the font to get correct width
    canvas2dCtx.font = s.fontSize + ' ' + s.fontFamily;
    return canvas2dCtx.measureText(node.textContent).width;
}
/**
 * @hidden
 * @return {?}
 */
export function isIE() {
    return navigator.appVersion.indexOf('Trident/') > 0;
}
/**
 * @hidden
 * @return {?}
 */
export function isEdge() {
    /** @type {?} */
    var edgeBrowser = /Edge[\/\s](\d+\.\d+)/.test(navigator.userAgent);
    return edgeBrowser;
}
/**
 * @hidden
 * @return {?}
 */
export function isFirefox() {
    /** @type {?} */
    var firefoxBrowser = /Firefox[\/\s](\d+\.\d+)/.test(navigator.userAgent);
    return firefoxBrowser;
}
/**
 * @hidden
 * @param {?} event
 * @return {?}
 */
export function isLeftClick(event) {
    return event.button === 0;
}
/**
 * @hidden
 * @param {?} key
 * @return {?}
 */
export function isNavigationKey(key) {
    return ['down', 'up', 'left', 'right', 'arrowdown', 'arrowup', 'arrowleft', 'arrowright',
        'home', 'end', 'space', 'spacebar', ' '].indexOf(key) !== -1;
}
/**
 * @hidden
 * @param {?} arr
 * @return {?}
 */
export function flatten(arr) {
    /** @type {?} */
    var result = [];
    arr.forEach(function (el) {
        result.push(el);
        if (el.children) {
            /** @type {?} */
            var children = Array.isArray(el.children) ? el.children : el.children.toArray();
            result = result.concat(flatten(children));
        }
    });
    return result;
}
/**
 * @record
 */
export function CancelableEventArgs() { }
if (false) {
    /**
     * Provides the ability to cancel the event.
     * @type {?}
     */
    CancelableEventArgs.prototype.cancel;
}
/**
 * @record
 */
export function CancelableBrowserEventArgs() { }
if (false) {
    /**
     * Browser event
     * @type {?|undefined}
     */
    CancelableBrowserEventArgs.prototype.event;
}
/** @type {?} */
export var NAVIGATION_KEYS = new Set(['down', 'up', 'left', 'right', 'arrowdown', 'arrowup', 'arrowleft', 'arrowright',
    'home', 'end', 'space', 'spacebar', ' ']);
/** @type {?} */
export var ROW_EXPAND_KEYS = new Set('right down arrowright arrowdown'.split(' '));
/** @type {?} */
export var ROW_COLLAPSE_KEYS = new Set('left up arrowleft arrowup'.split(' '));
/** @type {?} */
export var SUPPORTED_KEYS = new Set(tslib_1.__spread(Array.from(NAVIGATION_KEYS), ['tab', 'enter', 'f2', 'escape', 'esc']));
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidXRpbHMuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9pZ25pdGV1aS1hbmd1bGFyLyIsInNvdXJjZXMiOlsibGliL2NvcmUvdXRpbHMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFHQSxNQUFNLFVBQVUsVUFBVSxDQUFDLEtBQVksRUFBRSxJQUFjOztRQUM3QyxHQUFHLEdBQUcsRUFBRTtJQUNkLElBQUksQ0FBQyxLQUFLLEVBQUU7UUFDUixPQUFPLEdBQUcsQ0FBQztLQUNkOztRQUNHLENBQUMsR0FBRyxLQUFLLENBQUMsTUFBTTtJQUNwQixPQUFPLENBQUMsRUFBRSxFQUFFO1FBQ1IsR0FBRyxDQUFDLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxDQUFDLENBQUMsVUFBVSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUM7S0FDbkQ7SUFDRCxPQUFPLEdBQUcsQ0FBQztBQUNmLENBQUM7Ozs7Ozs7O0FBTUQsTUFBTSxVQUFVLHNCQUFzQixDQUFDLEtBQVksRUFBRSxZQUFpQjs7O1FBQzVELE1BQU0sR0FBVSxFQUFFO0lBQ3hCLElBQUksQ0FBQyxLQUFLLEVBQUU7UUFDUixPQUFPLE1BQU0sQ0FBQztLQUNqQjs7UUFFRCxLQUFtQixJQUFBLFVBQUEsaUJBQUEsS0FBSyxDQUFBLDRCQUFBLCtDQUFFO1lBQXJCLElBQU0sSUFBSSxrQkFBQTs7Z0JBQ0wsVUFBVSxHQUFHLFVBQVUsQ0FBQyxJQUFJLENBQUM7WUFDbkMsSUFBSSxLQUFLLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxZQUFZLENBQUMsQ0FBQyxFQUFFO2dCQUNuQyxVQUFVLENBQUMsWUFBWSxDQUFDLEdBQUcsc0JBQXNCLENBQUMsVUFBVSxDQUFDLFlBQVksQ0FBQyxFQUFFLFlBQVksQ0FBQyxDQUFDO2FBQzdGO1lBQ0QsTUFBTSxDQUFDLElBQUksQ0FBQyxVQUFVLENBQUMsQ0FBQztTQUMzQjs7Ozs7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QUMsQ0FBQztJQUNILE9BQU8sTUFBTSxDQUFDO0FBQ2xCLENBQUM7Ozs7QUFFRCx5Q0FLQzs7Ozs7O0lBREcscUNBQWdCOzs7OztBQUdwQixnREFHQzs7Ozs7O0lBREcsMkNBQWM7OztBQUdsQixNQUFNLEtBQU8sZUFBZSxHQUFHLElBQUksR0FBRyxDQUFDLENBQUMsTUFBTSxFQUFFLElBQUksRUFBRSxNQUFNLEVBQUUsT0FBTyxFQUFFLFdBQVcsRUFBRSxTQUFTLEVBQUUsV0FBVyxFQUFFLFlBQVk7SUFDeEYsTUFBTSxFQUFFLEtBQUssRUFBRSxPQUFPLEVBQUUsVUFBVSxFQUFFLEdBQUcsQ0FBQyxDQUFDOztBQUN6RSxNQUFNLEtBQU8sZUFBZSxHQUFHLElBQUksR0FBRyxDQUFDLGlDQUFpQyxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FBQzs7QUFDcEYsTUFBTSxLQUFPLGlCQUFpQixHQUFHLElBQUksR0FBRyxDQUFDLDJCQUEyQixDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FBQzs7QUFDaEYsTUFBTSxLQUFPLGNBQWMsR0FBRyxJQUFJLEdBQUcsa0JBQUssS0FBSyxDQUFDLElBQUksQ0FBQyxlQUFlLENBQUMsR0FBRSxLQUFLLEVBQUUsT0FBTyxFQUFFLElBQUksRUFBRSxRQUFRLEVBQUUsS0FBSyxHQUFFIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKkBoaWRkZW5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNsb25lQXJyYXkoYXJyYXk6IGFueVtdLCBkZWVwPzogYm9vbGVhbikge1xuICAgIGNvbnN0IGFyciA9IFtdO1xuICAgIGlmICghYXJyYXkpIHtcbiAgICAgICAgcmV0dXJuIGFycjtcbiAgICB9XG4gICAgbGV0IGkgPSBhcnJheS5sZW5ndGg7XG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgICBhcnJbaV0gPSBkZWVwID8gY2xvbmVWYWx1ZShhcnJheVtpXSkgOiBhcnJheVtpXTtcbiAgICB9XG4gICAgcmV0dXJuIGFycjtcbn1cblxuLyoqXG4gKiBEb2Vzbid0IGNsb25lIGxlYWYgaXRlbXNcbiAqIEBoaWRkZW5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNsb25lSGllcmFyY2hpY2FsQXJyYXkoYXJyYXk6IGFueVtdLCBjaGlsZERhdGFLZXk6IGFueSk6IGFueVtdIHtcbiAgICBjb25zdCByZXN1bHQ6IGFueVtdID0gW107XG4gICAgaWYgKCFhcnJheSkge1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIGZvciAoY29uc3QgaXRlbSBvZiBhcnJheSkge1xuICAgICAgICBjb25zdCBjbG9uZWRJdGVtID0gY2xvbmVWYWx1ZShpdGVtKTtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoaXRlbVtjaGlsZERhdGFLZXldKSkge1xuICAgICAgICAgICAgY2xvbmVkSXRlbVtjaGlsZERhdGFLZXldID0gY2xvbmVIaWVyYXJjaGljYWxBcnJheShjbG9uZWRJdGVtW2NoaWxkRGF0YUtleV0sIGNoaWxkRGF0YUtleSk7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0LnB1c2goY2xvbmVkSXRlbSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogRGVlcCBjbG9uZXMgYWxsIGZpcnN0IGxldmVsIGtleXMgb2YgT2JqMiBhbmQgbWVyZ2VzIHRoZW0gdG8gT2JqMVxuICogQHBhcmFtIG9iajEgT2JqZWN0IHRvIG1lcmdlIGludG9cbiAqIEBwYXJhbSBvYmoyIE9iamVjdCB0byBtZXJnZSBmcm9tXG4gKiBAcmV0dXJucyBPYmoxIHdpdGggbWVyZ2VkIGNsb25lZCBrZXlzIGZyb20gT2JqMlxuICogQGhpZGRlblxuICovXG5leHBvcnQgZnVuY3Rpb24gbWVyZ2VPYmplY3RzKG9iajE6IHt9LCBvYmoyOiB7fSk6IGFueSB7XG4gICAgaWYgKCFpc09iamVjdChvYmoxKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENhbm5vdCBtZXJnZSBpbnRvICR7b2JqMX0uIEZpcnN0IHBhcmFtIG11c3QgYmUgYW4gb2JqZWN0LmApO1xuICAgIH1cblxuICAgIGlmICghaXNPYmplY3Qob2JqMikpIHtcbiAgICAgICAgcmV0dXJuIG9iajE7XG4gICAgfVxuXG4gICAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXMob2JqMikpIHtcbiAgICAgICAgb2JqMVtrZXldID0gY2xvbmVWYWx1ZShvYmoyW2tleV0pO1xuICAgIH1cblxuICAgIHJldHVybiBvYmoxO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgZGVlcCBjbG9uZSBvZiBwcm92aWRlZCB2YWx1ZS5cbiAqIFN1cHBvcnRzIHByaW1pdGl2ZSB2YWx1ZXMsIGRhdGVzIGFuZCBvYmplY3RzLlxuICogSWYgcGFzc2VkIHZhbHVlIGlzIGFycmF5IHJldHVybnMgc2hhbGxvdyBjb3B5IG9mIHRoZSBhcnJheS5cbiAqIEBwYXJhbSB2YWx1ZSB2YWx1ZSB0byBjbG9uZVxuICogQHJldHVybnMgRGVlcCBjb3B5IG9mIHByb3ZpZGVkIHZhbHVlXG4gKkBoaWRkZW5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNsb25lVmFsdWUodmFsdWU6IGFueSk6IGFueSB7XG4gICAgaWYgKGlzRGF0ZSh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBEYXRlKHZhbHVlLmdldFRpbWUoKSk7XG4gICAgfVxuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gWy4uLnZhbHVlXTtcbiAgICB9XG5cbiAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBNYXAgfHwgdmFsdWUgaW5zdGFuY2VvZiBTZXQpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cblxuICAgIGlmIChpc09iamVjdCh2YWx1ZSkpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0ge307XG5cbiAgICAgICAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXModmFsdWUpKSB7XG4gICAgICAgICAgICByZXN1bHRba2V5XSA9IGNsb25lVmFsdWUodmFsdWVba2V5XSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBwcm92aWRlZCB2YXJpYWJsZSBpcyBPYmplY3RcbiAqIEBwYXJhbSB2YWx1ZSBWYWx1ZSB0byBjaGVja1xuICogQHJldHVybnMgdHJ1ZSBpZiBwcm92aWRlZCB2YXJpYWJsZSBpcyBPYmplY3RcbiAqQGhpZGRlblxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNPYmplY3QodmFsdWU6IGFueSk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB2YWx1ZSAmJiB2YWx1ZS50b1N0cmluZygpID09PSAnW29iamVjdCBPYmplY3RdJztcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgcHJvdmlkZWQgdmFyaWFibGUgaXMgRGF0ZVxuICogQHBhcmFtIHZhbHVlIFZhbHVlIHRvIGNoZWNrXG4gKiBAcmV0dXJucyB0cnVlIGlmIHByb3ZpZGVkIHZhcmlhYmxlIGlzIERhdGVcbiAqQGhpZGRlblxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNEYXRlKHZhbHVlOiBhbnkpIHtcbiAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSA9PT0gJ1tvYmplY3QgRGF0ZV0nO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiB0aGUgdHdvIHBhc3NlZCBhcmd1bWVudHMgYXJlIGVxdWFsXG4gKiBDdXJyZW50bHkgc3VwcG9ydHMgZGF0ZSBvYmplY3RzXG4gKiBAcGFyYW0gb2JqMVxuICogQHBhcmFtIG9iajJcbiAqIEByZXR1cm5zOiBgYm9vbGVhbmBcbiAqIEBoaWRkZW5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzRXF1YWwob2JqMSwgb2JqMik6IGJvb2xlYW4ge1xuICAgIGlmIChpc0RhdGUob2JqMSkgJiYgaXNEYXRlKG9iajIpKSB7XG4gICAgICAgIHJldHVybiBvYmoxLmdldFRpbWUoKSA9PT0gb2JqMi5nZXRUaW1lKCk7XG4gICAgfVxuICAgIHJldHVybiBvYmoxID09PSBvYmoyO1xufVxuXG4vKipcbiAqQGhpZGRlblxuICovXG5leHBvcnQgY29uc3QgZW51bSBLRVlDT0RFUyB7XG4gICAgRU5URVIgPSAxMyxcbiAgICBTUEFDRSA9IDMyLFxuICAgIEVTQ0FQRSA9IDI3LFxuICAgIExFRlRfQVJST1cgPSAzNyxcbiAgICBVUF9BUlJPVyA9IDM4LFxuICAgIFJJR0hUX0FSUk9XID0gMzksXG4gICAgRE9XTl9BUlJPVyA9IDQwLFxuICAgIEYyID0gMTEzLFxuICAgIFRBQiA9IDlcbn1cblxuLyoqXG4gKkBoaWRkZW5cbiAqL1xuZXhwb3J0IGNvbnN0IGVudW0gS0VZUyB7XG4gICAgRU5URVIgPSAnRW50ZXInLFxuICAgIFNQQUNFID0gJyAnLFxuICAgIFNQQUNFX0lFID0gJ1NwYWNlYmFyJyxcbiAgICBFU0NBUEUgPSAnRXNjYXBlJyxcbiAgICBFU0NBUEVfSUUgPSAnRXNjJyxcbiAgICBMRUZUX0FSUk9XID0gJ0Fycm93TGVmdCcsXG4gICAgTEVGVF9BUlJPV19JRSA9ICdMZWZ0JyxcbiAgICBVUF9BUlJPVyA9ICdBcnJvd1VwJyxcbiAgICBVUF9BUlJPV19JRSA9ICdVcCcsXG4gICAgUklHSFRfQVJST1cgPSAnQXJyb3dSaWdodCcsXG4gICAgUklHSFRfQVJST1dfSUUgPSAnUmlnaHQnLFxuICAgIERPV05fQVJST1cgPSAnQXJyb3dEb3duJyxcbiAgICBET1dOX0FSUk9XX0lFID0gJ0Rvd24nLFxuICAgIEYyID0gJ0YyJyxcbiAgICBUQUIgPSAnVGFiJ1xufVxuXG4vKipcbiAqQGhpZGRlblxuKiBSZXR1cm5zIHRoZSBhY3R1YWwgc2l6ZSBvZiB0aGUgbm9kZSBjb250ZW50LCB1c2luZyBSYW5nZVxuKiBgYGB0eXBlc2NyaXB0XG4qIGxldCByYW5nZSA9IGRvY3VtZW50LmNyZWF0ZVJhbmdlKCk7XG4qIGxldCBjb2x1bW4gPSB0aGlzLmdyaWQuY29sdW1uTGlzdC5maWx0ZXIoYyA9PiBjLmZpZWxkID09PSAnSUQnKVswXTtcbipcbiogbGV0IHNpemUgPSBnZXROb2RlU2l6ZVZpYVJhbmdlKHJhbmdlLCBjb2x1bW4uY2VsbHNbMF0ubmF0aXZlRWxlbWVudCk7XG4qIGBgYFxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0Tm9kZVNpemVWaWFSYW5nZShyYW5nZTogUmFuZ2UsIG5vZGU6IGFueSk6IG51bWJlciB7XG4gICAgbGV0IG92ZXJmbG93ID0gbnVsbDtcbiAgICBpZiAoIWlzRmlyZWZveCgpKSB7XG4gICAgICAgIG92ZXJmbG93ID0gbm9kZS5zdHlsZS5vdmVyZmxvdztcbiAgICAgICAgLy8gd2UgbmVlZCB0aGF0IGhhY2sgLSBvdGhlcndpc2UgY29udGVudCB3b24ndCBiZSBtZWFzdXJlZCBjb3JyZWN0bHkgaW4gSUUvRWRnZVxuICAgICAgICBub2RlLnN0eWxlLm92ZXJmbG93ID0gJ3Zpc2libGUnO1xuICAgIH1cblxuICAgIHJhbmdlLnNlbGVjdE5vZGVDb250ZW50cyhub2RlKTtcbiAgICBjb25zdCB3aWR0aCA9IHJhbmdlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLndpZHRoO1xuXG4gICAgaWYgKCFpc0ZpcmVmb3goKSkge1xuICAgICAgICAvLyB3ZSBuZWVkIHRoYXQgaGFjayAtIG90aGVyd2lzZSBjb250ZW50IHdvbid0IGJlIG1lYXN1cmVkIGNvcnJlY3RseSBpbiBJRS9FZGdlXG4gICAgICAgIG5vZGUuc3R5bGUub3ZlcmZsb3cgPSBvdmVyZmxvdztcbiAgICB9XG5cbiAgICByZXR1cm4gd2lkdGg7XG59XG4vKipcbiAqQGhpZGRlblxuKiBSZXR1cm5zIHRoZSBhY3R1YWwgc2l6ZSBvZiB0aGUgbm9kZSBjb250ZW50LCB1c2luZyBDYW52YXNcbiogYGBgdHlwZXNjcmlwdFxuKiBsZXQgY3R4ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJykuZ2V0Q29udGV4dCgnMmQnKTtcbiogbGV0IGNvbHVtbiA9IHRoaXMuZ3JpZC5jb2x1bW5MaXN0LmZpbHRlcihjID0+IGMuZmllbGQgPT09ICdJRCcpWzBdO1xuKlxuKiBsZXQgc2l6ZSA9IHZhbFRvUHhsc1VzaW5nQ2FudmFzKGN0eCwgY29sdW1uLmNlbGxzWzBdLm5hdGl2ZUVsZW1lbnQpO1xuKiBgYGBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldE5vZGVTaXplVmlhQ2FudmFzKGNhbnZhczJkQ3R4OiBhbnksIG5vZGU6IGFueSk6IG51bWJlciB7XG4gICAgY29uc3QgcyA9IHRoaXMuZ3JpZC5kb2N1bWVudC5kZWZhdWx0Vmlldy5nZXRDb21wdXRlZFN0eWxlKG5vZGUpO1xuXG4gICAgLy8gbmVlZCB0byBzZXQgdGhlIGZvbnQgdG8gZ2V0IGNvcnJlY3Qgd2lkdGhcbiAgICBjYW52YXMyZEN0eC5mb250ID0gcy5mb250U2l6ZSArICcgJyArIHMuZm9udEZhbWlseTtcblxuICAgIHJldHVybiBjYW52YXMyZEN0eC5tZWFzdXJlVGV4dChub2RlLnRleHRDb250ZW50KS53aWR0aDtcbn1cbi8qKlxuICpAaGlkZGVuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0lFKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiBuYXZpZ2F0b3IuYXBwVmVyc2lvbi5pbmRleE9mKCdUcmlkZW50LycpID4gMDtcbn1cbi8qKlxuICpAaGlkZGVuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0VkZ2UoKTogYm9vbGVhbiB7XG4gICAgY29uc3QgZWRnZUJyb3dzZXIgPSAvRWRnZVtcXC9cXHNdKFxcZCtcXC5cXGQrKS8udGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcbiAgICByZXR1cm4gZWRnZUJyb3dzZXI7XG59XG5cbi8qKlxuICpAaGlkZGVuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0ZpcmVmb3goKTogYm9vbGVhbiB7XG4gICAgY29uc3QgZmlyZWZveEJyb3dzZXIgPSAvRmlyZWZveFtcXC9cXHNdKFxcZCtcXC5cXGQrKS8udGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcbiAgICByZXR1cm4gZmlyZWZveEJyb3dzZXI7XG59XG5cbi8qKlxuICogQGhpZGRlblxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNMZWZ0Q2xpY2soZXZlbnQ6IFBvaW50ZXJFdmVudCkge1xuICAgIHJldHVybiBldmVudC5idXR0b24gPT09IDA7XG59XG5cbi8qKiBAaGlkZGVuICovXG5leHBvcnQgZnVuY3Rpb24gaXNOYXZpZ2F0aW9uS2V5KGtleTogc3RyaW5nKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIFsnZG93bicsICd1cCcsICdsZWZ0JywgJ3JpZ2h0JywgJ2Fycm93ZG93bicsICdhcnJvd3VwJywgJ2Fycm93bGVmdCcsICdhcnJvd3JpZ2h0JyxcbiAgICAgICAgJ2hvbWUnLCAnZW5kJywgJ3NwYWNlJywgJ3NwYWNlYmFyJywgJyAnXS5pbmRleE9mKGtleSkgIT09IC0xO1xufVxuXG4vKipcbiAqQGhpZGRlblxuICovXG5leHBvcnQgZnVuY3Rpb24gZmxhdHRlbihhcnI6IGFueVtdKSB7XG4gICAgbGV0IHJlc3VsdCA9IFtdO1xuXG4gICAgYXJyLmZvckVhY2goZWwgPT4ge1xuICAgICAgICByZXN1bHQucHVzaChlbCk7XG4gICAgICAgIGlmIChlbC5jaGlsZHJlbikge1xuICAgICAgICAgICAgY29uc3QgY2hpbGRyZW4gPSBBcnJheS5pc0FycmF5KGVsLmNoaWxkcmVuKSA/IGVsLmNoaWxkcmVuIDogZWwuY2hpbGRyZW4udG9BcnJheSgpO1xuICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0LmNvbmNhdChmbGF0dGVuKGNoaWxkcmVuKSk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIENhbmNlbGFibGVFdmVudEFyZ3Mge1xuICAgIC8qKlxuICAgICAqIFByb3ZpZGVzIHRoZSBhYmlsaXR5IHRvIGNhbmNlbCB0aGUgZXZlbnQuXG4gICAgICovXG4gICAgY2FuY2VsOiBib29sZWFuO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIENhbmNlbGFibGVCcm93c2VyRXZlbnRBcmdzIGV4dGVuZHMgQ2FuY2VsYWJsZUV2ZW50QXJncyB7XG4gICAgLyoqIEJyb3dzZXIgZXZlbnQgKi9cbiAgICBldmVudD86IEV2ZW50O1xufVxuXG5leHBvcnQgY29uc3QgTkFWSUdBVElPTl9LRVlTID0gbmV3IFNldChbJ2Rvd24nLCAndXAnLCAnbGVmdCcsICdyaWdodCcsICdhcnJvd2Rvd24nLCAnYXJyb3d1cCcsICdhcnJvd2xlZnQnLCAnYXJyb3dyaWdodCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdob21lJywgJ2VuZCcsICdzcGFjZScsICdzcGFjZWJhcicsICcgJ10pO1xuZXhwb3J0IGNvbnN0IFJPV19FWFBBTkRfS0VZUyA9IG5ldyBTZXQoJ3JpZ2h0IGRvd24gYXJyb3dyaWdodCBhcnJvd2Rvd24nLnNwbGl0KCcgJykpO1xuZXhwb3J0IGNvbnN0IFJPV19DT0xMQVBTRV9LRVlTID0gbmV3IFNldCgnbGVmdCB1cCBhcnJvd2xlZnQgYXJyb3d1cCcuc3BsaXQoJyAnKSk7XG5leHBvcnQgY29uc3QgU1VQUE9SVEVEX0tFWVMgPSBuZXcgU2V0KFsuLi5BcnJheS5mcm9tKE5BVklHQVRJT05fS0VZUyksICd0YWInLCAnZW50ZXInLCAnZjInLCAnZXNjYXBlJywgJ2VzYyddKTtcbiJdfQ==