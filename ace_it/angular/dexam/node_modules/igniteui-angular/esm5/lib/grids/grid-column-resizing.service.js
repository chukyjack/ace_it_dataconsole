/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { Injectable, NgZone } from '@angular/core';
/**
 * @hidden
 */
var IgxColumnResizingService = /** @class */ (function () {
    function IgxColumnResizingService(zone) {
        this.zone = zone;
        /**
         * @hidden
         */
        this.resizeCursor = null;
        /**
         * @hidden
         */
        this.showResizer = false;
    }
    Object.defineProperty(IgxColumnResizingService.prototype, "resizerHeight", {
        /**
         *@hidden
         */
        get: /**
         * @hidden
         * @return {?}
         */
        function () {
            /** @type {?} */
            var height = this.column.grid.getVisibleContentHeight();
            if (this.column.level !== 0) {
                height -= this.column.topLevelParent.headerGroup.height - this.column.headerGroup.height;
            }
            return height;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxColumnResizingService.prototype, "restrictResizeMin", {
        /**
         * Returns the minimal possible width to which the column can be resized.
         */
        get: /**
         * Returns the minimal possible width to which the column can be resized.
         * @return {?}
         */
        function () {
            /** @type {?} */
            var actualMinWidth = parseFloat(this.column.minWidth);
            /** @type {?} */
            var defaultMinWidth = parseFloat(this.column.defaultMinWidth);
            /** @type {?} */
            var minWidth = Number.isNaN(actualMinWidth) || actualMinWidth < defaultMinWidth ? defaultMinWidth : actualMinWidth;
            minWidth = minWidth < parseFloat(this.column.width) ? minWidth : parseFloat(this.column.width);
            return this.column.headerCell.elementRef.nativeElement.getBoundingClientRect().width - minWidth;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxColumnResizingService.prototype, "restrictResizeMax", {
        /**
         * Returns the maximal possible width to which the column can be resized.
         */
        get: /**
         * Returns the maximal possible width to which the column can be resized.
         * @return {?}
         */
        function () {
            /** @type {?} */
            var actualWidth = this.column.headerCell.elementRef.nativeElement.getBoundingClientRect().width;
            if (this.column.pinned) {
                /** @type {?} */
                var pinnedMaxWidth = this.pinnedMaxWidth =
                    this.column.grid.calcPinnedContainerMaxWidth - this.column.grid.getPinnedWidth(true) + actualWidth;
                if (this.column.maxWidth && parseFloat(this.column.maxWidth) < pinnedMaxWidth) {
                    this.pinnedMaxWidth = this.column.maxWidth;
                    return parseFloat(this.column.maxWidth) - actualWidth;
                }
                else {
                    return pinnedMaxWidth - actualWidth;
                }
            }
            else {
                if (this.column.maxWidth) {
                    return parseFloat(this.column.maxWidth) - actualWidth;
                }
                else {
                    return Number.MAX_SAFE_INTEGER;
                }
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Autosizes the column to the longest currently visible cell value, including the header cell.
     * If the column has a predifined maxWidth and the autosized column width will become bigger than it,
     * then the column is sized to its maxWidth.
     * If the column is pinned and the autosized column width will cause the pinned area to become bigger
     * than the maximum allowed pinned area width (80% of the total grid width), autosizing will be deismissed.
     */
    /**
     * Autosizes the column to the longest currently visible cell value, including the header cell.
     * If the column has a predifined maxWidth and the autosized column width will become bigger than it,
     * then the column is sized to its maxWidth.
     * If the column is pinned and the autosized column width will cause the pinned area to become bigger
     * than the maximum allowed pinned area width (80% of the total grid width), autosizing will be deismissed.
     * @return {?}
     */
    IgxColumnResizingService.prototype.autosizeColumnOnDblClick = /**
     * Autosizes the column to the longest currently visible cell value, including the header cell.
     * If the column has a predifined maxWidth and the autosized column width will become bigger than it,
     * then the column is sized to its maxWidth.
     * If the column is pinned and the autosized column width will cause the pinned area to become bigger
     * than the maximum allowed pinned area width (80% of the total grid width), autosizing will be deismissed.
     * @return {?}
     */
    function () {
        /** @type {?} */
        var currentColWidth = this.column.headerCell.elementRef.nativeElement.getBoundingClientRect().width;
        /** @type {?} */
        var size = this.column.getLargestCellWidth();
        if (this.column.pinned) {
            /** @type {?} */
            var newPinnedWidth = this.column.grid.getPinnedWidth(true) - currentColWidth + parseFloat(size);
            if (newPinnedWidth <= this.column.grid.calcPinnedContainerMaxWidth) {
                this.column.width = size;
            }
        }
        else if (this.column.maxWidth && (parseFloat(size) > parseFloat(this.column.maxWidth))) {
            this.column.width = parseFloat(this.column.maxWidth) + 'px';
        }
        else if (parseFloat(size) < parseFloat(this.column.defaultMinWidth)) {
            this.column.width = this.column.defaultMinWidth + 'px';
        }
        else {
            this.column.width = size;
        }
        this.zone.run(function () { });
        this.column.grid.reflow();
        this.column.grid.onColumnResized.emit({
            column: this.column,
            prevWidth: currentColWidth.toString(),
            newWidth: this.column.width
        });
    };
    /**
     * Resizes the column regaridng to the column minWidth and maxWidth.
     */
    /**
     * Resizes the column regaridng to the column minWidth and maxWidth.
     * @param {?} event
     * @return {?}
     */
    IgxColumnResizingService.prototype.resizeColumn = /**
     * Resizes the column regaridng to the column minWidth and maxWidth.
     * @param {?} event
     * @return {?}
     */
    function (event) {
        this.showResizer = false;
        /** @type {?} */
        var diff = event.clientX - this.startResizePos;
        /** @type {?} */
        var currentColWidth = parseFloat(this.column.width);
        /** @type {?} */
        var actualMinWidth = parseFloat(this.column.minWidth);
        /** @type {?} */
        var defaultMinWidth = parseFloat(this.column.defaultMinWidth);
        /** @type {?} */
        var colMinWidth = Number.isNaN(actualMinWidth) || actualMinWidth < defaultMinWidth ? defaultMinWidth : actualMinWidth;
        /** @type {?} */
        var colMaxWidth = this.column.pinned ? parseFloat(this.pinnedMaxWidth) : parseFloat(this.column.maxWidth);
        /** @type {?} */
        var actualWidth = this.column.headerCell.elementRef.nativeElement.getBoundingClientRect().width;
        currentColWidth = Number.isNaN(currentColWidth) || (currentColWidth < actualWidth) ? actualWidth : currentColWidth;
        colMinWidth = colMinWidth < currentColWidth ? colMinWidth : currentColWidth;
        if (currentColWidth + diff < colMinWidth) {
            this.column.width = colMinWidth + 'px';
        }
        else if (colMaxWidth && (currentColWidth + diff > colMaxWidth)) {
            this.column.width = colMaxWidth + 'px';
        }
        else {
            this.column.width = (currentColWidth + diff) + 'px';
        }
        this.zone.run(function () { });
        this.column.grid.reflow();
        if (currentColWidth !== parseFloat(this.column.width)) {
            this.column.grid.onColumnResized.emit({
                column: this.column,
                prevWidth: currentColWidth.toString(),
                newWidth: this.column.width
            });
        }
        this.isColumnResizing = false;
    };
    IgxColumnResizingService.decorators = [
        { type: Injectable }
    ];
    /** @nocollapse */
    IgxColumnResizingService.ctorParameters = function () { return [
        { type: NgZone }
    ]; };
    return IgxColumnResizingService;
}());
export { IgxColumnResizingService };
if (false) {
    /**
     * @type {?}
     * @private
     */
    IgxColumnResizingService.prototype.pinnedMaxWidth;
    /**
     * @hidden
     * @type {?}
     */
    IgxColumnResizingService.prototype.startResizePos;
    /**
     * Indicates that a column is currently being resized.
     * @type {?}
     */
    IgxColumnResizingService.prototype.isColumnResizing;
    /**
     * @hidden
     * @type {?}
     */
    IgxColumnResizingService.prototype.resizeCursor;
    /**
     * @hidden
     * @type {?}
     */
    IgxColumnResizingService.prototype.showResizer;
    /**
     * The column being resized.
     * @type {?}
     */
    IgxColumnResizingService.prototype.column;
    /**
     * @type {?}
     * @private
     */
    IgxColumnResizingService.prototype.zone;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZ3JpZC1jb2x1bW4tcmVzaXppbmcuc2VydmljZS5qcyIsInNvdXJjZVJvb3QiOiJuZzovL2lnbml0ZXVpLWFuZ3VsYXIvIiwic291cmNlcyI6WyJsaWIvZ3JpZHMvZ3JpZC1jb2x1bW4tcmVzaXppbmcuc2VydmljZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7O0FBQUEsT0FBTyxFQUFFLFVBQVUsRUFBRSxNQUFNLEVBQUUsTUFBTSxlQUFlLENBQUM7Ozs7QUFJbkQ7SUEwQkksa0NBQW9CLElBQVk7UUFBWixTQUFJLEdBQUosSUFBSSxDQUFROzs7O1FBVnpCLGlCQUFZLEdBQVcsSUFBSSxDQUFDOzs7O1FBSTVCLGdCQUFXLEdBQUcsS0FBSyxDQUFDO0lBTVMsQ0FBQztJQUtyQyxzQkFBSSxtREFBYTtRQUhqQjs7V0FFRzs7Ozs7UUFDSDs7Z0JBQ1EsTUFBTSxHQUFHLElBQUksQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLHVCQUF1QixFQUFFO1lBRXZELElBQUksSUFBSSxDQUFDLE1BQU0sQ0FBQyxLQUFLLEtBQUssQ0FBQyxFQUFFO2dCQUN6QixNQUFNLElBQUksSUFBSSxDQUFDLE1BQU0sQ0FBQyxjQUFjLENBQUMsV0FBVyxDQUFDLE1BQU0sR0FBRyxJQUFJLENBQUMsTUFBTSxDQUFDLFdBQVcsQ0FBQyxNQUFNLENBQUM7YUFDNUY7WUFFRCxPQUFPLE1BQU0sQ0FBQztRQUNsQixDQUFDOzs7T0FBQTtJQUtELHNCQUFJLHVEQUFpQjtRQUhyQjs7V0FFRzs7Ozs7UUFDSDs7Z0JBQ1UsY0FBYyxHQUFHLFVBQVUsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLFFBQVEsQ0FBQzs7Z0JBQ2pELGVBQWUsR0FBRyxVQUFVLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxlQUFlLENBQUM7O2dCQUUzRCxRQUFRLEdBQUcsTUFBTSxDQUFDLEtBQUssQ0FBQyxjQUFjLENBQUMsSUFBSSxjQUFjLEdBQUcsZUFBZSxDQUFDLENBQUMsQ0FBQyxlQUFlLENBQUMsQ0FBQyxD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QUFJLENBQUM7Z0JBQ2xDLE1BQU0sRUFBRSxJQUFJLENBQUMsTUFBTTtnQkFDbkIsU0FBUyxFQUFFLGVBQWUsQ0FBQyxRQUFRLEVBQUU7Z0JBQ3JDLFFBQVEsRUFBRSxJQUFJLENBQUMsTUFBTSxDQUFDLEtBQUs7YUFDOUIsQ0FBQyxDQUFDO1NBQ047UUFFRCxJQUFJLENBQUMsZ0JBQWdCLEdBQUcsS0FBSyxDQUFDO0lBQ2xDLENBQUM7O2dCQTVKSixVQUFVOzs7O2dCQUpVLE1BQU07O0lBaUszQiwrQkFBQztDQUFBLEFBN0pELElBNkpDO1NBNUpZLHdCQUF3Qjs7Ozs7O0lBRWpDLGtEQUErQjs7Ozs7SUFLL0Isa0RBQThCOzs7OztJQUk5QixvREFBaUM7Ozs7O0lBSWpDLGdEQUFtQzs7Ozs7SUFJbkMsK0NBQTJCOzs7OztJQUkzQiwwQ0FBa0M7Ozs7O0lBRXRCLHdDQUFvQiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEluamVjdGFibGUsIE5nWm9uZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgSWd4Q29sdW1uQ29tcG9uZW50IH0gZnJvbSAnLi9jb2x1bW4uY29tcG9uZW50JztcblxuLyoqIEBoaWRkZW4gKi9cbkBJbmplY3RhYmxlKClcbmV4cG9ydCBjbGFzcyBJZ3hDb2x1bW5SZXNpemluZ1NlcnZpY2Uge1xuXG4gICAgcHJpdmF0ZSBwaW5uZWRNYXhXaWR0aDogc3RyaW5nO1xuXG4gICAgLyoqXG4gICAgICpAaGlkZGVuXG4gICAgICovXG4gICAgcHVibGljIHN0YXJ0UmVzaXplUG9zOiBudW1iZXI7XG4gICAgLyoqXG4gICAgICogSW5kaWNhdGVzIHRoYXQgYSBjb2x1bW4gaXMgY3VycmVudGx5IGJlaW5nIHJlc2l6ZWQuXG4gICAgICovXG4gICAgcHVibGljIGlzQ29sdW1uUmVzaXppbmc6IGJvb2xlYW47XG4gICAgLyoqXG4gICAgICpAaGlkZGVuXG4gICAgICovXG4gICAgcHVibGljIHJlc2l6ZUN1cnNvcjogc3RyaW5nID0gbnVsbDtcbiAgICAvKipcbiAgICAgKkBoaWRkZW5cbiAgICAgKi9cbiAgICBwdWJsaWMgc2hvd1Jlc2l6ZXIgPSBmYWxzZTtcbiAgICAvKipcbiAgICAgKiBUaGUgY29sdW1uIGJlaW5nIHJlc2l6ZWQuXG4gICAgICovXG4gICAgcHVibGljIGNvbHVtbjogSWd4Q29sdW1uQ29tcG9uZW50O1xuXG4gICAgY29uc3RydWN0b3IocHJpdmF0ZSB6b25lOiBOZ1pvbmUpIHsgfVxuXG4gICAgLyoqXG4gICAgICpAaGlkZGVuXG4gICAgICovXG4gICAgZ2V0IHJlc2l6ZXJIZWlnaHQoKTogbnVtYmVyIHtcbiAgICAgICAgbGV0IGhlaWdodCA9IHRoaXMuY29sdW1uLmdyaWQuZ2V0VmlzaWJsZUNvbnRlbnRIZWlnaHQoKTtcblxuICAgICAgICBpZiAodGhpcy5jb2x1bW4ubGV2ZWwgIT09IDApIHtcbiAgICAgICAgICAgIGhlaWdodCAtPSB0aGlzLmNvbHVtbi50b3BMZXZlbFBhcmVudC5oZWFkZXJHcm91cC5oZWlnaHQgLSB0aGlzLmNvbHVtbi5oZWFkZXJHcm91cC5oZWlnaHQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gaGVpZ2h0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIG1pbmltYWwgcG9zc2libGUgd2lkdGggdG8gd2hpY2ggdGhlIGNvbHVtbiBjYW4gYmUgcmVzaXplZC5cbiAgICAgKi9cbiAgICBnZXQgcmVzdHJpY3RSZXNpemVNaW4oKTogbnVtYmVyIHtcbiAgICAgICAgY29uc3QgYWN0dWFsTWluV2lkdGggPSBwYXJzZUZsb2F0KHRoaXMuY29sdW1uLm1pbldpZHRoKTtcbiAgICAgICAgY29uc3QgZGVmYXVsdE1pbldpZHRoID0gcGFyc2VGbG9hdCh0aGlzLmNvbHVtbi5kZWZhdWx0TWluV2lkdGgpO1xuXG4gICAgICAgIGxldCBtaW5XaWR0aCA9IE51bWJlci5pc05hTihhY3R1YWxNaW5XaWR0aCkgfHwgYWN0dWFsTWluV2lkdGggPCBkZWZhdWx0TWluV2lkdGggPyBkZWZhdWx0TWluV2lkdGggOiBhY3R1YWxNaW5XaWR0aDtcbiAgICAgICAgbWluV2lkdGggPSBtaW5XaWR0aCA8IHBhcnNlRmxvYXQodGhpcy5jb2x1bW4ud2lkdGgpID8gbWluV2lkdGggOiBwYXJzZUZsb2F0KHRoaXMuY29sdW1uLndpZHRoKTtcblxuICAgICAgICByZXR1cm4gdGhpcy5jb2x1bW4uaGVhZGVyQ2VsbC5lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkud2lkdGggLSBtaW5XaWR0aDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBtYXhpbWFsIHBvc3NpYmxlIHdpZHRoIHRvIHdoaWNoIHRoZSBjb2x1bW4gY2FuIGJlIHJlc2l6ZWQuXG4gICAgICovXG4gICAgZ2V0IHJlc3RyaWN0UmVzaXplTWF4KCk6IG51bWJlciB7XG4gICAgICAgIGNvbnN0IGFjdHVhbFdpZHRoID0gdGhpcy5jb2x1bW4uaGVhZGVyQ2VsbC5lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkud2lkdGg7XG5cbiAgICAgICAgaWYgKHRoaXMuY29sdW1uLnBpbm5lZCkge1xuICAgICAgICAgICAgY29uc3QgcGlubmVkTWF4V2lkdGggPSB0aGlzLnBpbm5lZE1heFdpZHRoID1cbiAgICAgICAgICAgICAgICB0aGlzLmNvbHVtbi5ncmlkLmNhbGNQaW5uZWRDb250YWluZXJNYXhXaWR0aCAtIHRoaXMuY29sdW1uLmdyaWQuZ2V0UGlubmVkV2lkdGgodHJ1ZSkgKyBhY3R1YWxXaWR0aDtcblxuICAgICAgICAgICAgaWYgKHRoaXMuY29sdW1uLm1heFdpZHRoICYmIHBhcnNlRmxvYXQodGhpcy5jb2x1bW4ubWF4V2lkdGgpIDwgcGlubmVkTWF4V2lkdGgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnBpbm5lZE1heFdpZHRoID0gdGhpcy5jb2x1bW4ubWF4V2lkdGg7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VGbG9hdCh0aGlzLmNvbHVtbi5tYXhXaWR0aCkgLSBhY3R1YWxXaWR0aDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBpbm5lZE1heFdpZHRoIC0gYWN0dWFsV2lkdGg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAodGhpcy5jb2x1bW4ubWF4V2lkdGgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VGbG9hdCh0aGlzLmNvbHVtbi5tYXhXaWR0aCkgLSBhY3R1YWxXaWR0aDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIE51bWJlci5NQVhfU0FGRV9JTlRFR0VSO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQXV0b3NpemVzIHRoZSBjb2x1bW4gdG8gdGhlIGxvbmdlc3QgY3VycmVudGx5IHZpc2libGUgY2VsbCB2YWx1ZSwgaW5jbHVkaW5nIHRoZSBoZWFkZXIgY2VsbC5cbiAgICAgKiBJZiB0aGUgY29sdW1uIGhhcyBhIHByZWRpZmluZWQgbWF4V2lkdGggYW5kIHRoZSBhdXRvc2l6ZWQgY29sdW1uIHdpZHRoIHdpbGwgYmVjb21lIGJpZ2dlciB0aGFuIGl0LFxuICAgICAqIHRoZW4gdGhlIGNvbHVtbiBpcyBzaXplZCB0byBpdHMgbWF4V2lkdGguXG4gICAgICogSWYgdGhlIGNvbHVtbiBpcyBwaW5uZWQgYW5kIHRoZSBhdXRvc2l6ZWQgY29sdW1uIHdpZHRoIHdpbGwgY2F1c2UgdGhlIHBpbm5lZCBhcmVhIHRvIGJlY29tZSBiaWdnZXJcbiAgICAgKiB0aGFuIHRoZSBtYXhpbXVtIGFsbG93ZWQgcGlubmVkIGFyZWEgd2lkdGggKDgwJSBvZiB0aGUgdG90YWwgZ3JpZCB3aWR0aCksIGF1dG9zaXppbmcgd2lsbCBiZSBkZWlzbWlzc2VkLlxuICAgICAqL1xuICAgIHB1YmxpYyBhdXRvc2l6ZUNvbHVtbk9uRGJsQ2xpY2soKSB7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRDb2xXaWR0aCA9IHRoaXMuY29sdW1uLmhlYWRlckNlbGwuZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLndpZHRoO1xuXG4gICAgICAgIGNvbnN0IHNpemUgPSB0aGlzLmNvbHVtbi5nZXRMYXJnZXN0Q2VsbFdpZHRoKCk7XG5cbiAgICAgICAgaWYgKHRoaXMuY29sdW1uLnBpbm5lZCkge1xuICAgICAgICAgICAgY29uc3QgbmV3UGlubmVkV2lkdGggPSB0aGlzLmNvbHVtbi5ncmlkLmdldFBpbm5lZFdpZHRoKHRydWUpIC0gY3VycmVudENvbFdpZHRoICsgcGFyc2VGbG9hdChzaXplKTtcblxuICAgICAgICAgICAgaWYgKG5ld1Bpbm5lZFdpZHRoIDw9IHRoaXMuY29sdW1uLmdyaWQuY2FsY1Bpbm5lZENvbnRhaW5lck1heFdpZHRoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jb2x1bW4ud2lkdGggPSBzaXplO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuY29sdW1uLm1heFdpZHRoICYmIChwYXJzZUZsb2F0KHNpemUpID4gcGFyc2VGbG9hdCh0aGlzLmNvbHVtbi5tYXhXaWR0aCkpKSB7XG4gICAgICAgICAgICB0aGlzLmNvbHVtbi53aWR0aCA9IHBhcnNlRmxvYXQodGhpcy5jb2x1bW4ubWF4V2lkdGgpICsgJ3B4JztcbiAgICAgICAgfSBlbHNlIGlmIChwYXJzZUZsb2F0KHNpemUpIDwgcGFyc2VGbG9hdCh0aGlzLmNvbHVtbi5kZWZhdWx0TWluV2lkdGgpKSB7XG4gICAgICAgICAgICB0aGlzLmNvbHVtbi53aWR0aCA9IHRoaXMuY29sdW1uLmRlZmF1bHRNaW5XaWR0aCArICdweCc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmNvbHVtbi53aWR0aCA9IHNpemU7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnpvbmUucnVuKCgpID0+IHt9KTtcblxuICAgICAgICB0aGlzLmNvbHVtbi5ncmlkLnJlZmxvdygpO1xuICAgICAgICB0aGlzLmNvbHVtbi5ncmlkLm9uQ29sdW1uUmVzaXplZC5lbWl0KHtcbiAgICAgICAgICAgIGNvbHVtbjogdGhpcy5jb2x1bW4sXG4gICAgICAgICAgICBwcmV2V2lkdGg6IGN1cnJlbnRDb2xXaWR0aC50b1N0cmluZygpLFxuICAgICAgICAgICAgbmV3V2lkdGg6IHRoaXMuY29sdW1uLndpZHRoXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlc2l6ZXMgdGhlIGNvbHVtbiByZWdhcmlkbmcgdG8gdGhlIGNvbHVtbiBtaW5XaWR0aCBhbmQgbWF4V2lkdGguXG4gICAgICovXG4gICAgcHVibGljIHJlc2l6ZUNvbHVtbihldmVudDogTW91c2VFdmVudCkge1xuICAgICAgICB0aGlzLnNob3dSZXNpemVyID0gZmFsc2U7XG4gICAgICAgIGNvbnN0IGRpZmYgPSBldmVudC5jbGllbnRYIC0gdGhpcy5zdGFydFJlc2l6ZVBvcztcblxuICAgICAgICBsZXQgY3VycmVudENvbFdpZHRoID0gcGFyc2VGbG9hdCh0aGlzLmNvbHVtbi53aWR0aCk7XG5cbiAgICAgICAgY29uc3QgYWN0dWFsTWluV2lkdGggPSBwYXJzZUZsb2F0KHRoaXMuY29sdW1uLm1pbldpZHRoKTtcbiAgICAgICAgY29uc3QgZGVmYXVsdE1pbldpZHRoID0gcGFyc2VGbG9hdCh0aGlzLmNvbHVtbi5kZWZhdWx0TWluV2lkdGgpO1xuXG4gICAgICAgIGxldCBjb2xNaW5XaWR0aCA9IE51bWJlci5pc05hTihhY3R1YWxNaW5XaWR0aCkgfHwgYWN0dWFsTWluV2lkdGggPCBkZWZhdWx0TWluV2lkdGggPyBkZWZhdWx0TWluV2lkdGggOiBhY3R1YWxNaW5XaWR0aDtcbiAgICAgICAgY29uc3QgY29sTWF4V2lkdGggPSB0aGlzLmNvbHVtbi5waW5uZWQgPyBwYXJzZUZsb2F0KHRoaXMucGlubmVkTWF4V2lkdGgpIDogcGFyc2VGbG9hdCh0aGlzLmNvbHVtbi5tYXhXaWR0aCk7XG5cbiAgICAgICAgY29uc3QgYWN0dWFsV2lkdGggPSB0aGlzLmNvbHVtbi5oZWFkZXJDZWxsLmVsZW1lbnRSZWYubmF0aXZlRWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS53aWR0aDtcblxuICAgICAgICBjdXJyZW50Q29sV2lkdGggPSBOdW1iZXIuaXNOYU4oY3VycmVudENvbFdpZHRoKSB8fCAoY3VycmVudENvbFdpZHRoIDwgYWN0dWFsV2lkdGgpID8gYWN0dWFsV2lkdGggOiBjdXJyZW50Q29sV2lkdGg7XG4gICAgICAgIGNvbE1pbldpZHRoID0gY29sTWluV2lkdGggPCBjdXJyZW50Q29sV2lkdGggPyBjb2xNaW5XaWR0aCA6IGN1cnJlbnRDb2xXaWR0aDtcblxuICAgICAgICBpZiAoY3VycmVudENvbFdpZHRoICsgZGlmZiA8IGNvbE1pbldpZHRoKSB7XG4gICAgICAgICAgICB0aGlzLmNvbHVtbi53aWR0aCA9IGNvbE1pbldpZHRoICsgJ3B4JztcbiAgICAgICAgfSBlbHNlIGlmIChjb2xNYXhXaWR0aCAmJiAoY3VycmVudENvbFdpZHRoICsgZGlmZiA+IGNvbE1heFdpZHRoKSkge1xuICAgICAgICAgICAgdGhpcy5jb2x1bW4ud2lkdGggPSBjb2xNYXhXaWR0aCArICdweCc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmNvbHVtbi53aWR0aCA9IChjdXJyZW50Q29sV2lkdGggKyBkaWZmKSArICdweCc7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnpvbmUucnVuKCgpID0+IHt9KTtcbiAgICAgICAgdGhpcy5jb2x1bW4uZ3JpZC5yZWZsb3coKTtcblxuICAgICAgICBpZiAoY3VycmVudENvbFdpZHRoICE9PSBwYXJzZUZsb2F0KHRoaXMuY29sdW1uLndpZHRoKSkge1xuICAgICAgICAgICAgdGhpcy5jb2x1bW4uZ3JpZC5vbkNvbHVtblJlc2l6ZWQuZW1pdCh7XG4gICAgICAgICAgICAgICAgY29sdW1uOiB0aGlzLmNvbHVtbixcbiAgICAgICAgICAgICAgICBwcmV2V2lkdGg6IGN1cnJlbnRDb2xXaWR0aC50b1N0cmluZygpLFxuICAgICAgICAgICAgICAgIG5ld1dpZHRoOiB0aGlzLmNvbHVtbi53aWR0aFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmlzQ29sdW1uUmVzaXppbmcgPSBmYWxzZTtcbiAgICB9XG59XG4iXX0=