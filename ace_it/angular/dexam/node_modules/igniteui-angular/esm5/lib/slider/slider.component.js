/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import * as tslib_1 from "tslib";
import { CommonModule } from '@angular/common';
import { Component, ElementRef, EventEmitter, HostBinding, Input, NgModule, Output, Renderer2, ViewChild, Directive, TemplateRef, ContentChild, HostListener, ViewChildren, QueryList } from '@angular/core';
import { NG_VALUE_ACCESSOR } from '@angular/forms';
import { DeprecateProperty } from '../core/deprecateDecorators';
import { IgxSliderThumbModule, IgxSliderThumbComponent } from './thumb/thumb-slider.component';
import { Subject, merge } from 'rxjs';
import { takeUntil } from 'rxjs/operators';
/**
 * Template directive that allows you to set a custom template representing the lower label value of the {\@link IgxSliderComponent}
 *
 * ```html
 * <igx-slider>
 *  <ng-template igxSliderThumbFrom let-value let-labels>{{value}}</ng-template>
 * </igx-slider>
 * ```
 *
 * \@context {\@link IgxSliderComponent.context}
 */
var IgxThumbFromTemplateDirective = /** @class */ (function () {
    function IgxThumbFromTemplateDirective() {
    }
    IgxThumbFromTemplateDirective.decorators = [
        { type: Directive, args: [{
                    selector: '[igxSliderThumbFrom]'
                },] }
    ];
    return IgxThumbFromTemplateDirective;
}());
export { IgxThumbFromTemplateDirective };
/**
 * Template directive that allows you to set a custom template representing the upper label value of the {\@link IgxSliderComponent}
 *
 * ```html
 * <igx-slider>
 *  <ng-template igxSliderThumbTo let-value let-labels>{{value}}</ng-template>
 * </igx-slider>
 * ```
 *
 * \@context {\@link IgxSliderComponent.context}
 */
var IgxThumbToTemplateDirective = /** @class */ (function () {
    function IgxThumbToTemplateDirective() {
    }
    IgxThumbToTemplateDirective.decorators = [
        { type: Directive, args: [{
                    selector: '[igxSliderThumbTo]'
                },] }
    ];
    return IgxThumbToTemplateDirective;
}());
export { IgxThumbToTemplateDirective };
/** @enum {number} */
var SliderType = {
    /**
     * Slider with single thumb.
     */
    SLIDER: 0,
    /**
     *  Range slider with multiple thumbs, that can mark the range.
     */
    RANGE: 1,
};
export { SliderType };
SliderType[SliderType.SLIDER] = 'SLIDER';
SliderType[SliderType.RANGE] = 'RANGE';
/** @enum {number} */
var SliderHandle = {
    FROM: 0,
    TO: 1,
};
export { SliderHandle };
SliderHandle[SliderHandle.FROM] = 'FROM';
SliderHandle[SliderHandle.TO] = 'TO';
/**
 * @record
 */
export function IRangeSliderValue() { }
if (false) {
    /** @type {?} */
    IRangeSliderValue.prototype.lower;
    /** @type {?} */
    IRangeSliderValue.prototype.upper;
}
/**
 * @record
 */
export function ISliderValueChangeEventArgs() { }
if (false) {
    /** @type {?} */
    ISliderValueChangeEventArgs.prototype.oldValue;
    /** @type {?} */
    ISliderValueChangeEventArgs.prototype.value;
}
/** @type {?} */
var noop = function () {
};
var Éµ0 = noop;
/** @type {?} */
var NEXT_ID = 0;
/**
 * **Ignite UI for Angular Slider** -
 * [Documentation](https://www.infragistics.com/products/ignite-ui-angular/angular/components/slider.html)
 *
 * The Ignite UI Slider allows selection in a given range by moving the thumb along the track. The track
 * can be defined as continuous or stepped, and you can choose between single and range slider types.
 *
 * Example:
 * ```html
 * <igx-slider id="slider"
 *            [minValue]="0" [maxValue]="100"
 *            [continuous]=true [(ngModel)]="volume">
 * </igx-slider>
 * ```
 */
var IgxSliderComponent = /** @class */ (function () {
    function IgxSliderComponent(renderer, _el) {
        this.renderer = renderer;
        this._el = _el;
        // Limit handle travel zone
        this._pMin = 0;
        this._pMax = 1;
        // From/upperValue in percent values
        this._hasViewInit = false;
        this._minValue = 0;
        this._maxValue = 100;
        this._countinuous = false;
        this._disabled = false;
        this._step = 1;
        this._labels = new Array();
        this._type = SliderType.SLIDER;
        this._destroy$ = new Subject();
        this._onChangeCallback = noop;
        this._onTouchedCallback = noop;
        /**
         * @hidden
         */
        this.thumbs = new QueryList();
        /**
         * @hidden
         */
        this.stepDistance = this._step;
        /**
         * @hidden
         */
        this.onPan = new Subject();
        /**
         * @hidden
         */
        this.role = 'slider';
        /**
         * @hidden
         */
        this.slierClass = true;
        /**
         * An \@Input property that sets the value of the `id` attribute.
         * If not provided it will be automatically generated.
         * ```html
         * <igx-slider [id]="'igx-slider-32'" [(ngModel)]="task.percentCompleted" [step]="5" [lowerBound]="20">
         * ```
         */
        this.id = "igx-slider-" + NEXT_ID++;
        /**
         * An \@Input property that sets the duration visibility of thumbs labels. The default value is 750 milliseconds.
         * ```html
         * <igx-slider #slider [thumbLabelVisibilityDuration]="3000" [(ngModel)]="task.percentCompleted" [step]="5">
         * ```
         */
        this.thumbLabelVisibilityDuration = 750;
        /**
         * This event is emitted when user has stopped interacting the thumb and value is changed.
         * ```typescript
         * public change(event){
         *    alert("The value has been changed!");
         * }
         * ```
         * ```html
         * <igx-slider (onValueChange)="change($event)" #slider [(ngModel)]="task.percentCompleted" [step]="5">
         * ```
         */
        this.onValueChange = new EventEmitter();
    }
    Object.defineProperty(IgxSliderComponent.prototype, "thumbFrom", {
        get: /**
         * @private
         * @return {?}
         */
        function () {
            return this.thumbs.find(function (thumb) { return thumb.type === SliderHandle.FROM; });
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxSliderComponent.prototype, "thumbTo", {
        get: /**
         * @private
         * @return {?}
         */
        function () {
            return this.thumbs.find(function (thumb) { return thumb.type === SliderHandle.TO; });
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxSliderComponent.prototype, "valuemin", {
        /**
         * @hidden
         */
        get: /**
         * @hidden
         * @return {?}
         */
        function () {
            return this.minValue;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxSliderComponent.prototype, "valuemax", {
        /**
         * @hidden
         */
        get: /**
         * @hidden
         * @return {?}
         */
        function () {
            return this.maxValue;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxSliderComponent.prototype, "readonly", {
        /**
         * @hidden
         */
        get: /**
         * @hidden
         * @return {?}
         */
        function () {
            return this.disabled;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxSliderComponent.prototype, "disabledClass", {
        /**
         * @hidden
         */
        get: /**
         * @hidden
         * @return {?}
         */
        function () {
            return this.disabled;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxSliderComponent.prototype, "type", {
        /**
         * An @Input property that gets the type of the `IgxSliderComponent`. The slider can be SliderType.SLIDER(default) or SliderType.RANGE.
         * ```typescript
         * @ViewChild("slider2")
         * public slider: IgxSliderComponent;
         * ngAfterViewInit(){
         *     let type = this.slider.type;
         * }
         */
        get: /**
         * An \@Input property that gets the type of the `IgxSliderComponent`. The slider can be SliderType.SLIDER(default) or SliderType.RANGE.
         * ```typescript
         * \@ViewChild("slider2")
         * public slider: IgxSliderComponent;
         * ngAfterViewInit(){
         *     let type = this.slider.type;
         * }
         * @return {?}
         */
        function () {
            return this._type;
        },
        /**
         * An @Input property that sets the type of the `IgxSliderComponent`. The slider can be SliderType.SLIDER(default) or SliderType.RANGE.
         * ```typescript
         * sliderType: SliderType = SliderType.RANGE;
         * ```
         * ```html
         * <igx-slider #slider2 [type]="sliderType" [(ngModel)]="rangeValue" [minValue]="0" [maxValue]="100">
         * ```
         */
        set: /**
         * An \@Input property that sets the type of the `IgxSliderComponent`. The slider can be SliderType.SLIDER(default) or SliderType.RANGE.
         * ```typescript
         * sliderType: SliderType = SliderType.RANGE;
         * ```
         * ```html
         * <igx-slider #slider2 [type]="sliderType" [(ngModel)]="rangeValue" [minValue]="0" [maxValue]="100">
         * ```
         * @param {?} type
         * @return {?}
         */
        function (type) {
            this._type = type;
            if (type === SliderType.SLIDER) {
                this.lowerValue = 0;
            }
            if (this.labelsViewEnabled && this.upperValue > this.maxValue) {
                this.upperValue = this.labels.length - 1;
            }
            if (this._hasViewInit) {
                this.updateTrack();
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxSliderComponent.prototype, "labels", {
        /**
         * Enables `labelView`, by accepting a collection of primitive values with more than one element.
         * Each element will be equally spread over the slider and it will serve as a thumb label.
         * Once the property is set, it will precendence over {@link maxValue}, {@link minValue}, {@link step}.
         * This means that the manipulation for those properties won't be allowed.
         */
        get: /**
         * Enables `labelView`, by accepting a collection of primitive values with more than one element.
         * Each element will be equally spread over the slider and it will serve as a thumb label.
         * Once the property is set, it will precendence over {\@link maxValue}, {\@link minValue}, {\@link step}.
         * This means that the manipulation for those properties won't be allowed.
         * @return {?}
         */
        function () {
            return this._labels;
        },
        set: /**
         * @param {?} labels
         * @return {?}
         */
        function (labels) {
            this._labels = labels;
            this._pMax = 1;
            if (this._hasViewInit) {
                this.stepDistance = this.calculateStepDistance();
                this.positionHandlesAndUpdateTrack();
                this.setTickInterval(labels);
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxSliderComponent.prototype, "context", {
        /**
         * Returns the template context corresponding
         * to {@link IgxThumbFromTemplateDirective} and {@link IgxThumbToTemplateDirective} templates.
         *
         * return {
         *  $implicit: {@link value},
         *  labels: {@link labels}
         * }
         * ```
         */
        get: /**
         * Returns the template context corresponding
         * to {\@link IgxThumbFromTemplateDirective} and {\@link IgxThumbToTemplateDirective} templates.
         *
         * return {
         *  $implicit: {\@link value},
         *  labels: {\@link labels}
         * }
         * ```
         * @return {?}
         */
        function () {
            return {
                $implicit: this.value,
                labels: this.labels
            };
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxSliderComponent.prototype, "step", {
        /**
         * Returns the incremental/decremental dragging step of the {@link IgxSliderComponent}.
         * ```typescript
         * @ViewChild("slider2")
         * public slider: IgxSliderComponent;
         * ngAfterViewInit(){
         *     let step = this.slider.step;
         * }
         * ```
         */
        get: /**
         * Returns the incremental/decremental dragging step of the {\@link IgxSliderComponent}.
         * ```typescript
         * \@ViewChild("slider2")
         * public slider: IgxSliderComponent;
         * ngAfterViewInit(){
         *     let step = this.slider.step;
         * }
         * ```
         * @return {?}
         */
        function () {
            return this.labelsViewEnabled ? 1 : this._step;
        },
        /**
         * An @Input property that sets the incremental/decremental step of the value when dragging the thumb.
         * The default step is 1, and step should not be less or equal than 0.
         * ```html
         * <igx-slider #slider [(ngModel)]="task.percentCompleted" [step]="5">
         * ```
         */
        set: /**
         * An \@Input property that sets the incremental/decremental step of the value when dragging the thumb.
         * The default step is 1, and step should not be less or equal than 0.
         * ```html
         * <igx-slider #slider [(ngModel)]="task.percentCompleted" [step]="5">
         * ```
         * @param {?} step
         * @return {?}
         */
        function (step) {
            this._step = step;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxSliderComponent.prototype, "disabled", {
        /**
         * Returns if the {@link IgxSliderComponent} is disabled.
         * ```typescript
         * @ViewChild("slider2")
         * public slider: IgxSliderComponent;
         * ngAfterViewInit(){
         *     let isDisabled = this.slider.disabled;
         * }
         * ```
         */
        get: /**
         * Returns if the {\@link IgxSliderComponent} is disabled.
         * ```typescript
         * \@ViewChild("slider2")
         * public slider: IgxSliderComponent;
         * ngAfterViewInit(){
         *     let isDisabled = this.slider.disabled;
         * }
         * ```
         * @return {?}
         */
        function () {
            return this._disabled;
        },
        /**
         *An @Input property that disables or enables UI interaction.
         *```html
         *<igx-slider #slider [disabled]="'true'" [(ngModel)]="task.percentCompleted" [step]="5" [lowerBound]="20">
         *```
         */
        set: /**
         * An \@Input property that disables or enables UI interaction.
         * ```html
         * <igx-slider #slider [disabled]="'true'" [(ngModel)]="task.percentCompleted" [step]="5" [lowerBound]="20">
         * ```
         * @param {?} disable
         * @return {?}
         */
        function (disable) {
            this._disabled = disable;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxSliderComponent.prototype, "continuous", {
        /**
         * Returns if the {@link IgxSliderComponent} is set as continuous.
         * ```typescript
         * @ViewChild("slider2")
         * public slider: IgxSliderComponent;
         * ngAfterViewInit(){
         *     let continuous = this.slider.continuous;
         * }
         * ```
         */
        get: /**
         * Returns if the {\@link IgxSliderComponent} is set as continuous.
         * ```typescript
         * \@ViewChild("slider2")
         * public slider: IgxSliderComponent;
         * ngAfterViewInit(){
         *     let continuous = this.slider.continuous;
         * }
         * ```
         * @return {?}
         */
        function () {
            return this._countinuous;
        },
        /**
         * An @Input property that marks the {@link IgxSliderComponent} as continuous.
         * By default is considered that the {@link IgxSliderComponent} is discrete.
         * Discrete {@link IgxSliderComponent} does not have ticks and does not shows bubble labels for values.
         * ```html
         * <igx-slider #slider [continuous]="'true'" [(ngModel)]="task.percentCompleted" [step]="5" [lowerBound]="20">
         * ```
         */
        set: /**
         * An \@Input property that marks the {\@link IgxSliderComponent} as continuous.
         * By default is considered that the {\@link IgxSliderComponent} is discrete.
         * Discrete {\@link IgxSliderComponent} does not have ticks and does not shows bubble labels for values.
         * ```html
         * <igx-slider #slider [continuous]="'true'" [(ngModel)]="task.percentCompleted" [step]="5" [lowerBound]="20">
         * ```
         * @param {?} continuous
         * @return {?}
         */
        function (continuous) {
            if (this.labelsViewEnabled) {
                return;
            }
            this._countinuous = continuous;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxSliderComponent.prototype, "isContinuous", {
        /**
         * Returns if the {@link IgxSliderComponent} is set as continuous.
         * ```typescript
         * @ViewChild("slider2")
         * public slider: IgxSliderComponent;
         * ngAfterViewInit(){
         *     let continuous = this.slider.continuous;
         * }
         * ```
         */
        get: /**
         * Returns if the {\@link IgxSliderComponent} is set as continuous.
         * ```typescript
         * \@ViewChild("slider2")
         * public slider: IgxSliderComponent;
         * ngAfterViewInit(){
         *     let continuous = this.slider.continuous;
         * }
         * ```
         * @return {?}
         */
        function () {
            return this.continuous;
        },
        /**
         * @hidden
         * @internal
         */
        set: /**
         * @hidden
         * \@internal
         * @param {?} continuous
         * @return {?}
         */
        function (continuous) {
            this.continuous = continuous;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxSliderComponent.prototype, "maxValue", {
        /**
         * Returns the maximum value for the {@link IgxSliderComponent}.
         * ```typescript
         *@ViewChild("slider")
         *public slider: IgxSliderComponent;
         *ngAfterViewInit(){
         *    let sliderMax = this.slider.maxValue;
         *}
         * ```
         */
        get: /**
         * Returns the maximum value for the {\@link IgxSliderComponent}.
         * ```typescript
         * \@ViewChild("slider")
         * public slider: IgxSliderComponent;
         * ngAfterViewInit(){
         *    let sliderMax = this.slider.maxValue;
         * }
         * ```
         * @return {?}
         */
        function () {
            return this.labelsViewEnabled ?
                this.labels.length - 1 :
                this._maxValue;
        },
        /**
         * Sets the maximal value for the `IgxSliderComponent`.
         * The default maximum value is 100.
         * ```html
         * <igx-slider [type]="sliderType" [minValue]="56" [maxValue]="256">
         * ```
         */
        set: /**
         * Sets the maximal value for the `IgxSliderComponent`.
         * The default maximum value is 100.
         * ```html
         * <igx-slider [type]="sliderType" [minValue]="56" [maxValue]="256">
         * ```
         * @param {?} value
         * @return {?}
         */
        function (value) {
            if (value <= this._minValue) {
                this._maxValue = this._minValue + 1;
            }
            else {
                this._maxValue = value;
            }
            if (value < this.lowerBound) {
                this.updateLowerBoundAndMinTravelZone();
                this.upperBound = value;
            }
            // refresh max travel zone limits.
            this._pMax = 1;
            // recalculate step distance.
            this.stepDistance = this.calculateStepDistance();
            this.positionHandlesAndUpdateTrack();
            this.setTickInterval(null);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxSliderComponent.prototype, "minValue", {
        /**
         *Returns the minimal value of the `IgxSliderComponent`.
         *```typescript
         *@ViewChild("slider2")
         *public slider: IgxSliderComponent;
         *ngAfterViewInit(){
         *    let sliderMin = this.slider.minValue;
         *}
         *```
         */
        get: /**
         * Returns the minimal value of the `IgxSliderComponent`.
         * ```typescript
         * \@ViewChild("slider2")
         * public slider: IgxSliderComponent;
         * ngAfterViewInit(){
         *    let sliderMin = this.slider.minValue;
         * }
         * ```
         * @return {?}
         */
        function () {
            if (this.labelsViewEnabled) {
                return 0;
            }
            return this._minValue;
        },
        /**
         * Sets the minimal value for the `IgxSliderComponent`.
         * The default minimal value is 0.
         * ```html
         * <igx-slider [type]="sliderType" [minValue]="56" [maxValue]="100">
         * ```
         */
        set: /**
         * Sets the minimal value for the `IgxSliderComponent`.
         * The default minimal value is 0.
         * ```html
         * <igx-slider [type]="sliderType" [minValue]="56" [maxValue]="100">
         * ```
         * @param {?} value
         * @return {?}
         */
        function (value) {
            if (value >= this.maxValue) {
                this._minValue = this.maxValue - 1;
            }
            else {
                this._minValue = value;
            }
            if (value > this.upperBound) {
                this.updateUpperBoundAndMaxTravelZone();
                this.lowerBound = value;
            }
            // Refresh min travel zone limit.
            this._pMin = 0;
            // Recalculate step distance.
            this.stepDistance = this.calculateStepDistance();
            this.positionHandlesAndUpdateTrack();
            this.setTickInterval(null);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxSliderComponent.prototype, "lowerBound", {
        /**
         * Returns the lower boundary of the `IgxSliderComponent`.
         *```typescript
         *@ViewChild("slider")
         *public slider: IgxSliderComponent;
         *ngAfterViewInit(){
         *    let sliderLowBound = this.slider.lowerBound;
         *}
         *```
         */
        get: /**
         * Returns the lower boundary of the `IgxSliderComponent`.
         * ```typescript
         * \@ViewChild("slider")
         * public slider: IgxSliderComponent;
         * ngAfterViewInit(){
         *    let sliderLowBound = this.slider.lowerBound;
         * }
         * ```
         * @return {?}
         */
        function () {
            if (!Number.isNaN(this._lowerBound) && this._lowerBound !== undefined) {
                return this.valueInRange(this._lowerBound, this.minValue, this.maxValue);
            }
            return this.minValue;
        },
        /**
         * Sets the lower boundary of the `IgxSliderComponent`.
         * If not set is the same as min value.
         * ```html
         * <igx-slider [step]="5" [lowerBound]="20">
         * ```
         */
        set: /**
         * Sets the lower boundary of the `IgxSliderComponent`.
         * If not set is the same as min value.
         * ```html
         * <igx-slider [step]="5" [lowerBound]="20">
         * ```
         * @param {?} value
         * @return {?}
         */
        function (value) {
            if (value >= this.upperBound || (this.labelsViewEnabled && value < 0)) {
                return;
            }
            this._lowerBound = this.valueInRange(value, this.minValue, this.maxValue);
            // Refresh time travel zone.
            this._pMin = this.valueToFraction(this._lowerBound) || 0;
            this.positionHandlesAndUpdateTrack();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxSliderComponent.prototype, "upperBound", {
        /**
         * Returns the upper boundary of the `IgxSliderComponent`.
         * ```typescript
         *@ViewChild("slider")
         *public slider: IgxSliderComponent;
         *ngAfterViewInit(){
         *    let sliderUpBound = this.slider.upperBound;
         *}
         * ```
         */
        get: /**
         * Returns the upper boundary of the `IgxSliderComponent`.
         * ```typescript
         * \@ViewChild("slider")
         * public slider: IgxSliderComponent;
         * ngAfterViewInit(){
         *    let sliderUpBound = this.slider.upperBound;
         * }
         * ```
         * @return {?}
         */
        function () {
            if (!Number.isNaN(this._upperBound) && this._upperBound !== undefined) {
                return this.valueInRange(this._upperBound, this.minValue, this.maxValue);
            }
            return this.maxValue;
        },
        /**
         * Sets the upper boundary of the `IgxSliderComponent`.
         * If not set is the same as max value.
         * ```html
         * <igx-slider [step]="5" [upperBound]="20">
         * ```
         */
        set: /**
         * Sets the upper boundary of the `IgxSliderComponent`.
         * If not set is the same as max value.
         * ```html
         * <igx-slider [step]="5" [upperBound]="20">
         * ```
         * @param {?} value
         * @return {?}
         */
        function (value) {
            if (value <= this.lowerBound || (this.labelsViewEnabled && value > this.labels.length - 1)) {
                return;
            }
            this._upperBound = this.valueInRange(value, this.minValue, this.maxValue);
            // Refresh time travel zone.
            this._pMax = this.valueToFraction(this._upperBound) || 1;
            this.positionHandlesAndUpdateTrack();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxSliderComponent.prototype, "value", {
        /**
         * Returns the slider value. If the slider is of type {@link SliderType.SLIDER} the returned value is number.
         * If the slider type is {@link SliderType.RANGE} the returned value represents an object of {@link lowerValue} and {@link upperValue}.
         *```typescript
         *@ViewChild("slider2")
         *public slider: IgxSliderComponent;
         *public sliderValue(event){
         *    let sliderVal = this.slider.value;
         *}
         *```
         */
        get: /**
         * Returns the slider value. If the slider is of type {\@link SliderType.SLIDER} the returned value is number.
         * If the slider type is {\@link SliderType.RANGE} the returned value represents an object of {\@link lowerValue} and {\@link upperValue}.
         * ```typescript
         * \@ViewChild("slider2")
         * public slider: IgxSliderComponent;
         * public sliderValue(event){
         *    let sliderVal = this.slider.value;
         * }
         * ```
         * @return {?}
         */
        function () {
            if (this.isRange) {
                return {
                    lower: this.valueInRange(this.lowerValue, this.lowerBound, this.upperBound),
                    upper: this.valueInRange(this.upperValue, this.lowerBound, this.upperBound)
                };
            }
            else {
                return this.valueInRange(this.upperValue, this.lowerBound, this.upperBound);
            }
        },
        /**
         * Sets the slider value.
         * If the slider is of type {@link SliderType.SLIDER} the argument is number. By default the {@link value} gets the {@link lowerBound}.
         * If the slider type is {@link SliderType.RANGE} the argument
         * represents an object of {@link lowerValue} and {@link upperValue} properties.
         * By default the object is associated with the {@link lowerBound} and {@link upperBound} property values.
         * ```typescript
         *rangeValue = {
         *   lower: 30,
         *   upper: 60
         *};
         * ```
         * ```html
         * <igx-slider [type]="sliderType" [(ngModel)]="rangeValue" [minValue]="56" [maxValue]="256">
         * ```
         */
        set: /**
         * Sets the slider value.
         * If the slider is of type {\@link SliderType.SLIDER} the argument is number. By default the {\@link value} gets the {\@link lowerBound}.
         * If the slider type is {\@link SliderType.RANGE} the argument
         * represents an object of {\@link lowerValue} and {\@link upperValue} properties.
         * By default the object is associated with the {\@link lowerBound} and {\@link upperBound} property values.
         * ```typescript
         * rangeValue = {
         *   lower: 30,
         *   upper: 60
         * };
         * ```
         * ```html
         * <igx-slider [type]="sliderType" [(ngModel)]="rangeValue" [minValue]="56" [maxValue]="256">
         * ```
         * @param {?} value
         * @return {?}
         */
        function (value) {
            if (!this.isRange) {
                this.upperValue = (/** @type {?} */ (value));
            }
            else {
                value = this.validateInitialValue((/** @type {?} */ (value)));
                this.upperValue = ((/** @type {?} */ (value))).upper;
                this.lowerValue = ((/** @type {?} */ (value))).lower;
            }
            this._onChangeCallback(this.value);
            if (this._hasViewInit) {
                this.positionHandlesAndUpdateTrack();
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @hidden
     */
    /**
     * @hidden
     * @param {?} $event
     * @return {?}
     */
    IgxSliderComponent.prototype.onPointerDown = /**
     * @hidden
     * @param {?} $event
     * @return {?}
     */
    function ($event) {
        this.findClosestThumb($event);
        if (!this.thumbTo.isActive && this.thumbFrom === undefined) {
            return;
        }
        this.showThumbLabels();
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @return {?}
     */
    IgxSliderComponent.prototype.onPointerUp = /**
     * @hidden
     * @return {?}
     */
    function () {
        if (!this.thumbTo.isActive && this.thumbFrom === undefined) {
            return;
        }
        this.hideThumbLabels();
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @return {?}
     */
    IgxSliderComponent.prototype.onFocus = /**
     * @hidden
     * @return {?}
     */
    function () {
        this.toggleThumbLabels();
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @return {?}
     */
    IgxSliderComponent.prototype.onBlur = /**
     * @hidden
     * @return {?}
     */
    function () {
        this.hideThumbLabels();
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @param {?} $event
     * @return {?}
     */
    IgxSliderComponent.prototype.onPanListener = /**
     * @hidden
     * @param {?} $event
     * @return {?}
     */
    function ($event) {
        this.update($event.srcEvent.clientX);
    };
    /**
     * @return {?}
     */
    IgxSliderComponent.prototype.onPanStart = /**
     * @return {?}
     */
    function () {
        this.showThumbLabels();
    };
    /**
     * @return {?}
     */
    IgxSliderComponent.prototype.onPanEnd = /**
     * @return {?}
     */
    function () {
        this.hideThumbLabels();
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @param {?} $event
     * @return {?}
     */
    IgxSliderComponent.prototype.onTapListener = /**
     * @hidden
     * @param {?} $event
     * @return {?}
     */
    function ($event) {
        this.onTap($event);
    };
    Object.defineProperty(IgxSliderComponent.prototype, "isRange", {
        /**
         *Returns whether the `IgxSliderComponent` type is RANGE.
         *```typescript
         *@ViewChild("slider")
         *public slider: IgxSliderComponent;
         *ngAfterViewInit(){
         *    let sliderRange = this.slider.isRange;
         *}
         * ```
         */
        get: /**
         * Returns whether the `IgxSliderComponent` type is RANGE.
         * ```typescript
         * \@ViewChild("slider")
         * public slider: IgxSliderComponent;
         * ngAfterViewInit(){
         *    let sliderRange = this.slider.isRange;
         * }
         * ```
         * @return {?}
         */
        function () {
            return this.type === SliderType.RANGE;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxSliderComponent.prototype, "lowerValue", {
        /**
         * Returns the lower value of the `IgxSliderComponent`.
         * ```typescript
         * @ViewChild("slider")
         * public slider: IgxSliderComponent;
         * public lowValue(event){
         *    let sliderLowValue = this.slider.lowerValue;
         *}
         *```
         */
        get: /**
         * Returns the lower value of the `IgxSliderComponent`.
         * ```typescript
         * \@ViewChild("slider")
         * public slider: IgxSliderComponent;
         * public lowValue(event){
         *    let sliderLowValue = this.slider.lowerValue;
         * }
         * ```
         * @return {?}
         */
        function () {
            if (!Number.isNaN(this._lowerValue) && this._lowerValue !== undefined && this._lowerValue >= this.lowerBound) {
                return this._lowerValue;
            }
            return this.lowerBound;
        },
        /**
         *Sets the lower value of the `IgxSliderComponent`.
         *```typescript
         *@ViewChild("slider2")
         *public slider: IgxSliderComponent;
         *public lowValue(event){
         *    this.slider.lowerValue = 120;
         *}
         *```
         */
        set: /**
         * Sets the lower value of the `IgxSliderComponent`.
         * ```typescript
         * \@ViewChild("slider2")
         * public slider: IgxSliderComponent;
         * public lowValue(event){
         *    this.slider.lowerValue = 120;
         * }
         * ```
         * @param {?} value
         * @return {?}
         */
        function (value) {
            value = this.valueInRange(value, this.lowerBound, this.upperBound);
            this._lowerValue = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxSliderComponent.prototype, "upperValue", {
        /**
         *Returns the upper value of the `IgxSliderComponent`.
         *```typescript
         *@ViewChild("slider2")
         *public slider: IgxSliderComponent;
         *public upperValue(event){
         *    let upperValue = this.slider.upperValue;
         *}
         *```
         */
        get: /**
         * Returns the upper value of the `IgxSliderComponent`.
         * ```typescript
         * \@ViewChild("slider2")
         * public slider: IgxSliderComponent;
         * public upperValue(event){
         *    let upperValue = this.slider.upperValue;
         * }
         * ```
         * @return {?}
         */
        function () {
            if (!Number.isNaN(this._upperValue) && this._upperValue !== undefined && this._upperValue <= this.upperBound) {
                return this._upperValue;
            }
            return this.upperBound;
        },
        /**
         *Sets the upper value of the `IgxSliderComponent`.
         *```typescript
         *@ViewChild("slider2")
         *public slider: IgxSliderComponent;
         *public upperValue(event){
         *    this.slider.upperValue = 120;
         *}
         *```
         */
        set: /**
         * Sets the upper value of the `IgxSliderComponent`.
         * ```typescript
         * \@ViewChild("slider2")
         * public slider: IgxSliderComponent;
         * public upperValue(event){
         *    this.slider.upperValue = 120;
         * }
         * ```
         * @param {?} value
         * @return {?}
         */
        function (value) {
            value = this.valueInRange(value, this.lowerBound, this.upperBound);
            this._upperValue = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxSliderComponent.prototype, "lowerLabel", {
        /**
         * Returns the value corresponding the lower label.
         *```typescript
         * @ViewChild("slider")
         * public slider: IgxSliderComponent;
         * let label = this.slider.lowerLabel;
         *```
         */
        get: /**
         * Returns the value corresponding the lower label.
         * ```typescript
         * \@ViewChild("slider")
         * public slider: IgxSliderComponent;
         * let label = this.slider.lowerLabel;
         * ```
         * @return {?}
         */
        function () {
            return this.labelsViewEnabled ?
                this.labels[this.lowerValue] :
                this.lowerValue;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxSliderComponent.prototype, "upperLabel", {
        /**
         * Returns the value corresponding the upper label.
         *```typescript
         * @ViewChild("slider")
         * public slider: IgxSliderComponent;
         * let label = this.slider.upperLabel;
         *```
         */
        get: /**
         * Returns the value corresponding the upper label.
         * ```typescript
         * \@ViewChild("slider")
         * public slider: IgxSliderComponent;
         * let label = this.slider.upperLabel;
         * ```
         * @return {?}
         */
        function () {
            return this.labelsViewEnabled ?
                this.labels[this.upperValue] :
                this.upperValue;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxSliderComponent.prototype, "labelsViewEnabled", {
        /**
         * Returns if label view is enabled.
         * If the {@link labels} is set, the view is automatically activated.
         *```typescript
         * @ViewChild("slider")
         * public slider: IgxSliderComponent;
         * let labelView = this.slider.labelsViewEnabled;
         *```
         */
        get: /**
         * Returns if label view is enabled.
         * If the {\@link labels} is set, the view is automatically activated.
         * ```typescript
         * \@ViewChild("slider")
         * public slider: IgxSliderComponent;
         * let labelView = this.slider.labelsViewEnabled;
         * ```
         * @return {?}
         */
        function () {
            return !!(this.labels && this.labels.length > 1);
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @hidden
     */
    /**
     * @hidden
     * @return {?}
     */
    IgxSliderComponent.prototype.ngOnInit = /**
     * @hidden
     * @return {?}
     */
    function () {
        this.sliderSetup();
        // Set track travel zone
        this._pMin = this.valueToFraction(this.lowerBound) || 0;
        this._pMax = this.valueToFraction(this.upperBound) || 1;
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @return {?}
     */
    IgxSliderComponent.prototype.ngAfterViewInit = /**
     * @hidden
     * @return {?}
     */
    function () {
        var _this = this;
        this._hasViewInit = true;
        this.positionHandlesAndUpdateTrack();
        this.setTickInterval(this.labels);
        this.subscribeTo(this.thumbFrom, this.thumbChanged.bind(this));
        this.subscribeTo(this.thumbTo, this.thumbChanged.bind(this));
        this.thumbs.changes.pipe(takeUntil(this._destroy$)).subscribe(function (change) {
            /** @type {?} */
            var t = change.find(function (thumb) { return thumb.type === SliderHandle.FROM; });
            _this.positionHandle(t, _this.lowerValue);
            _this.subscribeTo(t, _this.thumbChanged.bind(_this));
        });
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @return {?}
     */
    IgxSliderComponent.prototype.ngAfterContentInit = /**
     * @hidden
     * @return {?}
     */
    function () {
        // Calculates the distance between every step in pixels.
        this.stepDistance = this.calculateStepDistance();
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @return {?}
     */
    IgxSliderComponent.prototype.ngOnDestroy = /**
     * @hidden
     * @return {?}
     */
    function () {
        this._destroy$.next(true);
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @param {?} value
     * @return {?}
     */
    IgxSliderComponent.prototype.writeValue = /**
     * @hidden
     * @param {?} value
     * @return {?}
     */
    function (value) {
        if (!value) {
            return;
        }
        this.value = value;
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @param {?} fn
     * @return {?}
     */
    IgxSliderComponent.prototype.registerOnChange = /**
     * @hidden
     * @param {?} fn
     * @return {?}
     */
    function (fn) {
        this._onChangeCallback = fn;
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @param {?} fn
     * @return {?}
     */
    IgxSliderComponent.prototype.registerOnTouched = /**
     * @hidden
     * @param {?} fn
     * @return {?}
     */
    function (fn) {
        this._onTouchedCallback = fn;
    };
    /** @hidden */
    /**
     * @hidden
     * @return {?}
     */
    IgxSliderComponent.prototype.getEditElement = /**
     * @hidden
     * @return {?}
     */
    function () {
        return this.isRange ? this.thumbFrom.nativeElement : this.thumbTo.nativeElement;
    };
    /**
     *
     * @hidden
     */
    /**
     *
     * @hidden
     * @param {?} $event
     * @return {?}
     */
    IgxSliderComponent.prototype.onTap = /**
     *
     * @hidden
     * @param {?} $event
     * @return {?}
     */
    function ($event) {
        this.update($event.srcEvent.clientX);
    };
    /**
     *
     * @hidden
     */
    /**
     *
     * @hidden
     * @param {?} mouseX
     * @return {?}
     */
    IgxSliderComponent.prototype.update = /**
     *
     * @hidden
     * @param {?} mouseX
     * @return {?}
     */
    function (mouseX) {
        if (this.disabled) {
            return;
        }
        // Update To/From Values
        this.onPan.next(mouseX);
        // Finally do positionHandlesAndUpdateTrack the DOM
        // based on data values
        this.positionHandlesAndUpdateTrack();
        this._onTouchedCallback();
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @param {?} value
     * @param {?} thumbType
     * @return {?}
     */
    IgxSliderComponent.prototype.thumbChanged = /**
     * @hidden
     * @param {?} value
     * @param {?} thumbType
     * @return {?}
     */
    function (value, thumbType) {
        /** @type {?} */
        var oldValue = this.value;
        /** @type {?} */
        var newVal;
        if (this.isRange) {
            if (thumbType === SliderHandle.FROM) {
                newVal = {
                    lower: ((/** @type {?} */ (this.value))).lower + value,
                    upper: ((/** @type {?} */ (this.value))).upper
                };
            }
            else {
                newVal = {
                    lower: ((/** @type {?} */ (this.value))).lower,
                    upper: ((/** @type {?} */ (this.value))).upper + value
                };
            }
            // Swap the thumbs if a collision appears.
            if (newVal.lower >= newVal.upper) {
                this.value = this.swapThumb(newVal);
            }
            else {
                this.value = newVal;
            }
        }
        else {
            this.value = (/** @type {?} */ (this.value)) + value;
        }
        if (this.hasValueChanged(oldValue)) {
            this.emitValueChanged(oldValue);
        }
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @return {?}
     */
    IgxSliderComponent.prototype.onThumbChange = /**
     * @hidden
     * @return {?}
     */
    function () {
        this.toggleThumbLabels();
    };
    /**
     * @private
     * @param {?} value
     * @return {?}
     */
    IgxSliderComponent.prototype.swapThumb = /**
     * @private
     * @param {?} value
     * @return {?}
     */
    function (value) {
        if (this.thumbFrom.isActive) {
            value.upper = this.upperValue;
            value.lower = this.upperValue;
        }
        else {
            value.upper = this.lowerValue;
            value.lower = this.lowerValue;
        }
        this.toggleThumb();
        return value;
    };
    /**
     * @private
     * @param {?} event
     * @return {?}
     */
    IgxSliderComponent.prototype.findClosestThumb = /**
     * @private
     * @param {?} event
     * @return {?}
     */
    function (event) {
        if (this.isRange) {
            this.closestHandle(event.clientX);
        }
        else {
            this.thumbTo.nativeElement.focus();
        }
        this.update(event.clientX);
        event.preventDefault();
    };
    /**
     * @private
     * @return {?}
     */
    IgxSliderComponent.prototype.updateLowerBoundAndMinTravelZone = /**
     * @private
     * @return {?}
     */
    function () {
        this.lowerBound = this.minValue;
        this._pMin = 0;
    };
    /**
     * @private
     * @return {?}
     */
    IgxSliderComponent.prototype.updateUpperBoundAndMaxTravelZone = /**
     * @private
     * @return {?}
     */
    function () {
        this.upperBound = this.maxValue;
        this._pMax = 1;
    };
    /**
     * @private
     * @return {?}
     */
    IgxSliderComponent.prototype.sliderSetup = /**
     * @private
     * @return {?}
     */
    function () {
        /**
         * if {@link SliderType.SLIDER} than the initial value shold be the lowest one.
         */
        if (!this.isRange && this.value === this.upperBound) {
            this.value = this.lowerBound;
        }
    };
    /**
     * @private
     * @return {?}
     */
    IgxSliderComponent.prototype.calculateStepDistance = /**
     * @private
     * @return {?}
     */
    function () {
        return this._el.nativeElement.getBoundingClientRect().width / (this.maxValue - this.minValue) * this.step;
    };
    /**
     * @private
     * @return {?}
     */
    IgxSliderComponent.prototype.toggleThumb = /**
     * @private
     * @return {?}
     */
    function () {
        return this.thumbFrom.isActive ?
            this.thumbTo.nativeElement.focus() :
            this.thumbFrom.nativeElement.focus();
    };
    /**
     * @private
     * @param {?} value
     * @param {?=} min
     * @param {?=} max
     * @return {?}
     */
    IgxSliderComponent.prototype.valueInRange = /**
     * @private
     * @param {?} value
     * @param {?=} min
     * @param {?=} max
     * @return {?}
     */
    function (value, min, max) {
        if (min === void 0) { min = 0; }
        if (max === void 0) { max = 100; }
        return Math.max(Math.min(value, max), min);
    };
    /**
     * @private
     * @param {?} color
     * @param {?} interval
     * @return {?}
     */
    IgxSliderComponent.prototype.generateTickMarks = /**
     * @private
     * @param {?} color
     * @param {?} interval
     * @return {?}
     */
    function (color, interval) {
        return interval !== null ? "repeating-linear-gradient(\n            " + 'to left' + ",\n            " + color + ",\n            " + color + " 1.5px,\n            transparent 1.5px,\n            transparent " + interval + "%\n        ), repeating-linear-gradient(\n            " + 'to right' + ",\n            " + color + ",\n            " + color + " 1.5px,\n            transparent 1.5px,\n            transparent " + interval + "%\n        )" : interval;
    };
    /**
     * @private
     * @param {?} handle
     * @param {?} position
     * @return {?}
     */
    IgxSliderComponent.prototype.positionHandle = /**
     * @private
     * @param {?} handle
     * @param {?} position
     * @return {?}
     */
    function (handle, position) {
        if (!handle) {
            return;
        }
        handle.nativeElement.style.left = this.valueToFraction(position) * 100 + "%";
    };
    /**
     * @private
     * @return {?}
     */
    IgxSliderComponent.prototype.positionHandlesAndUpdateTrack = /**
     * @private
     * @return {?}
     */
    function () {
        if (!this.isRange) {
            this.positionHandle(this.thumbTo, (/** @type {?} */ (this.value)));
        }
        else {
            this.positionHandle(this.thumbTo, ((/** @type {?} */ (this.value))).upper);
            this.positionHandle(this.thumbFrom, ((/** @type {?} */ (this.value))).lower);
        }
        this.updateTrack();
    };
    /**
     * @private
     * @param {?} mouseX
     * @return {?}
     */
    IgxSliderComponent.prototype.closestHandle = /**
     * @private
     * @param {?} mouseX
     * @return {?}
     */
    function (mouseX) {
        /** @type {?} */
        var fromOffset = this.thumbFrom.nativeElement.offsetLeft + this.thumbFrom.nativeElement.offsetWidth / 2;
        /** @type {?} */
        var toOffset = this.thumbTo.nativeElement.offsetLeft + this.thumbTo.nativeElement.offsetWidth / 2;
        /** @type {?} */
        var xPointer = mouseX - this._el.nativeElement.getBoundingClientRect().left;
        /** @type {?} */
        var match = this.closestTo(xPointer, [fromOffset, toOffset]);
        if (match === fromOffset) {
            this.thumbFrom.nativeElement.focus();
        }
        else if (match === toOffset) {
            this.thumbTo.nativeElement.focus();
        }
    };
    /**
     * @private
     * @param {?} labels
     * @return {?}
     */
    IgxSliderComponent.prototype.setTickInterval = /**
     * @private
     * @param {?} labels
     * @return {?}
     */
    function (labels) {
        if (this.continuous) {
            return;
        }
        /** @type {?} */
        var interval;
        /** @type {?} */
        var trackProgress = 100;
        if (this.labelsViewEnabled) {
            // Calc ticks depending on the labels length;
            interval = ((trackProgress / (this.labels.length - 1) * 10)) / 10;
        }
        else {
            /** @type {?} */
            var trackRange = this.maxValue - this.minValue;
            interval = this.step > 1 ?
                (trackProgress / ((trackRange / this.step)) * 10) / 10
                : null;
        }
        this.renderer.setStyle(this.ticks.nativeElement, 'background', this.generateTickMarks('white', interval));
    };
    /**
     * @private
     * @return {?}
     */
    IgxSliderComponent.prototype.showThumbLabels = /**
     * @private
     * @return {?}
     */
    function () {
        if (this.disabled) {
            return;
        }
        this.thumbTo.showThumbLabel();
        if (this.thumbFrom) {
            this.thumbFrom.showThumbLabel();
        }
    };
    /**
     * @private
     * @return {?}
     */
    IgxSliderComponent.prototype.hideThumbLabels = /**
     * @private
     * @return {?}
     */
    function () {
        if (this.disabled) {
            return;
        }
        this.thumbTo.hideThumbLabel();
        if (this.thumbFrom) {
            this.thumbFrom.hideThumbLabel();
        }
    };
    /**
     * @private
     * @return {?}
     */
    IgxSliderComponent.prototype.toggleThumbLabels = /**
     * @private
     * @return {?}
     */
    function () {
        this.showThumbLabels();
        this.hideThumbLabels();
    };
    /**
     * @private
     * @param {?} goal
     * @param {?} positions
     * @return {?}
     */
    IgxSliderComponent.prototype.closestTo = /**
     * @private
     * @param {?} goal
     * @param {?} positions
     * @return {?}
     */
    function (goal, positions) {
        return positions.reduce(function (previous, current) {
            return (Math.abs(goal - current) < Math.abs(goal - previous) ? current : previous);
        });
    };
    /**
     * @private
     * @param {?} value
     * @param {?=} pMin
     * @param {?=} pMax
     * @return {?}
     */
    IgxSliderComponent.prototype.valueToFraction = /**
     * @private
     * @param {?} value
     * @param {?=} pMin
     * @param {?=} pMax
     * @return {?}
     */
    function (value, pMin, pMax) {
        if (pMin === void 0) { pMin = this._pMin; }
        if (pMax === void 0) { pMax = this._pMax; }
        return this.valueInRange((value - this.minValue) / (this.maxValue - this.minValue), pMin, pMax);
    };
    /**
     * @private
     * @return {?}
     */
    IgxSliderComponent.prototype.updateTrack = /**
     * @private
     * @return {?}
     */
    function () {
        /** @type {?} */
        var fromPosition = this.valueToFraction(this.lowerValue);
        /** @type {?} */
        var toPosition = this.valueToFraction(this.upperValue);
        /** @type {?} */
        var positionGap = toPosition - fromPosition;
        /** @type {?} */
        var trackLeftIndention = fromPosition;
        if (this.isRange) {
            if (positionGap) {
                trackLeftIndention = Math.round((1 / positionGap * fromPosition) * 100);
            }
            this.renderer.setStyle(this.track.nativeElement, 'transform', "scaleX(" + positionGap + ") translateX(" + trackLeftIndention + "%)");
        }
        else {
            this.renderer.setStyle(this.track.nativeElement, 'transform', "scaleX(" + toPosition + ")");
        }
    };
    /**
     * @private
     * @param {?} value
     * @return {?}
     */
    IgxSliderComponent.prototype.validateInitialValue = /**
     * @private
     * @param {?} value
     * @return {?}
     */
    function (value) {
        if (value.lower < this.lowerBound && value.upper < this.lowerBound) {
            value.upper = this.lowerBound;
            value.lower = this.lowerBound;
        }
        if (value.lower > this.upperBound && value.upper > this.upperBound) {
            value.upper = this.upperBound;
            value.lower = this.upperBound;
        }
        if (value.upper < value.lower) {
            value.upper = this.upperValue;
            value.lower = this.lowerValue;
        }
        return value;
    };
    /**
     * @private
     * @param {?} thumb
     * @param {?} callback
     * @return {?}
     */
    IgxSliderComponent.prototype.subscribeTo = /**
     * @private
     * @param {?} thumb
     * @param {?} callback
     * @return {?}
     */
    function (thumb, callback) {
        if (!thumb) {
            return;
        }
        thumb.onThumbValueChange
            .pipe(takeUntil(this.unsubscriber(thumb)))
            .subscribe(function (value) { return callback(value, thumb.type); });
    };
    /**
     * @private
     * @param {?} thumb
     * @return {?}
     */
    IgxSliderComponent.prototype.unsubscriber = /**
     * @private
     * @param {?} thumb
     * @return {?}
     */
    function (thumb) {
        return merge(this._destroy$, thumb.destroy);
    };
    /**
     * @private
     * @param {?} oldValue
     * @return {?}
     */
    IgxSliderComponent.prototype.hasValueChanged = /**
     * @private
     * @param {?} oldValue
     * @return {?}
     */
    function (oldValue) {
        /** @type {?} */
        var isSliderWithDifferentValue = !this.isRange && oldValue !== this.value;
        /** @type {?} */
        var isRangeWithOneDifferentValue = this.isRange &&
            (((/** @type {?} */ (oldValue))).lower !== ((/** @type {?} */ (this.value))).lower ||
                ((/** @type {?} */ (oldValue))).upper !== ((/** @type {?} */ (this.value))).upper);
        return isSliderWithDifferentValue || isRangeWithOneDifferentValue;
    };
    /**
     * @private
     * @param {?} oldValue
     * @return {?}
     */
    IgxSliderComponent.prototype.emitValueChanged = /**
     * @private
     * @param {?} oldValue
     * @return {?}
     */
    function (oldValue) {
        this.onValueChange.emit({ oldValue: oldValue, value: this.value });
    };
    IgxSliderComponent.decorators = [
        { type: Component, args: [{
                    providers: [{ provide: NG_VALUE_ACCESSOR, useExisting: IgxSliderComponent, multi: true }],
                    selector: 'igx-slider',
                    template: "<div class=\"igx-slider__track\">\n    <div #track class=\"igx-slider__track-fill\"></div>\n    <div #ticks class=\"igx-slider__track-ticks\"></div>\n</div>\n<div class=\"igx-slider__thumbs\">\n    <igx-thumb *ngIf=\"isRange\"\n        #thumbFrom\n        [type]=\"0\"\n        [value]=\"lowerLabel\"\n        [disabled]=\"disabled\"\n        [continuous]=\"continuous\"\n        [onPan]=\"onPan\"\n        [stepDistance]=\"stepDistance\"\n        [step]=\"step\"\n        [fromHandler]=\"true\"\n        [templateRef]=\"thumbFromTemplateRef\"\n        [context]=\"context\"\n        (onChange)=\"onThumbChange()\"\n        [thumbLabelVisibilityDuration]=\"thumbLabelVisibilityDuration\"></igx-thumb>\n    <igx-thumb\n        #thumbTo\n        [type]=\"1\"\n        [value]=\"upperLabel\"\n        [disabled]=\"disabled\"\n        [continuous]=\"continuous\"\n        [onPan]=\"onPan\"\n        [stepDistance]=\"stepDistance\"\n        [step]=\"step\"\n        [templateRef]=\"thumbToTemplateRef\"\n        [context]=\"context\"\n        (onChange)=\"onThumbChange()\"\n        [thumbLabelVisibilityDuration]=\"thumbLabelVisibilityDuration\"></igx-thumb>\n</div>\n",
                    styles: ["\n        :host {\n            display: block;\n        }\n    "]
                }] }
    ];
    /** @nocollapse */
    IgxSliderComponent.ctorParameters = function () { return [
        { type: Renderer2 },
        { type: ElementRef }
    ]; };
    IgxSliderComponent.propDecorators = {
        track: [{ type: ViewChild, args: ['track',] }],
        ticks: [{ type: ViewChild, args: ['ticks',] }],
        thumbs: [{ type: ViewChildren, args: [IgxSliderThumbComponent,] }],
        thumbFromTemplateRef: [{ type: ContentChild, args: [IgxThumbFromTemplateDirective, { read: TemplateRef },] }],
        thumbToTemplateRef: [{ type: ContentChild, args: [IgxThumbToTemplateDirective, { read: TemplateRef },] }],
        role: [{ type: HostBinding, args: ["attr.role",] }],
        valuemin: [{ type: HostBinding, args: ["attr.aria-valuemin",] }],
        valuemax: [{ type: HostBinding, args: ["attr.aria-valuemax",] }],
        readonly: [{ type: HostBinding, args: ["attr.aria-readonly",] }],
        slierClass: [{ type: HostBinding, args: ['class.igx-slider',] }],
        disabledClass: [{ type: HostBinding, args: ['class.igx-slider--disabled',] }],
        id: [{ type: HostBinding, args: ['attr.id',] }, { type: Input }],
        type: [{ type: Input }],
        thumbLabelVisibilityDuration: [{ type: Input }],
        labels: [{ type: Input }],
        step: [{ type: Input }],
        disabled: [{ type: Input }],
        continuous: [{ type: Input }],
        isContinuous: [{ type: Input }],
        maxValue: [{ type: Input }],
        minValue: [{ type: Input }],
        lowerBound: [{ type: Input }],
        upperBound: [{ type: Input }],
        value: [{ type: Input }],
        onValueChange: [{ type: Output }],
        onPointerDown: [{ type: HostListener, args: ['pointerdown', ['$event'],] }],
        onPointerUp: [{ type: HostListener, args: ['pointerup',] }],
        onFocus: [{ type: HostListener, args: ['focus',] }],
        onBlur: [{ type: HostListener, args: ['blur',] }],
        onPanListener: [{ type: HostListener, args: ['pan', ['$event'],] }],
        onPanStart: [{ type: HostListener, args: ['panstart',] }],
        onPanEnd: [{ type: HostListener, args: ['panend',] }],
        onTapListener: [{ type: HostListener, args: ['tap', ['$event'],] }]
    };
    tslib_1.__decorate([
        DeprecateProperty("IgxSliderComponent `isContinuous` property is deprecated.\nUse `continuous` instead."),
        tslib_1.__metadata("design:type", Boolean),
        tslib_1.__metadata("design:paramtypes", [Boolean])
    ], IgxSliderComponent.prototype, "isContinuous", null);
    return IgxSliderComponent;
}());
export { IgxSliderComponent };
if (false) {
    /**
     * @type {?}
     * @private
     */
    IgxSliderComponent.prototype._pMin;
    /**
     * @type {?}
     * @private
     */
    IgxSliderComponent.prototype._pMax;
    /**
     * @type {?}
     * @private
     */
    IgxSliderComponent.prototype._hasViewInit;
    /**
     * @type {?}
     * @private
     */
    IgxSliderComponent.prototype._minValue;
    /**
     * @type {?}
     * @private
     */
    IgxSliderComponent.prototype._maxValue;
    /**
     * @type {?}
     * @private
     */
    IgxSliderComponent.prototype._lowerBound;
    /**
     * @type {?}
     * @private
     */
    IgxSliderComponent.prototype._upperBound;
    /**
     * @type {?}
     * @private
     */
    IgxSliderComponent.prototype._lowerValue;
    /**
     * @type {?}
     * @private
     */
    IgxSliderComponent.prototype._upperValue;
    /**
     * @type {?}
     * @private
     */
    IgxSliderComponent.prototype._countinuous;
    /**
     * @type {?}
     * @private
     */
    IgxSliderComponent.prototype._disabled;
    /**
     * @type {?}
     * @private
     */
    IgxSliderComponent.prototype._step;
    /**
     * @type {?}
     * @private
     */
    IgxSliderComponent.prototype._labels;
    /**
     * @type {?}
     * @private
     */
    IgxSliderComponent.prototype._type;
    /**
     * @type {?}
     * @private
     */
    IgxSliderComponent.prototype._destroy$;
    /**
     * @type {?}
     * @private
     */
    IgxSliderComponent.prototype._onChangeCallback;
    /**
     * @type {?}
     * @private
     */
    IgxSliderComponent.prototype._onTouchedCallback;
    /**
     * @hidden
     * @type {?}
     * @private
     */
    IgxSliderComponent.prototype.track;
    /**
     * @hidden
     * @type {?}
     * @private
     */
    IgxSliderComponent.prototype.ticks;
    /**
     * @hidden
     * @type {?}
     * @private
     */
    IgxSliderComponent.prototype.thumbs;
    /**
     * @hidden
     * @type {?}
     */
    IgxSliderComponent.prototype.stepDistance;
    /**
     * @hidden
     * @type {?}
     */
    IgxSliderComponent.prototype.onPan;
    /**
     * @hidden
     * @type {?}
     */
    IgxSliderComponent.prototype.thumbFromTemplateRef;
    /**
     * @hidden
     * @type {?}
     */
    IgxSliderComponent.prototype.thumbToTemplateRef;
    /**
     * @hidden
     * @type {?}
     */
    IgxSliderComponent.prototype.role;
    /**
     * @hidden
     * @type {?}
     */
    IgxSliderComponent.prototype.slierClass;
    /**
     * An \@Input property that sets the value of the `id` attribute.
     * If not provided it will be automatically generated.
     * ```html
     * <igx-slider [id]="'igx-slider-32'" [(ngModel)]="task.percentCompleted" [step]="5" [lowerBound]="20">
     * ```
     * @type {?}
     */
    IgxSliderComponent.prototype.id;
    /**
     * An \@Input property that sets the duration visibility of thumbs labels. The default value is 750 milliseconds.
     * ```html
     * <igx-slider #slider [thumbLabelVisibilityDuration]="3000" [(ngModel)]="task.percentCompleted" [step]="5">
     * ```
     * @type {?}
     */
    IgxSliderComponent.prototype.thumbLabelVisibilityDuration;
    /**
     * This event is emitted when user has stopped interacting the thumb and value is changed.
     * ```typescript
     * public change(event){
     *    alert("The value has been changed!");
     * }
     * ```
     * ```html
     * <igx-slider (onValueChange)="change($event)" #slider [(ngModel)]="task.percentCompleted" [step]="5">
     * ```
     * @type {?}
     */
    IgxSliderComponent.prototype.onValueChange;
    /**
     * @type {?}
     * @private
     */
    IgxSliderComponent.prototype.renderer;
    /**
     * @type {?}
     * @private
     */
    IgxSliderComponent.prototype._el;
}
/**
 * @hidden
 */
var IgxSliderModule = /** @class */ (function () {
    function IgxSliderModule() {
    }
    IgxSliderModule.decorators = [
        { type: NgModule, args: [{
                    declarations: [IgxSliderComponent, IgxThumbFromTemplateDirective, IgxThumbToTemplateDirective],
                    exports: [IgxSliderComponent, IgxThumbFromTemplateDirective, IgxThumbToTemplateDirective],
                    imports: [CommonModule, IgxSliderThumbModule]
                },] }
    ];
    return IgxSliderModule;
}());
export { IgxSliderModule };
export { Éµ0 };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2xpZGVyLmNvbXBvbmVudC5qcyIsInNvdXJjZVJvb3QiOiJuZzovL2lnbml0ZXVpLWFuZ3VsYXIvIiwic291cmNlcyI6WyJsaWIvc2xpZGVyL3NsaWRlci5jb21wb25lbnQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQSxPQUFPLEVBQUUsWUFBWSxFQUFFLE1BQU0saUJBQWlCLENBQUM7QUFDL0MsT0FBTyxFQUNZLFNBQVMsRUFBRSxVQUFVLEVBQUUsWUFBWSxFQUNsRCxXQUFXLEVBQUUsS0FBSyxFQUFFLFFBQVEsRUFBVSxNQUFNLEVBQUUsU0FBUyxFQUN2RCxTQUFTLEVBQ1QsU0FBUyxFQUNULFdBQVcsRUFDWCxZQUFZLEVBR1osWUFBWSxFQUNaLFlBQVksRUFDWixTQUFTLEVBQ1osTUFBTSxlQUFlLENBQUM7QUFDdkIsT0FBTyxFQUF3QixpQkFBaUIsRUFBRSxNQUFNLGdCQUFnQixDQUFDO0FBRXpFLE9BQU8sRUFBRSxpQkFBaUIsRUFBRSxNQUFNLDZCQUE2QixDQUFDO0FBQ2hFLE9BQU8sRUFBRSxvQkFBb0IsRUFBRSx1QkFBdUIsRUFBRSxNQUFNLGdDQUFnQyxDQUFDO0FBQy9GLE9BQU8sRUFBRSxPQUFPLEVBQUUsS0FBSyxFQUFVLE1BQU0sTUFBTSxDQUFDO0FBQzlDLE9BQU8sRUFBRSxTQUFTLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQzs7Ozs7Ozs7Ozs7O0FBYTNDO0lBQUE7SUFHNEMsQ0FBQzs7Z0JBSDVDLFNBQVMsU0FBQztvQkFDUCxRQUFRLEVBQUUsc0JBQXNCO2lCQUNuQzs7SUFDMkMsb0NBQUM7Q0FBQSxBQUg3QyxJQUc2QztTQUFoQyw2QkFBNkI7Ozs7Ozs7Ozs7OztBQWExQztJQUFBO0lBRzBDLENBQUM7O2dCQUgxQyxTQUFTLFNBQUM7b0JBQ1AsUUFBUSxFQUFFLG9CQUFvQjtpQkFDakM7O0lBQ3lDLGtDQUFDO0NBQUEsQUFIM0MsSUFHMkM7U0FBOUIsMkJBQTJCOzs7SUFHcEM7O09BRUc7SUFDSCxTQUFNO0lBQ047O09B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Q0FBNkI7Ozs7O0lBQzdCLDBDQUE2Qjs7Ozs7SUFDN0IsdUNBQTBCOzs7OztJQUMxQixtQ0FBa0I7Ozs7O0lBRWxCLHFDQUFvRTs7Ozs7SUFDcEUsbUNBQWtDOzs7OztJQUVsQyx1Q0FBMkM7Ozs7O0lBRTNDLCtDQUFtRDs7Ozs7SUFDbkQsZ0RBQThDOzs7Ozs7SUFLOUMsbUNBQzBCOzs7Ozs7SUFLMUIsbUNBQzBCOzs7Ozs7SUFLMUIsb0NBQzhGOzs7OztJQWE5RiwwQ0FBaUM7Ozs7O0lBS2pDLG1DQUFzRDs7Ozs7SUFLdEQsa0RBQzhDOzs7OztJQUs5QyxnREFDNEM7Ozs7O0lBSzVDLGtDQUN1Qjs7Ozs7SUE2QnZCLHdDQUN5Qjs7Ozs7Ozs7O0lBaUJ6QixnQ0FFc0M7Ozs7Ozs7O0lBK0N0QywwREFDMEM7Ozs7Ozs7Ozs7Ozs7SUE0WDFDLDJDQUN1RTs7Ozs7SUFHM0Qsc0NBQTJCOzs7OztJQUFFLGlDQUF1Qjs7Ozs7QUFxakJwRTtJQUFBO0lBTUEsQ0FBQzs7Z0JBTkEsUUFBUSxTQUFDO29CQUNOLFlBQVksRUFBRSxDQUFDLGtCQUFrQixFQUFFLDZCQUE2QixFQUFFLDJCQUEyQixDQUFDO29CQUM5RixPQUFPLEVBQUUsQ0FBQyxrQkFBa0IsRUFBRSw2QkFBNkIsRUFBRSwyQkFBMkIsQ0FBQztvQkFDekYsT0FBTyxFQUFFLENBQUMsWUFBWSxFQUFFLG9CQUFvQixDQUFDO2lCQUNoRDs7SUFFRCxzQkFBQztDQUFBLEFBTkQsSUFNQztTQURZLGVBQWUiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBDb21tb25Nb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuaW1wb3J0IHtcbiAgICBBZnRlclZpZXdJbml0LCBDb21wb25lbnQsIEVsZW1lbnRSZWYsIEV2ZW50RW1pdHRlcixcbiAgICBIb3N0QmluZGluZywgSW5wdXQsIE5nTW9kdWxlLCBPbkluaXQsIE91dHB1dCwgUmVuZGVyZXIyLFxuICAgIFZpZXdDaGlsZCxcbiAgICBEaXJlY3RpdmUsXG4gICAgVGVtcGxhdGVSZWYsXG4gICAgQ29udGVudENoaWxkLFxuICAgIEFmdGVyQ29udGVudEluaXQsXG4gICAgT25EZXN0cm95LFxuICAgIEhvc3RMaXN0ZW5lcixcbiAgICBWaWV3Q2hpbGRyZW4sXG4gICAgUXVlcnlMaXN0XG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgQ29udHJvbFZhbHVlQWNjZXNzb3IsIE5HX1ZBTFVFX0FDQ0VTU09SIH0gZnJvbSAnQGFuZ3VsYXIvZm9ybXMnO1xuaW1wb3J0IHsgRWRpdG9yUHJvdmlkZXIgfSBmcm9tICcuLi9jb3JlL2VkaXQtcHJvdmlkZXInO1xuaW1wb3J0IHsgRGVwcmVjYXRlUHJvcGVydHkgfSBmcm9tICcuLi9jb3JlL2RlcHJlY2F0ZURlY29yYXRvcnMnO1xuaW1wb3J0IHsgSWd4U2xpZGVyVGh1bWJNb2R1bGUsIElneFNsaWRlclRodW1iQ29tcG9uZW50IH0gZnJvbSAnLi90aHVtYi90aHVtYi1zbGlkZXIuY29tcG9uZW50JztcbmltcG9ydCB7IFN1YmplY3QsIG1lcmdlLCBjb25jYXQgfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IHRha2VVbnRpbCB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcblxuLyoqXG4gKiBUZW1wbGF0ZSBkaXJlY3RpdmUgdGhhdCBhbGxvd3MgeW91IHRvIHNldCBhIGN1c3RvbSB0ZW1wbGF0ZSByZXByZXNlbnRpbmcgdGhlIGxvd2VyIGxhYmVsIHZhbHVlIG9mIHRoZSB7QGxpbmsgSWd4U2xpZGVyQ29tcG9uZW50fVxuICpcbiAqYGBgaHRtbFxuICogPGlneC1zbGlkZXI+XG4gKiAgPG5nLXRlbXBsYXRlIGlneFNsaWRlclRodW1iRnJvbSBsZXQtdmFsdWUgbGV0LWxhYmVscz57e3ZhbHVlfX08L25nLXRlbXBsYXRlPlxuICogPC9pZ3gtc2xpZGVyPlxuICogYGBgXG4gKlxuICogQGNvbnRleHQge0BsaW5rIElneFNsaWRlckNvbXBvbmVudC5jb250ZXh0fVxuICovXG5ARGlyZWN0aXZlKHtcbiAgICBzZWxlY3RvcjogJ1tpZ3hTbGlkZXJUaHVtYkZyb21dJ1xufSlcbmV4cG9ydCBjbGFzcyBJZ3hUaHVtYkZyb21UZW1wbGF0ZURpcmVjdGl2ZSB7fVxuXG4vKipcbiAqIFRlbXBsYXRlIGRpcmVjdGl2ZSB0aGF0IGFsbG93cyB5b3UgdG8gc2V0IGEgY3VzdG9tIHRlbXBsYXRlIHJlcHJlc2VudGluZyB0aGUgdXBwZXIgbGFiZWwgdmFsdWUgb2YgdGhlIHtAbGluayBJZ3hTbGlkZXJDb21wb25lbnR9XG4gKlxuICogYGBgaHRtbFxuICogPGlneC1zbGlkZXI+XG4gKiAgPG5nLXRlbXBsYXRlIGlneFNsaWRlclRodW1iVG8gbGV0LXZhbHVlIGxldC1sYWJlbHM+e3t2YWx1ZX19PC9uZy10ZW1wbGF0ZT5cbiAqIDwvaWd4LXNsaWRlcj5cbiAqIGBgYFxuICpcbiAqIEBjb250ZXh0IHtAbGluayBJZ3hTbGlkZXJDb21wb25lbnQuY29udGV4dH1cbiAqL1xuQERpcmVjdGl2ZSh7XG4gICAgc2VsZWN0b3I6ICdbaWd4U2xpZGVyVGh1bWJUb10nXG59KVxuZXhwb3J0IGNsYXNzIElneFRodW1iVG9UZW1wbGF0ZURpcmVjdGl2ZSB7fVxuXG5leHBvcnQgZW51bSBTbGlkZXJUeXBlIHtcbiAgICAvKipcbiAgICAgKiBTbGlkZXIgd2l0aCBzaW5nbGUgdGh1bWIuXG4gICAgICovXG4gICAgU0xJREVSLFxuICAgIC8qKlxuICAgICAqICBSYW5nZSBzbGlkZXIgd2l0aCBtdWx0aXBsZSB0aHVtYnMsIHRoYXQgY2FuIG1hcmsgdGhlIHJhbmdlLlxuICAgICAqL1xuICAgIFJBTkdFXG59XG5cbmV4cG9ydCBlbnVtIFNsaWRlckhhbmRsZSB7XG4gICAgRlJPTSxcbiAgICBUT1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIElSYW5nZVNsaWRlclZhbHVlIHtcbiAgICBsb3dlcjogbnVtYmVyO1xuICAgIHVwcGVyOiBudW1iZXI7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgSVNsaWRlclZhbHVlQ2hhbmdlRXZlbnRBcmdzIHtcbiAgICBvbGRWYWx1ZTogbnVtYmVyIHwgSVJhbmdlU2xpZGVyVmFsdWU7XG4gICAgdmFsdWU6IG51bWJlciB8IElSYW5nZVNsaWRlclZhbHVlO1xufVxuXG5jb25zdCBub29wID0gKCkgPT4ge1xufTtcblxubGV0IE5FWFRfSUQgPSAwO1xuXG4vKipcbiAqICoqSWduaXRlIFVJIGZvciBBbmd1bGFyIFNsaWRlcioqIC1cbiAqIFtEb2N1bWVudGF0aW9uXShodHRwczovL3d3dy5pbmZyYWdpc3RpY3MuY29tL3Byb2R1Y3RzL2lnbml0ZS11aS1hbmd1bGFyL2FuZ3VsYXIvY29tcG9uZW50cy9zbGlkZXIuaHRtbClcbiAqXG4gKiBUaGUgSWduaXRlIFVJIFNsaWRlciBhbGxvd3Mgc2VsZWN0aW9uIGluIGEgZ2l2ZW4gcmFuZ2UgYnkgbW92aW5nIHRoZSB0aHVtYiBhbG9uZyB0aGUgdHJhY2suIFRoZSB0cmFja1xuICogY2FuIGJlIGRlZmluZWQgYXMgY29udGludW91cyBvciBzdGVwcGVkLCBhbmQgeW91IGNhbiBjaG9vc2UgYmV0d2VlbiBzaW5nbGUgYW5kIHJhbmdlIHNsaWRlciB0eXBlcy5cbiAqXG4gKiBFeGFtcGxlOlxuICogYGBgaHRtbFxuICogPGlneC1zbGlkZXIgaWQ9XCJzbGlkZXJcIlxuICogICAgICAgICAgICBbbWluVmFsdWVdPVwiMFwiIFttYXhWYWx1ZV09XCIxMDBcIlxuICogICAgICAgICAgICBbY29udGludW91c109dHJ1ZSBbKG5nTW9kZWwpXT1cInZvbHVtZVwiPlxuICogPC9pZ3gtc2xpZGVyPlxuICogYGBgXG4gKi9cbkBDb21wb25lbnQoe1xuICAgIHByb3ZpZGVyczogW3sgcHJvdmlkZTogTkdfVkFMVUVfQUNDRVNTT1IsIHVzZUV4aXN0aW5nOiBJZ3hTbGlkZXJDb21wb25lbnQsIG11bHRpOiB0cnVlIH1dLFxuICAgIHNlbGVjdG9yOiAnaWd4LXNsaWRlcicsXG4gICAgdGVtcGxhdGVVcmw6ICdzbGlkZXIuY29tcG9uZW50Lmh0bWwnLFxuICAgIHN0eWxlczogW2BcbiAgICAgICAgOmhvc3Qge1xuICAgICAgICAgICAgZGlzcGxheTogYmxvY2s7XG4gICAgICAgIH1cbiAgICBgXVxufSlcbmV4cG9ydCBjbGFzcyBJZ3hTbGlkZXJDb21wb25lbnQgaW1wbGVtZW50c1xuICAgIENvbnRyb2xWYWx1ZUFjY2Vzc29yLFxuICAgIEVkaXRvclByb3ZpZGVyLFxuICAgIE9uSW5pdCxcbiAgICBBZnRlclZpZXdJbml0LFxuICAgIEFmdGVyQ29udGVudEluaXQsXG4gICAgT25EZXN0cm95IHtcblxuICAgIC8vIExpbWl0IGhhbmRsZSB0cmF2ZWwgem9uZVxuICAgIHByaXZhdGUgX3BNaW4gPSAwO1xuICAgIHByaXZhdGUgX3BNYXggPSAxO1xuXG4gICAgLy8gRnJvbS91cHBlclZhbHVlIGluIHBlcmNlbnQgdmFsdWVzXG4gICAgcHJpdmF0ZSBfaGFzVmlld0luaXQgPSBmYWxzZTtcbiAgICBwcml2YXRlIF9taW5WYWx1ZSA9IDA7XG4gICAgcHJpdmF0ZSBfbWF4VmFsdWUgPSAxMDA7XG4gICAgcHJpdmF0ZSBfbG93ZXJCb3VuZD86IG51bWJlcjtcbiAgICBwcml2YXRlIF91cHBlckJvdW5kPzogbnVtYmVyO1xuICAgIHByaXZhdGUgX2xvd2VyVmFsdWU/OiBudW1iZXI7XG4gICAgcHJpdmF0ZSBfdXBwZXJWYWx1ZT86IG51bWJlcjtcbiAgICBwcml2YXRlIF9jb3VudGludW91cyA9IGZhbHNlO1xuICAgIHByaXZhdGUgX2Rpc2FibGVkID0gZmFsc2U7XG4gICAgcHJpdmF0ZSBfc3RlcCA9IDE7XG5cbiAgICBwcml2YXRlIF9sYWJlbHMgPSBuZXcgQXJyYXk8bnVtYmVyfHN0cmluZ3xib29sZWFufG51bGx8dW5kZWZpbmVkPigpO1xuICAgIHByaXZhdGUgX3R5cGUgPSBTbGlkZXJUeXBlLlNMSURFUjtcblxuICAgIHByaXZhdGUgX2Rlc3Ryb3kkID0gbmV3IFN1YmplY3Q8Ym9vbGVhbj4oKTtcblxuICAgIHByaXZhdGUgX29uQ2hhbmdlQ2FsbGJhY2s6IChfOiBhbnkpID0+IHZvaWQgPSBub29wO1xuICAgIHByaXZhdGUgX29uVG91Y2hlZENhbGxiYWNrOiAoKSA9PiB2b2lkID0gbm9vcDtcblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBAVmlld0NoaWxkKCd0cmFjaycpXG4gICAgcHJpdmF0ZSB0cmFjazogRWxlbWVudFJlZjtcblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBAVmlld0NoaWxkKCd0aWNrcycpXG4gICAgcHJpdmF0ZSB0aWNrczogRWxlbWVudFJlZjtcblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBAVmlld0NoaWxkcmVuKElneFNsaWRlclRodW1iQ29tcG9uZW50KVxuICAgIHByaXZhdGUgdGh1bWJzOiBRdWVyeUxpc3Q8SWd4U2xpZGVyVGh1bWJDb21wb25lbnQ+ID0gbmV3IFF1ZXJ5TGlzdDxJZ3hTbGlkZXJUaHVtYkNvbXBvbmVudD4oKTtcblxuICAgIHByaXZhdGUgZ2V0IHRodW1iRnJvbSgpOiBJZ3hTbGlkZXJUaHVtYkNvbXBvbmVudCB7XG4gICAgICAgIHJldHVybiB0aGlzLnRodW1icy5maW5kKHRodW1iID0+IHRodW1iLnR5cGUgPT09IFNsaWRlckhhbmRsZS5GUk9NKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIGdldCB0aHVtYlRvKCk6IElneFNsaWRlclRodW1iQ29tcG9uZW50IHtcbiAgICAgICAgcmV0dXJuIHRoaXMudGh1bWJzLmZpbmQodGh1bWIgPT4gdGh1bWIudHlwZSA9PT0gU2xpZGVySGFuZGxlLlRPKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHVibGljIHN0ZXBEaXN0YW5jZSA9IHRoaXMuX3N0ZXA7XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHVibGljIG9uUGFuOiBTdWJqZWN0PG51bWJlcj4gPSBuZXcgU3ViamVjdDxudW1iZXI+KCk7XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgQENvbnRlbnRDaGlsZChJZ3hUaHVtYkZyb21UZW1wbGF0ZURpcmVjdGl2ZSwgeyByZWFkOiBUZW1wbGF0ZVJlZiB9KVxuICAgIHB1YmxpYyB0aHVtYkZyb21UZW1wbGF0ZVJlZjogVGVtcGxhdGVSZWY8YW55PjtcblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBAQ29udGVudENoaWxkKElneFRodW1iVG9UZW1wbGF0ZURpcmVjdGl2ZSwgeyByZWFkOiBUZW1wbGF0ZVJlZiB9KVxuICAgIHB1YmxpYyB0aHVtYlRvVGVtcGxhdGVSZWY6IFRlbXBsYXRlUmVmPGFueT47XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgQEhvc3RCaW5kaW5nKGBhdHRyLnJvbGVgKVxuICAgIHB1YmxpYyByb2xlID0gJ3NsaWRlcic7XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgQEhvc3RCaW5kaW5nKGBhdHRyLmFyaWEtdmFsdWVtaW5gKVxuICAgIHB1YmxpYyBnZXQgdmFsdWVtaW4oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1pblZhbHVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBASG9zdEJpbmRpbmcoYGF0dHIuYXJpYS12YWx1ZW1heGApXG4gICAgcHVibGljIGdldCB2YWx1ZW1heCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWF4VmFsdWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIEBIb3N0QmluZGluZyhgYXR0ci5hcmlhLXJlYWRvbmx5YClcbiAgICBwdWJsaWMgZ2V0IHJlYWRvbmx5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kaXNhYmxlZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgQEhvc3RCaW5kaW5nKCdjbGFzcy5pZ3gtc2xpZGVyJylcbiAgICBwdWJsaWMgc2xpZXJDbGFzcyA9IHRydWU7XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgQEhvc3RCaW5kaW5nKCdjbGFzcy5pZ3gtc2xpZGVyLS1kaXNhYmxlZCcpXG4gICAgcHVibGljIGdldCBkaXNhYmxlZENsYXNzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kaXNhYmxlZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBbiBASW5wdXQgcHJvcGVydHkgdGhhdCBzZXRzIHRoZSB2YWx1ZSBvZiB0aGUgYGlkYCBhdHRyaWJ1dGUuXG4gICAgICogSWYgbm90IHByb3ZpZGVkIGl0IHdpbGwgYmUgYXV0b21hdGljYWxseSBnZW5lcmF0ZWQuXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxpZ3gtc2xpZGVyIFtpZF09XCInaWd4LXNsaWRlci0zMidcIiBbKG5nTW9kZWwpXT1cInRhc2sucGVyY2VudENvbXBsZXRlZFwiIFtzdGVwXT1cIjVcIiBbbG93ZXJCb3VuZF09XCIyMFwiPlxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIEBIb3N0QmluZGluZygnYXR0ci5pZCcpXG4gICAgQElucHV0KClcbiAgICBwdWJsaWMgaWQgPSBgaWd4LXNsaWRlci0ke05FWFRfSUQrK31gO1xuXG4gICAgLyoqXG4gICAgICogQW4gQElucHV0IHByb3BlcnR5IHRoYXQgZ2V0cyB0aGUgdHlwZSBvZiB0aGUgYElneFNsaWRlckNvbXBvbmVudGAuIFRoZSBzbGlkZXIgY2FuIGJlIFNsaWRlclR5cGUuU0xJREVSKGRlZmF1bHQpIG9yIFNsaWRlclR5cGUuUkFOR0UuXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIEBWaWV3Q2hpbGQoXCJzbGlkZXIyXCIpXG4gICAgICogcHVibGljIHNsaWRlcjogSWd4U2xpZGVyQ29tcG9uZW50O1xuICAgICAqIG5nQWZ0ZXJWaWV3SW5pdCgpe1xuICAgICAqICAgICBsZXQgdHlwZSA9IHRoaXMuc2xpZGVyLnR5cGU7XG4gICAgICogfVxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgcHVibGljIGdldCB0eXBlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdHlwZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBbiBASW5wdXQgcHJvcGVydHkgdGhhdCBzZXRzIHRoZSB0eXBlIG9mIHRoZSBgSWd4U2xpZGVyQ29tcG9uZW50YC4gVGhlIHNsaWRlciBjYW4gYmUgU2xpZGVyVHlwZS5TTElERVIoZGVmYXVsdCkgb3IgU2xpZGVyVHlwZS5SQU5HRS5cbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogc2xpZGVyVHlwZTogU2xpZGVyVHlwZSA9IFNsaWRlclR5cGUuUkFOR0U7XG4gICAgICogYGBgXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxpZ3gtc2xpZGVyICNzbGlkZXIyIFt0eXBlXT1cInNsaWRlclR5cGVcIiBbKG5nTW9kZWwpXT1cInJhbmdlVmFsdWVcIiBbbWluVmFsdWVdPVwiMFwiIFttYXhWYWx1ZV09XCIxMDBcIj5cbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBwdWJsaWMgc2V0IHR5cGUodHlwZTogU2xpZGVyVHlwZSkge1xuICAgICAgICB0aGlzLl90eXBlID0gdHlwZTtcblxuICAgICAgICBpZiAodHlwZSA9PT0gU2xpZGVyVHlwZS5TTElERVIpIHtcbiAgICAgICAgICAgIHRoaXMubG93ZXJWYWx1ZSA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5sYWJlbHNWaWV3RW5hYmxlZCAmJiB0aGlzLnVwcGVyVmFsdWUgPiB0aGlzLm1heFZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLnVwcGVyVmFsdWUgPSB0aGlzLmxhYmVscy5sZW5ndGggLSAxO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuX2hhc1ZpZXdJbml0KSB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVRyYWNrKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKkFuIEBJbnB1dCBwcm9wZXJ0eSB0aGF0IHNldHMgdGhlIGR1cmF0aW9uIHZpc2liaWxpdHkgb2YgdGh1bWJzIGxhYmVscy4gVGhlIGRlZmF1bHQgdmFsdWUgaXMgNzUwIG1pbGxpc2Vjb25kcy5cbiAgICAgKmBgYGh0bWxcbiAgICAgKjxpZ3gtc2xpZGVyICNzbGlkZXIgW3RodW1iTGFiZWxWaXNpYmlsaXR5RHVyYXRpb25dPVwiMzAwMFwiIFsobmdNb2RlbCldPVwidGFzay5wZXJjZW50Q29tcGxldGVkXCIgW3N0ZXBdPVwiNVwiPlxuICAgICAqYGBgXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBwdWJsaWMgdGh1bWJMYWJlbFZpc2liaWxpdHlEdXJhdGlvbiA9IDc1MDtcblxuXG4gICAgLyoqXG4gICAgICogRW5hYmxlcyBgbGFiZWxWaWV3YCwgYnkgYWNjZXB0aW5nIGEgY29sbGVjdGlvbiBvZiBwcmltaXRpdmUgdmFsdWVzIHdpdGggbW9yZSB0aGFuIG9uZSBlbGVtZW50LlxuICAgICAqIEVhY2ggZWxlbWVudCB3aWxsIGJlIGVxdWFsbHkgc3ByZWFkIG92ZXIgdGhlIHNsaWRlciBhbmQgaXQgd2lsbCBzZXJ2ZSBhcyBhIHRodW1iIGxhYmVsLlxuICAgICAqIE9uY2UgdGhlIHByb3BlcnR5IGlzIHNldCwgaXQgd2lsbCBwcmVjZW5kZW5jZSBvdmVyIHtAbGluayBtYXhWYWx1ZX0sIHtAbGluayBtaW5WYWx1ZX0sIHtAbGluayBzdGVwfS5cbiAgICAgKiBUaGlzIG1lYW5zIHRoYXQgdGhlIG1hbmlwdWxhdGlvbiBmb3IgdGhvc2UgcHJvcGVydGllcyB3b24ndCBiZSBhbGxvd2VkLlxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgcHVibGljIGdldCBsYWJlbHMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9sYWJlbHM7XG4gICAgfVxuXG4gICAgcHVibGljIHNldCBsYWJlbHMobGFiZWxzOiBBcnJheTxudW1iZXJ8c3RyaW5nfGJvb2xlYW58bnVsbHx1bmRlZmluZWQ+KSB7XG4gICAgICAgIHRoaXMuX2xhYmVscyA9IGxhYmVscztcblxuICAgICAgICB0aGlzLl9wTWF4ID0gMTtcblxuICAgICAgICBpZiAodGhpcy5faGFzVmlld0luaXQpIHtcbiAgICAgICAgICAgIHRoaXMuc3RlcERpc3RhbmNlID0gdGhpcy5jYWxjdWxhdGVTdGVwRGlzdGFuY2UoKTtcbiAgICAgICAgICAgIHRoaXMucG9zaXRpb25IYW5kbGVzQW5kVXBkYXRlVHJhY2soKTtcbiAgICAgICAgICAgIHRoaXMuc2V0VGlja0ludGVydmFsKGxhYmVscyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSB0ZW1wbGF0ZSBjb250ZXh0IGNvcnJlc3BvbmRpbmdcbiAgICAgKiB0byB7QGxpbmsgSWd4VGh1bWJGcm9tVGVtcGxhdGVEaXJlY3RpdmV9IGFuZCB7QGxpbmsgSWd4VGh1bWJUb1RlbXBsYXRlRGlyZWN0aXZlfSB0ZW1wbGF0ZXMuXG4gICAgICpcbiAgICAgKiByZXR1cm4ge1xuICAgICAqICAkaW1wbGljaXQ6IHtAbGluayB2YWx1ZX0sXG4gICAgICogIGxhYmVsczoge0BsaW5rIGxhYmVsc31cbiAgICAgKiB9XG4gICAgICogYGBgXG4gICAgICovXG4gICAgcHVibGljIGdldCBjb250ZXh0KCk6IGFueSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAkaW1wbGljaXQ6IHRoaXMudmFsdWUsXG4gICAgICAgICAgICBsYWJlbHM6IHRoaXMubGFiZWxzXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQW4gQElucHV0IHByb3BlcnR5IHRoYXQgc2V0cyB0aGUgaW5jcmVtZW50YWwvZGVjcmVtZW50YWwgc3RlcCBvZiB0aGUgdmFsdWUgd2hlbiBkcmFnZ2luZyB0aGUgdGh1bWIuXG4gICAgICogVGhlIGRlZmF1bHQgc3RlcCBpcyAxLCBhbmQgc3RlcCBzaG91bGQgbm90IGJlIGxlc3Mgb3IgZXF1YWwgdGhhbiAwLlxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8aWd4LXNsaWRlciAjc2xpZGVyIFsobmdNb2RlbCldPVwidGFzay5wZXJjZW50Q29tcGxldGVkXCIgW3N0ZXBdPVwiNVwiPlxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgcHVibGljIHNldCBzdGVwKHN0ZXA6IG51bWJlcikge1xuICAgICAgICB0aGlzLl9zdGVwID0gc3RlcDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBpbmNyZW1lbnRhbC9kZWNyZW1lbnRhbCBkcmFnZ2luZyBzdGVwIG9mIHRoZSB7QGxpbmsgSWd4U2xpZGVyQ29tcG9uZW50fS5cbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogQFZpZXdDaGlsZChcInNsaWRlcjJcIilcbiAgICAgKiBwdWJsaWMgc2xpZGVyOiBJZ3hTbGlkZXJDb21wb25lbnQ7XG4gICAgICogbmdBZnRlclZpZXdJbml0KCl7XG4gICAgICogICAgIGxldCBzdGVwID0gdGhpcy5zbGlkZXIuc3RlcDtcbiAgICAgKiB9XG4gICAgICogYGBgXG4gICAgICovXG4gICAgcHVibGljIGdldCBzdGVwKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5sYWJlbHNWaWV3RW5hYmxlZCA/IDEgOiB0aGlzLl9zdGVwO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgaWYgdGhlIHtAbGluayBJZ3hTbGlkZXJDb21wb25lbnR9IGlzIGRpc2FibGVkLlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBAVmlld0NoaWxkKFwic2xpZGVyMlwiKVxuICAgICAqIHB1YmxpYyBzbGlkZXI6IElneFNsaWRlckNvbXBvbmVudDtcbiAgICAgKiBuZ0FmdGVyVmlld0luaXQoKXtcbiAgICAgKiAgICAgbGV0IGlzRGlzYWJsZWQgPSB0aGlzLnNsaWRlci5kaXNhYmxlZDtcbiAgICAgKiB9XG4gICAgICogYGBgXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBwdWJsaWMgZ2V0IGRpc2FibGVkKCk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGlzYWJsZWQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpBbiBASW5wdXQgcHJvcGVydHkgdGhhdCBkaXNhYmxlcyBvciBlbmFibGVzIFVJIGludGVyYWN0aW9uLlxuICAgICAqYGBgaHRtbFxuICAgICAqPGlneC1zbGlkZXIgI3NsaWRlciBbZGlzYWJsZWRdPVwiJ3RydWUnXCIgWyhuZ01vZGVsKV09XCJ0YXNrLnBlcmNlbnRDb21wbGV0ZWRcIiBbc3RlcF09XCI1XCIgW2xvd2VyQm91bmRdPVwiMjBcIj5cbiAgICAgKmBgYFxuICAgICAqL1xuICAgIHB1YmxpYyBzZXQgZGlzYWJsZWQoZGlzYWJsZTogYm9vbGVhbikge1xuICAgICAgICB0aGlzLl9kaXNhYmxlZCA9IGRpc2FibGU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBpZiB0aGUge0BsaW5rIElneFNsaWRlckNvbXBvbmVudH0gaXMgc2V0IGFzIGNvbnRpbnVvdXMuXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIEBWaWV3Q2hpbGQoXCJzbGlkZXIyXCIpXG4gICAgICogcHVibGljIHNsaWRlcjogSWd4U2xpZGVyQ29tcG9uZW50O1xuICAgICAqIG5nQWZ0ZXJWaWV3SW5pdCgpe1xuICAgICAqICAgICBsZXQgY29udGludW91cyA9IHRoaXMuc2xpZGVyLmNvbnRpbnVvdXM7XG4gICAgICogfVxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgcHVibGljIGdldCBjb250aW51b3VzKCk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gdGhpcy5fY291bnRpbnVvdXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQW4gQElucHV0IHByb3BlcnR5IHRoYXQgbWFya3MgdGhlIHtAbGluayBJZ3hTbGlkZXJDb21wb25lbnR9IGFzIGNvbnRpbnVvdXMuXG4gICAgICogQnkgZGVmYXVsdCBpcyBjb25zaWRlcmVkIHRoYXQgdGhlIHtAbGluayBJZ3hTbGlkZXJDb21wb25lbnR9IGlzIGRpc2NyZXRlLlxuICAgICAqIERpc2NyZXRlIHtAbGluayBJZ3hTbGlkZXJDb21wb25lbnR9IGRvZXMgbm90IGhhdmUgdGlja3MgYW5kIGRvZXMgbm90IHNob3dzIGJ1YmJsZSBsYWJlbHMgZm9yIHZhbHVlcy5cbiAgICAgKiBgYGBodG1sXG4gICAgICogPGlneC1zbGlkZXIgI3NsaWRlciBbY29udGludW91c109XCIndHJ1ZSdcIiBbKG5nTW9kZWwpXT1cInRhc2sucGVyY2VudENvbXBsZXRlZFwiIFtzdGVwXT1cIjVcIiBbbG93ZXJCb3VuZF09XCIyMFwiPlxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIHB1YmxpYyBzZXQgY29udGludW91cyhjb250aW51b3VzOiBib29sZWFuKSB7XG4gICAgICAgIGlmICh0aGlzLmxhYmVsc1ZpZXdFbmFibGVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9jb3VudGludW91cyA9IGNvbnRpbnVvdXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBpZiB0aGUge0BsaW5rIElneFNsaWRlckNvbXBvbmVudH0gaXMgc2V0IGFzIGNvbnRpbnVvdXMuXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIEBWaWV3Q2hpbGQoXCJzbGlkZXIyXCIpXG4gICAgICogcHVibGljIHNsaWRlcjogSWd4U2xpZGVyQ29tcG9uZW50O1xuICAgICAqIG5nQWZ0ZXJWaWV3SW5pdCgpe1xuICAgICAqICAgICBsZXQgY29udGludW91cyA9IHRoaXMuc2xpZGVyLmNvbnRpbnVvdXM7XG4gICAgICogfVxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgQERlcHJlY2F0ZVByb3BlcnR5KGBJZ3hTbGlkZXJDb21wb25lbnQgXFxgaXNDb250aW51b3VzXFxgIHByb3BlcnR5IGlzIGRlcHJlY2F0ZWQuXFxuVXNlIFxcYGNvbnRpbnVvdXNcXGAgaW5zdGVhZC5gKVxuICAgIHB1YmxpYyBnZXQgaXNDb250aW51b3VzKCk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gdGhpcy5jb250aW51b3VzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBwdWJsaWMgc2V0IGlzQ29udGludW91cyhjb250aW51b3VzOiBib29sZWFuKSB7XG4gICAgICAgIHRoaXMuY29udGludW91cyA9IGNvbnRpbnVvdXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgbWF4aW11bSB2YWx1ZSBmb3IgdGhlIHtAbGluayBJZ3hTbGlkZXJDb21wb25lbnR9LlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKkBWaWV3Q2hpbGQoXCJzbGlkZXJcIilcbiAgICAgKnB1YmxpYyBzbGlkZXI6IElneFNsaWRlckNvbXBvbmVudDtcbiAgICAgKm5nQWZ0ZXJWaWV3SW5pdCgpe1xuICAgICAqICAgIGxldCBzbGlkZXJNYXggPSB0aGlzLnNsaWRlci5tYXhWYWx1ZTtcbiAgICAgKn1cbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0IG1heFZhbHVlKCk6IG51bWJlciB7XG4gICAgICAgIHJldHVybiB0aGlzLmxhYmVsc1ZpZXdFbmFibGVkID9cbiAgICAgICAgICAgIHRoaXMubGFiZWxzLmxlbmd0aCAtIDEgOlxuICAgICAgICAgICAgdGhpcy5fbWF4VmFsdWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgbWF4aW1hbCB2YWx1ZSBmb3IgdGhlIGBJZ3hTbGlkZXJDb21wb25lbnRgLlxuICAgICAqIFRoZSBkZWZhdWx0IG1heGltdW0gdmFsdWUgaXMgMTAwLlxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8aWd4LXNsaWRlciBbdHlwZV09XCJzbGlkZXJUeXBlXCIgW21pblZhbHVlXT1cIjU2XCIgW21heFZhbHVlXT1cIjI1NlwiPlxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgcHVibGljIHNldCBtYXhWYWx1ZSh2YWx1ZTogbnVtYmVyKSB7XG4gICAgICAgIGlmICh2YWx1ZSA8PSB0aGlzLl9taW5WYWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5fbWF4VmFsdWUgPSB0aGlzLl9taW5WYWx1ZSArIDE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9tYXhWYWx1ZSA9IHZhbHVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHZhbHVlIDwgdGhpcy5sb3dlckJvdW5kKSB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUxvd2VyQm91bmRBbmRNaW5UcmF2ZWxab25lKCk7XG4gICAgICAgICAgICB0aGlzLnVwcGVyQm91bmQgPSB2YWx1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHJlZnJlc2ggbWF4IHRyYXZlbCB6b25lIGxpbWl0cy5cbiAgICAgICAgdGhpcy5fcE1heCA9IDE7XG4gICAgICAgIC8vIHJlY2FsY3VsYXRlIHN0ZXAgZGlzdGFuY2UuXG4gICAgICAgIHRoaXMuc3RlcERpc3RhbmNlID0gdGhpcy5jYWxjdWxhdGVTdGVwRGlzdGFuY2UoKTtcbiAgICAgICAgdGhpcy5wb3NpdGlvbkhhbmRsZXNBbmRVcGRhdGVUcmFjaygpO1xuICAgICAgICB0aGlzLnNldFRpY2tJbnRlcnZhbChudWxsKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlJldHVybnMgdGhlIG1pbmltYWwgdmFsdWUgb2YgdGhlIGBJZ3hTbGlkZXJDb21wb25lbnRgLlxuICAgICAqYGBgdHlwZXNjcmlwdFxuICAgICAqQFZpZXdDaGlsZChcInNsaWRlcjJcIilcbiAgICAgKnB1YmxpYyBzbGlkZXI6IElneFNsaWRlckNvbXBvbmVudDtcbiAgICAgKm5nQWZ0ZXJWaWV3SW5pdCgpe1xuICAgICAqICAgIGxldCBzbGlkZXJNaW4gPSB0aGlzLnNsaWRlci5taW5WYWx1ZTtcbiAgICAgKn1cbiAgICAgKmBgYFxuICAgICAqL1xuICAgIHB1YmxpYyBnZXQgbWluVmFsdWUoKTogbnVtYmVyIHtcbiAgICAgICAgaWYgKHRoaXMubGFiZWxzVmlld0VuYWJsZWQpIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX21pblZhbHVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIG1pbmltYWwgdmFsdWUgZm9yIHRoZSBgSWd4U2xpZGVyQ29tcG9uZW50YC5cbiAgICAgKiBUaGUgZGVmYXVsdCBtaW5pbWFsIHZhbHVlIGlzIDAuXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxpZ3gtc2xpZGVyIFt0eXBlXT1cInNsaWRlclR5cGVcIiBbbWluVmFsdWVdPVwiNTZcIiBbbWF4VmFsdWVdPVwiMTAwXCI+XG4gICAgICogYGBgXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBwdWJsaWMgc2V0IG1pblZhbHVlKHZhbHVlOiBudW1iZXIpIHtcbiAgICAgICAgaWYgKHZhbHVlID49IHRoaXMubWF4VmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuX21pblZhbHVlID0gdGhpcy5tYXhWYWx1ZSAtIDE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9taW5WYWx1ZSA9IHZhbHVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHZhbHVlID4gdGhpcy51cHBlckJvdW5kKSB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVVwcGVyQm91bmRBbmRNYXhUcmF2ZWxab25lKCk7XG4gICAgICAgICAgICB0aGlzLmxvd2VyQm91bmQgPSB2YWx1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFJlZnJlc2ggbWluIHRyYXZlbCB6b25lIGxpbWl0LlxuICAgICAgICB0aGlzLl9wTWluID0gMDtcbiAgICAgICAgLy8gUmVjYWxjdWxhdGUgc3RlcCBkaXN0YW5jZS5cbiAgICAgICAgdGhpcy5zdGVwRGlzdGFuY2UgPSB0aGlzLmNhbGN1bGF0ZVN0ZXBEaXN0YW5jZSgpO1xuICAgICAgICB0aGlzLnBvc2l0aW9uSGFuZGxlc0FuZFVwZGF0ZVRyYWNrKCk7XG4gICAgICAgIHRoaXMuc2V0VGlja0ludGVydmFsKG51bGwpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGxvd2VyIGJvdW5kYXJ5IG9mIHRoZSBgSWd4U2xpZGVyQ29tcG9uZW50YC5cbiAgICAgKmBgYHR5cGVzY3JpcHRcbiAgICAgKkBWaWV3Q2hpbGQoXCJzbGlkZXJcIilcbiAgICAgKnB1YmxpYyBzbGlkZXI6IElneFNsaWRlckNvbXBvbmVudDtcbiAgICAgKm5nQWZ0ZXJWaWV3SW5pdCgpe1xuICAgICAqICAgIGxldCBzbGlkZXJMb3dCb3VuZCA9IHRoaXMuc2xpZGVyLmxvd2VyQm91bmQ7XG4gICAgICp9XG4gICAgICpgYGBcbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0IGxvd2VyQm91bmQoKTogbnVtYmVyIHtcbiAgICAgICAgaWYgKCFOdW1iZXIuaXNOYU4odGhpcy5fbG93ZXJCb3VuZCkgJiYgdGhpcy5fbG93ZXJCb3VuZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy52YWx1ZUluUmFuZ2UodGhpcy5fbG93ZXJCb3VuZCwgdGhpcy5taW5WYWx1ZSwgdGhpcy5tYXhWYWx1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5taW5WYWx1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBsb3dlciBib3VuZGFyeSBvZiB0aGUgYElneFNsaWRlckNvbXBvbmVudGAuXG4gICAgICogSWYgbm90IHNldCBpcyB0aGUgc2FtZSBhcyBtaW4gdmFsdWUuXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxpZ3gtc2xpZGVyIFtzdGVwXT1cIjVcIiBbbG93ZXJCb3VuZF09XCIyMFwiPlxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgcHVibGljIHNldCBsb3dlckJvdW5kKHZhbHVlOiBudW1iZXIpIHtcbiAgICAgICAgaWYgKHZhbHVlID49IHRoaXMudXBwZXJCb3VuZCB8fCAodGhpcy5sYWJlbHNWaWV3RW5hYmxlZCAmJiB2YWx1ZSA8IDApKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9sb3dlckJvdW5kID0gdGhpcy52YWx1ZUluUmFuZ2UodmFsdWUsIHRoaXMubWluVmFsdWUsIHRoaXMubWF4VmFsdWUpO1xuXG4gICAgICAgIC8vIFJlZnJlc2ggdGltZSB0cmF2ZWwgem9uZS5cbiAgICAgICAgdGhpcy5fcE1pbiA9IHRoaXMudmFsdWVUb0ZyYWN0aW9uKHRoaXMuX2xvd2VyQm91bmQpIHx8IDA7XG4gICAgICAgIHRoaXMucG9zaXRpb25IYW5kbGVzQW5kVXBkYXRlVHJhY2soKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSB1cHBlciBib3VuZGFyeSBvZiB0aGUgYElneFNsaWRlckNvbXBvbmVudGAuXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqQFZpZXdDaGlsZChcInNsaWRlclwiKVxuICAgICAqcHVibGljIHNsaWRlcjogSWd4U2xpZGVyQ29tcG9uZW50O1xuICAgICAqbmdBZnRlclZpZXdJbml0KCl7XG4gICAgICogICAgbGV0IHNsaWRlclVwQm91bmQgPSB0aGlzLnNsaWRlci51cHBlckJvdW5kO1xuICAgICAqfVxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIHB1YmxpYyBnZXQgdXBwZXJCb3VuZCgpOiBudW1iZXIge1xuICAgICAgICBpZiAoIU51bWJlci5pc05hTih0aGlzLl91cHBlckJvdW5kKSAmJiB0aGlzLl91cHBlckJvdW5kICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnZhbHVlSW5SYW5nZSh0aGlzLl91cHBlckJvdW5kLCB0aGlzLm1pblZhbHVlLCB0aGlzLm1heFZhbHVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLm1heFZhbHVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIHVwcGVyIGJvdW5kYXJ5IG9mIHRoZSBgSWd4U2xpZGVyQ29tcG9uZW50YC5cbiAgICAgKiBJZiBub3Qgc2V0IGlzIHRoZSBzYW1lIGFzIG1heCB2YWx1ZS5cbiAgICAgKiBgYGBodG1sXG4gICAgICogPGlneC1zbGlkZXIgW3N0ZXBdPVwiNVwiIFt1cHBlckJvdW5kXT1cIjIwXCI+XG4gICAgICogYGBgXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBwdWJsaWMgc2V0IHVwcGVyQm91bmQodmFsdWU6IG51bWJlcikge1xuICAgICAgICBpZiAodmFsdWUgPD0gdGhpcy5sb3dlckJvdW5kIHx8ICh0aGlzLmxhYmVsc1ZpZXdFbmFibGVkICYmIHZhbHVlID4gdGhpcy5sYWJlbHMubGVuZ3RoIC0gMSkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX3VwcGVyQm91bmQgPSB0aGlzLnZhbHVlSW5SYW5nZSh2YWx1ZSwgdGhpcy5taW5WYWx1ZSwgdGhpcy5tYXhWYWx1ZSk7XG4gICAgICAgIC8vIFJlZnJlc2ggdGltZSB0cmF2ZWwgem9uZS5cbiAgICAgICAgdGhpcy5fcE1heCA9IHRoaXMudmFsdWVUb0ZyYWN0aW9uKHRoaXMuX3VwcGVyQm91bmQpIHx8IDE7XG4gICAgICAgIHRoaXMucG9zaXRpb25IYW5kbGVzQW5kVXBkYXRlVHJhY2soKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBzbGlkZXIgdmFsdWUuIElmIHRoZSBzbGlkZXIgaXMgb2YgdHlwZSB7QGxpbmsgU2xpZGVyVHlwZS5TTElERVJ9IHRoZSByZXR1cm5lZCB2YWx1ZSBpcyBudW1iZXIuXG4gICAgICogSWYgdGhlIHNsaWRlciB0eXBlIGlzIHtAbGluayBTbGlkZXJUeXBlLlJBTkdFfSB0aGUgcmV0dXJuZWQgdmFsdWUgcmVwcmVzZW50cyBhbiBvYmplY3Qgb2Yge0BsaW5rIGxvd2VyVmFsdWV9IGFuZCB7QGxpbmsgdXBwZXJWYWx1ZX0uXG4gICAgICpgYGB0eXBlc2NyaXB0XG4gICAgICpAVmlld0NoaWxkKFwic2xpZGVyMlwiKVxuICAgICAqcHVibGljIHNsaWRlcjogSWd4U2xpZGVyQ29tcG9uZW50O1xuICAgICAqcHVibGljIHNsaWRlclZhbHVlKGV2ZW50KXtcbiAgICAgKiAgICBsZXQgc2xpZGVyVmFsID0gdGhpcy5zbGlkZXIudmFsdWU7XG4gICAgICp9XG4gICAgICpgYGBcbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0IHZhbHVlKCk6IG51bWJlciB8IElSYW5nZVNsaWRlclZhbHVlIHtcbiAgICAgICAgaWYgKHRoaXMuaXNSYW5nZSkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBsb3dlcjogdGhpcy52YWx1ZUluUmFuZ2UodGhpcy5sb3dlclZhbHVlLCB0aGlzLmxvd2VyQm91bmQsIHRoaXMudXBwZXJCb3VuZCksXG4gICAgICAgICAgICAgICAgdXBwZXI6IHRoaXMudmFsdWVJblJhbmdlKHRoaXMudXBwZXJWYWx1ZSwgdGhpcy5sb3dlckJvdW5kLCB0aGlzLnVwcGVyQm91bmQpXG4gICAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudmFsdWVJblJhbmdlKHRoaXMudXBwZXJWYWx1ZSwgdGhpcy5sb3dlckJvdW5kLCB0aGlzLnVwcGVyQm91bmQpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgc2xpZGVyIHZhbHVlLlxuICAgICAqIElmIHRoZSBzbGlkZXIgaXMgb2YgdHlwZSB7QGxpbmsgU2xpZGVyVHlwZS5TTElERVJ9IHRoZSBhcmd1bWVudCBpcyBudW1iZXIuIEJ5IGRlZmF1bHQgdGhlIHtAbGluayB2YWx1ZX0gZ2V0cyB0aGUge0BsaW5rIGxvd2VyQm91bmR9LlxuICAgICAqIElmIHRoZSBzbGlkZXIgdHlwZSBpcyB7QGxpbmsgU2xpZGVyVHlwZS5SQU5HRX0gdGhlIGFyZ3VtZW50XG4gICAgICogcmVwcmVzZW50cyBhbiBvYmplY3Qgb2Yge0BsaW5rIGxvd2VyVmFsdWV9IGFuZCB7QGxpbmsgdXBwZXJWYWx1ZX0gcHJvcGVydGllcy5cbiAgICAgKiBCeSBkZWZhdWx0IHRoZSBvYmplY3QgaXMgYXNzb2NpYXRlZCB3aXRoIHRoZSB7QGxpbmsgbG93ZXJCb3VuZH0gYW5kIHtAbGluayB1cHBlckJvdW5kfSBwcm9wZXJ0eSB2YWx1ZXMuXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqcmFuZ2VWYWx1ZSA9IHtcbiAgICAgKiAgIGxvd2VyOiAzMCxcbiAgICAgKiAgIHVwcGVyOiA2MFxuICAgICAqfTtcbiAgICAgKiBgYGBcbiAgICAgKiBgYGBodG1sXG4gICAgICogPGlneC1zbGlkZXIgW3R5cGVdPVwic2xpZGVyVHlwZVwiIFsobmdNb2RlbCldPVwicmFuZ2VWYWx1ZVwiIFttaW5WYWx1ZV09XCI1NlwiIFttYXhWYWx1ZV09XCIyNTZcIj5cbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHB1YmxpYyBzZXQgdmFsdWUodmFsdWU6IG51bWJlciB8IElSYW5nZVNsaWRlclZhbHVlKSB7XG4gICAgICAgIGlmICghdGhpcy5pc1JhbmdlKSB7XG4gICAgICAgICAgICB0aGlzLnVwcGVyVmFsdWUgPSB2YWx1ZSBhcyBudW1iZXI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHRoaXMudmFsaWRhdGVJbml0aWFsVmFsdWUodmFsdWUgYXMgSVJhbmdlU2xpZGVyVmFsdWUpO1xuICAgICAgICAgICAgdGhpcy51cHBlclZhbHVlID0gKHZhbHVlIGFzIElSYW5nZVNsaWRlclZhbHVlKS51cHBlcjtcbiAgICAgICAgICAgIHRoaXMubG93ZXJWYWx1ZSA9ICh2YWx1ZSBhcyBJUmFuZ2VTbGlkZXJWYWx1ZSkubG93ZXI7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9vbkNoYW5nZUNhbGxiYWNrKHRoaXMudmFsdWUpO1xuXG4gICAgICAgIGlmICh0aGlzLl9oYXNWaWV3SW5pdCkge1xuICAgICAgICAgICAgdGhpcy5wb3NpdGlvbkhhbmRsZXNBbmRVcGRhdGVUcmFjaygpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBldmVudCBpcyBlbWl0dGVkIHdoZW4gdXNlciBoYXMgc3RvcHBlZCBpbnRlcmFjdGluZyB0aGUgdGh1bWIgYW5kIHZhbHVlIGlzIGNoYW5nZWQuXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIHB1YmxpYyBjaGFuZ2UoZXZlbnQpe1xuICAgICAqICAgIGFsZXJ0KFwiVGhlIHZhbHVlIGhhcyBiZWVuIGNoYW5nZWQhXCIpO1xuICAgICAqfVxuICAgICAqIGBgYFxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8aWd4LXNsaWRlciAob25WYWx1ZUNoYW5nZSk9XCJjaGFuZ2UoJGV2ZW50KVwiICNzbGlkZXIgWyhuZ01vZGVsKV09XCJ0YXNrLnBlcmNlbnRDb21wbGV0ZWRcIiBbc3RlcF09XCI1XCI+XG4gICAgICogYGBgXG4gICAgICovXG4gICAgQE91dHB1dCgpXG4gICAgcHVibGljIG9uVmFsdWVDaGFuZ2UgPSBuZXcgRXZlbnRFbWl0dGVyPElTbGlkZXJWYWx1ZUNoYW5nZUV2ZW50QXJncz4oKTtcblxuXG4gICAgY29uc3RydWN0b3IocHJpdmF0ZSByZW5kZXJlcjogUmVuZGVyZXIyLCBwcml2YXRlIF9lbDogRWxlbWVudFJlZikgeyB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgQEhvc3RMaXN0ZW5lcigncG9pbnRlcmRvd24nLCBbJyRldmVudCddKVxuICAgIHB1YmxpYyBvblBvaW50ZXJEb3duKCRldmVudCkge1xuICAgICAgICB0aGlzLmZpbmRDbG9zZXN0VGh1bWIoJGV2ZW50KTtcblxuICAgICAgICBpZiAoIXRoaXMudGh1bWJUby5pc0FjdGl2ZSAmJiB0aGlzLnRodW1iRnJvbSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnNob3dUaHVtYkxhYmVscygpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBASG9zdExpc3RlbmVyKCdwb2ludGVydXAnKVxuICAgIHB1YmxpYyBvblBvaW50ZXJVcCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLnRodW1iVG8uaXNBY3RpdmUgJiYgdGhpcy50aHVtYkZyb20gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5oaWRlVGh1bWJMYWJlbHMoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgQEhvc3RMaXN0ZW5lcignZm9jdXMnKVxuICAgIHB1YmxpYyBvbkZvY3VzKCkge1xuICAgICAgICB0aGlzLnRvZ2dsZVRodW1iTGFiZWxzKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIEBIb3N0TGlzdGVuZXIoJ2JsdXInKVxuICAgIHB1YmxpYyBvbkJsdXIoKSB7XG4gICAgICAgIHRoaXMuaGlkZVRodW1iTGFiZWxzKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIEBIb3N0TGlzdGVuZXIoJ3BhbicsIFsnJGV2ZW50J10pXG4gICAgcHVibGljIG9uUGFuTGlzdGVuZXIoJGV2ZW50KSB7XG4gICAgICAgIHRoaXMudXBkYXRlKCRldmVudC5zcmNFdmVudC5jbGllbnRYKTtcbiAgICB9XG5cbiAgICBASG9zdExpc3RlbmVyKCdwYW5zdGFydCcpXG4gICAgcHVibGljIG9uUGFuU3RhcnQoKSB7XG4gICAgICAgIHRoaXMuc2hvd1RodW1iTGFiZWxzKCk7XG4gICAgfVxuXG4gICAgQEhvc3RMaXN0ZW5lcigncGFuZW5kJylcbiAgICBwdWJsaWMgb25QYW5FbmQoKSB7XG4gICAgICAgIHRoaXMuaGlkZVRodW1iTGFiZWxzKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIEBIb3N0TGlzdGVuZXIoJ3RhcCcsIFsnJGV2ZW50J10pXG4gICAgcHVibGljIG9uVGFwTGlzdGVuZXIoJGV2ZW50KSB7XG4gICAgICAgIHRoaXMub25UYXAoJGV2ZW50KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlJldHVybnMgd2hldGhlciB0aGUgYElneFNsaWRlckNvbXBvbmVudGAgdHlwZSBpcyBSQU5HRS5cbiAgICAgKmBgYHR5cGVzY3JpcHRcbiAgICAgKkBWaWV3Q2hpbGQoXCJzbGlkZXJcIilcbiAgICAgKnB1YmxpYyBzbGlkZXI6IElneFNsaWRlckNvbXBvbmVudDtcbiAgICAgKm5nQWZ0ZXJWaWV3SW5pdCgpe1xuICAgICAqICAgIGxldCBzbGlkZXJSYW5nZSA9IHRoaXMuc2xpZGVyLmlzUmFuZ2U7XG4gICAgICp9XG4gICAgICogYGBgXG4gICAgICovXG4gICAgcHVibGljIGdldCBpc1JhbmdlKCk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gdGhpcy50eXBlID09PSBTbGlkZXJUeXBlLlJBTkdFO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGxvd2VyIHZhbHVlIG9mIHRoZSBgSWd4U2xpZGVyQ29tcG9uZW50YC5cbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogQFZpZXdDaGlsZChcInNsaWRlclwiKVxuICAgICAqIHB1YmxpYyBzbGlkZXI6IElneFNsaWRlckNvbXBvbmVudDtcbiAgICAgKiBwdWJsaWMgbG93VmFsdWUoZXZlbnQpe1xuICAgICAqICAgIGxldCBzbGlkZXJMb3dWYWx1ZSA9IHRoaXMuc2xpZGVyLmxvd2VyVmFsdWU7XG4gICAgICp9XG4gICAgICpgYGBcbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0IGxvd2VyVmFsdWUoKTogbnVtYmVyIHtcbiAgICAgICAgaWYgKCFOdW1iZXIuaXNOYU4odGhpcy5fbG93ZXJWYWx1ZSkgJiYgdGhpcy5fbG93ZXJWYWx1ZSAhPT0gdW5kZWZpbmVkICYmIHRoaXMuX2xvd2VyVmFsdWUgPj0gdGhpcy5sb3dlckJvdW5kKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbG93ZXJWYWx1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLmxvd2VyQm91bmQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpTZXRzIHRoZSBsb3dlciB2YWx1ZSBvZiB0aGUgYElneFNsaWRlckNvbXBvbmVudGAuXG4gICAgICpgYGB0eXBlc2NyaXB0XG4gICAgICpAVmlld0NoaWxkKFwic2xpZGVyMlwiKVxuICAgICAqcHVibGljIHNsaWRlcjogSWd4U2xpZGVyQ29tcG9uZW50O1xuICAgICAqcHVibGljIGxvd1ZhbHVlKGV2ZW50KXtcbiAgICAgKiAgICB0aGlzLnNsaWRlci5sb3dlclZhbHVlID0gMTIwO1xuICAgICAqfVxuICAgICAqYGBgXG4gICAgICovXG4gICAgcHVibGljIHNldCBsb3dlclZhbHVlKHZhbHVlOiBudW1iZXIpIHtcbiAgICAgICAgdmFsdWUgPSB0aGlzLnZhbHVlSW5SYW5nZSh2YWx1ZSwgdGhpcy5sb3dlckJvdW5kLCB0aGlzLnVwcGVyQm91bmQpO1xuICAgICAgICB0aGlzLl9sb3dlclZhbHVlID0gdmFsdWU7XG5cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlJldHVybnMgdGhlIHVwcGVyIHZhbHVlIG9mIHRoZSBgSWd4U2xpZGVyQ29tcG9uZW50YC5cbiAgICAgKmBgYHR5cGVzY3JpcHRcbiAgICAgKkBWaWV3Q2hpbGQoXCJzbGlkZXIyXCIpXG4gICAgICpwdWJsaWMgc2xpZGVyOiBJZ3hTbGlkZXJDb21wb25lbnQ7XG4gICAgICpwdWJsaWMgdXBwZXJWYWx1ZShldmVudCl7XG4gICAgICogICAgbGV0IHVwcGVyVmFsdWUgPSB0aGlzLnNsaWRlci51cHBlclZhbHVlO1xuICAgICAqfVxuICAgICAqYGBgXG4gICAgICovXG4gICAgcHVibGljIGdldCB1cHBlclZhbHVlKCkge1xuICAgICAgICBpZiAoIU51bWJlci5pc05hTih0aGlzLl91cHBlclZhbHVlKSAmJiB0aGlzLl91cHBlclZhbHVlICE9PSB1bmRlZmluZWQgJiYgdGhpcy5fdXBwZXJWYWx1ZSA8PSB0aGlzLnVwcGVyQm91bmQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl91cHBlclZhbHVlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMudXBwZXJCb3VuZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlNldHMgdGhlIHVwcGVyIHZhbHVlIG9mIHRoZSBgSWd4U2xpZGVyQ29tcG9uZW50YC5cbiAgICAgKmBgYHR5cGVzY3JpcHRcbiAgICAgKkBWaWV3Q2hpbGQoXCJzbGlkZXIyXCIpXG4gICAgICpwdWJsaWMgc2xpZGVyOiBJZ3hTbGlkZXJDb21wb25lbnQ7XG4gICAgICpwdWJsaWMgdXBwZXJWYWx1ZShldmVudCl7XG4gICAgICogICAgdGhpcy5zbGlkZXIudXBwZXJWYWx1ZSA9IDEyMDtcbiAgICAgKn1cbiAgICAgKmBgYFxuICAgICAqL1xuICAgIHB1YmxpYyBzZXQgdXBwZXJWYWx1ZSh2YWx1ZTogbnVtYmVyKSB7XG4gICAgICAgIHZhbHVlID0gdGhpcy52YWx1ZUluUmFuZ2UodmFsdWUsIHRoaXMubG93ZXJCb3VuZCwgdGhpcy51cHBlckJvdW5kKTtcbiAgICAgICAgdGhpcy5fdXBwZXJWYWx1ZSA9IHZhbHVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHZhbHVlIGNvcnJlc3BvbmRpbmcgdGhlIGxvd2VyIGxhYmVsLlxuICAgICAqYGBgdHlwZXNjcmlwdFxuICAgICAqIEBWaWV3Q2hpbGQoXCJzbGlkZXJcIilcbiAgICAgKiBwdWJsaWMgc2xpZGVyOiBJZ3hTbGlkZXJDb21wb25lbnQ7XG4gICAgICogbGV0IGxhYmVsID0gdGhpcy5zbGlkZXIubG93ZXJMYWJlbDtcbiAgICAgKmBgYFxuICAgICAqL1xuICAgIHB1YmxpYyBnZXQgbG93ZXJMYWJlbCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubGFiZWxzVmlld0VuYWJsZWQgP1xuICAgICAgICAgICAgdGhpcy5sYWJlbHNbdGhpcy5sb3dlclZhbHVlXSA6XG4gICAgICAgICAgICB0aGlzLmxvd2VyVmFsdWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgdmFsdWUgY29ycmVzcG9uZGluZyB0aGUgdXBwZXIgbGFiZWwuXG4gICAgICpgYGB0eXBlc2NyaXB0XG4gICAgICogQFZpZXdDaGlsZChcInNsaWRlclwiKVxuICAgICAqIHB1YmxpYyBzbGlkZXI6IElneFNsaWRlckNvbXBvbmVudDtcbiAgICAgKiBsZXQgbGFiZWwgPSB0aGlzLnNsaWRlci51cHBlckxhYmVsO1xuICAgICAqYGBgXG4gICAgICovXG4gICAgcHVibGljIGdldCB1cHBlckxhYmVsKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5sYWJlbHNWaWV3RW5hYmxlZCA/XG4gICAgICAgICAgICB0aGlzLmxhYmVsc1t0aGlzLnVwcGVyVmFsdWVdIDpcbiAgICAgICAgICAgIHRoaXMudXBwZXJWYWx1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGlmIGxhYmVsIHZpZXcgaXMgZW5hYmxlZC5cbiAgICAgKiBJZiB0aGUge0BsaW5rIGxhYmVsc30gaXMgc2V0LCB0aGUgdmlldyBpcyBhdXRvbWF0aWNhbGx5IGFjdGl2YXRlZC5cbiAgICAgKmBgYHR5cGVzY3JpcHRcbiAgICAgKiBAVmlld0NoaWxkKFwic2xpZGVyXCIpXG4gICAgICogcHVibGljIHNsaWRlcjogSWd4U2xpZGVyQ29tcG9uZW50O1xuICAgICAqIGxldCBsYWJlbFZpZXcgPSB0aGlzLnNsaWRlci5sYWJlbHNWaWV3RW5hYmxlZDtcbiAgICAgKmBgYFxuICAgICAqL1xuICAgIHB1YmxpYyBnZXQgbGFiZWxzVmlld0VuYWJsZWQoKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiAhISh0aGlzLmxhYmVscyAmJiB0aGlzLmxhYmVscy5sZW5ndGggPiAxKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHVibGljIG5nT25Jbml0KCkge1xuICAgICAgICB0aGlzLnNsaWRlclNldHVwKCk7XG5cbiAgICAgICAgLy8gU2V0IHRyYWNrIHRyYXZlbCB6b25lXG4gICAgICAgIHRoaXMuX3BNaW4gPSB0aGlzLnZhbHVlVG9GcmFjdGlvbih0aGlzLmxvd2VyQm91bmQpIHx8IDA7XG4gICAgICAgIHRoaXMuX3BNYXggPSB0aGlzLnZhbHVlVG9GcmFjdGlvbih0aGlzLnVwcGVyQm91bmQpIHx8IDE7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHB1YmxpYyBuZ0FmdGVyVmlld0luaXQoKSB7XG4gICAgICAgIHRoaXMuX2hhc1ZpZXdJbml0ID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5wb3NpdGlvbkhhbmRsZXNBbmRVcGRhdGVUcmFjaygpO1xuICAgICAgICB0aGlzLnNldFRpY2tJbnRlcnZhbCh0aGlzLmxhYmVscyk7XG5cbiAgICAgICAgdGhpcy5zdWJzY3JpYmVUbyh0aGlzLnRodW1iRnJvbSwgdGhpcy50aHVtYkNoYW5nZWQuYmluZCh0aGlzKSk7XG4gICAgICAgIHRoaXMuc3Vic2NyaWJlVG8odGhpcy50aHVtYlRvLCB0aGlzLnRodW1iQ2hhbmdlZC5iaW5kKHRoaXMpKTtcblxuICAgICAgICB0aGlzLnRodW1icy5jaGFuZ2VzLnBpcGUodGFrZVVudGlsKHRoaXMuX2Rlc3Ryb3kkKSkuc3Vic2NyaWJlKGNoYW5nZSA9PiB7XG4gICAgICAgICAgICBjb25zdCB0ID0gY2hhbmdlLmZpbmQoKHRodW1iOiBJZ3hTbGlkZXJUaHVtYkNvbXBvbmVudCkgPT4gdGh1bWIudHlwZSA9PT0gU2xpZGVySGFuZGxlLkZST00pO1xuICAgICAgICAgICAgdGhpcy5wb3NpdGlvbkhhbmRsZSh0LCB0aGlzLmxvd2VyVmFsdWUpO1xuICAgICAgICAgICAgdGhpcy5zdWJzY3JpYmVUbyh0LCB0aGlzLnRodW1iQ2hhbmdlZC5iaW5kKHRoaXMpKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHB1YmxpYyBuZ0FmdGVyQ29udGVudEluaXQoKSB7XG4gICAgICAgIC8vIENhbGN1bGF0ZXMgdGhlIGRpc3RhbmNlIGJldHdlZW4gZXZlcnkgc3RlcCBpbiBwaXhlbHMuXG4gICAgICAgIHRoaXMuc3RlcERpc3RhbmNlID0gdGhpcy5jYWxjdWxhdGVTdGVwRGlzdGFuY2UoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHVibGljIG5nT25EZXN0cm95KCkge1xuICAgICAgICB0aGlzLl9kZXN0cm95JC5uZXh0KHRydWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwdWJsaWMgd3JpdGVWYWx1ZSh2YWx1ZTogYW55KTogdm9pZCB7XG4gICAgICAgIGlmICghdmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHVibGljIHJlZ2lzdGVyT25DaGFuZ2UoZm46IGFueSk6IHZvaWQge1xuICAgICAgICB0aGlzLl9vbkNoYW5nZUNhbGxiYWNrID0gZm47XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHB1YmxpYyByZWdpc3Rlck9uVG91Y2hlZChmbjogYW55KTogdm9pZCB7XG4gICAgICAgIHRoaXMuX29uVG91Y2hlZENhbGxiYWNrID0gZm47XG4gICAgfVxuXG4gICAgLyoqIEBoaWRkZW4gKi9cbiAgICBwdWJsaWMgZ2V0RWRpdEVsZW1lbnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlzUmFuZ2UgPyB0aGlzLnRodW1iRnJvbS5uYXRpdmVFbGVtZW50IDogdGhpcy50aHVtYlRvLm5hdGl2ZUVsZW1lbnQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHVibGljIG9uVGFwKCRldmVudCkge1xuICAgICAgICB0aGlzLnVwZGF0ZSgkZXZlbnQuc3JjRXZlbnQuY2xpZW50WCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHB1YmxpYyB1cGRhdGUobW91c2VYKSB7XG4gICAgICAgIGlmICh0aGlzLmRpc2FibGVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBVcGRhdGUgVG8vRnJvbSBWYWx1ZXNcbiAgICAgICAgdGhpcy5vblBhbi5uZXh0KG1vdXNlWCk7XG5cbiAgICAgICAgLy8gRmluYWxseSBkbyBwb3NpdGlvbkhhbmRsZXNBbmRVcGRhdGVUcmFjayB0aGUgRE9NXG4gICAgICAgIC8vIGJhc2VkIG9uIGRhdGEgdmFsdWVzXG4gICAgICAgIHRoaXMucG9zaXRpb25IYW5kbGVzQW5kVXBkYXRlVHJhY2soKTtcbiAgICAgICAgdGhpcy5fb25Ub3VjaGVkQ2FsbGJhY2soKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHVibGljIHRodW1iQ2hhbmdlZCh2YWx1ZTogbnVtYmVyLCB0aHVtYlR5cGU6IG51bWJlcikge1xuICAgICAgICBjb25zdCBvbGRWYWx1ZSA9IHRoaXMudmFsdWU7XG5cbiAgICAgICAgbGV0IG5ld1ZhbDogSVJhbmdlU2xpZGVyVmFsdWU7XG4gICAgICAgIGlmICh0aGlzLmlzUmFuZ2UpIHtcbiAgICAgICAgICAgIGlmICh0aHVtYlR5cGUgPT09IFNsaWRlckhhbmRsZS5GUk9NKSB7XG4gICAgICAgICAgICAgICAgbmV3VmFsID0ge1xuICAgICAgICAgICAgICAgICAgICBsb3dlcjogKHRoaXMudmFsdWUgYXMgSVJhbmdlU2xpZGVyVmFsdWUpLmxvd2VyICsgdmFsdWUsXG4gICAgICAgICAgICAgICAgICAgIHVwcGVyOiAodGhpcy52YWx1ZSBhcyBJUmFuZ2VTbGlkZXJWYWx1ZSkudXBwZXJcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBuZXdWYWwgPSB7XG4gICAgICAgICAgICAgICAgICAgIGxvd2VyOiAodGhpcy52YWx1ZSBhcyBJUmFuZ2VTbGlkZXJWYWx1ZSkubG93ZXIsXG4gICAgICAgICAgICAgICAgICAgIHVwcGVyOiAodGhpcy52YWx1ZSBhcyBJUmFuZ2VTbGlkZXJWYWx1ZSkudXBwZXIgKyB2YWx1ZVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFN3YXAgdGhlIHRodW1icyBpZiBhIGNvbGxpc2lvbiBhcHBlYXJzLlxuICAgICAgICAgICAgaWYgKG5ld1ZhbC5sb3dlciA+PSBuZXdWYWwudXBwZXIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnZhbHVlID0gdGhpcy5zd2FwVGh1bWIobmV3VmFsKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy52YWx1ZSA9IG5ld1ZhbDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy52YWx1ZSA9IHRoaXMudmFsdWUgYXMgbnVtYmVyICsgdmFsdWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5oYXNWYWx1ZUNoYW5nZWQob2xkVmFsdWUpKSB7XG4gICAgICAgICAgICB0aGlzLmVtaXRWYWx1ZUNoYW5nZWQob2xkVmFsdWUpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHB1YmxpYyBvblRodW1iQ2hhbmdlKCkge1xuICAgICAgICB0aGlzLnRvZ2dsZVRodW1iTGFiZWxzKCk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBzd2FwVGh1bWIodmFsdWU6IElSYW5nZVNsaWRlclZhbHVlKSB7XG4gICAgICAgIGlmICh0aGlzLnRodW1iRnJvbS5pc0FjdGl2ZSkge1xuICAgICAgICAgICAgdmFsdWUudXBwZXIgPSB0aGlzLnVwcGVyVmFsdWU7XG4gICAgICAgICAgICB2YWx1ZS5sb3dlciA9IHRoaXMudXBwZXJWYWx1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhbHVlLnVwcGVyID0gdGhpcy5sb3dlclZhbHVlO1xuICAgICAgICAgICAgdmFsdWUubG93ZXIgPSB0aGlzLmxvd2VyVmFsdWU7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnRvZ2dsZVRodW1iKCk7XG5cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cblxuICAgIHByaXZhdGUgZmluZENsb3Nlc3RUaHVtYihldmVudCkge1xuICAgICAgICBpZiAodGhpcy5pc1JhbmdlKSB7XG4gICAgICAgICAgICB0aGlzLmNsb3Nlc3RIYW5kbGUoZXZlbnQuY2xpZW50WCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnRodW1iVG8ubmF0aXZlRWxlbWVudC5mb2N1cygpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy51cGRhdGUoZXZlbnQuY2xpZW50WCk7XG5cbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIHVwZGF0ZUxvd2VyQm91bmRBbmRNaW5UcmF2ZWxab25lKCkge1xuICAgICAgICB0aGlzLmxvd2VyQm91bmQgPSB0aGlzLm1pblZhbHVlO1xuICAgICAgICB0aGlzLl9wTWluID0gMDtcbiAgICB9XG5cbiAgICBwcml2YXRlIHVwZGF0ZVVwcGVyQm91bmRBbmRNYXhUcmF2ZWxab25lKCkge1xuICAgICAgICB0aGlzLnVwcGVyQm91bmQgPSB0aGlzLm1heFZhbHVlO1xuICAgICAgICB0aGlzLl9wTWF4ID0gMTtcbiAgICB9XG5cbiAgICBwcml2YXRlIHNsaWRlclNldHVwKCkge1xuICAgICAgICAvKipcbiAgICAgICAgICogaWYge0BsaW5rIFNsaWRlclR5cGUuU0xJREVSfSB0aGFuIHRoZSBpbml0aWFsIHZhbHVlIHNob2xkIGJlIHRoZSBsb3dlc3Qgb25lLlxuICAgICAgICAgKi9cbiAgICAgICAgaWYgKCF0aGlzLmlzUmFuZ2UgJiYgdGhpcy52YWx1ZSA9PT0gdGhpcy51cHBlckJvdW5kKSB7XG4gICAgICAgICAgICB0aGlzLnZhbHVlID0gdGhpcy5sb3dlckJvdW5kO1xuICAgICAgICB9XG5cbiAgICB9XG5cbiAgICBwcml2YXRlIGNhbGN1bGF0ZVN0ZXBEaXN0YW5jZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2VsLm5hdGl2ZUVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkud2lkdGggLyAodGhpcy5tYXhWYWx1ZSAtIHRoaXMubWluVmFsdWUpICogdGhpcy5zdGVwO1xuICAgIH1cblxuICAgIHByaXZhdGUgdG9nZ2xlVGh1bWIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRodW1iRnJvbS5pc0FjdGl2ZSA/XG4gICAgICAgICAgICB0aGlzLnRodW1iVG8ubmF0aXZlRWxlbWVudC5mb2N1cygpIDpcbiAgICAgICAgICAgIHRoaXMudGh1bWJGcm9tLm5hdGl2ZUVsZW1lbnQuZm9jdXMoKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIHZhbHVlSW5SYW5nZSh2YWx1ZSwgbWluID0gMCwgbWF4ID0gMTAwKSB7XG4gICAgICAgIHJldHVybiBNYXRoLm1heChNYXRoLm1pbih2YWx1ZSwgbWF4KSwgbWluKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIGdlbmVyYXRlVGlja01hcmtzKGNvbG9yOiBzdHJpbmcsIGludGVydmFsOiBudW1iZXIpIHtcbiAgICAgICAgcmV0dXJuIGludGVydmFsICE9PSBudWxsID8gYHJlcGVhdGluZy1saW5lYXItZ3JhZGllbnQoXG4gICAgICAgICAgICAkeyd0byBsZWZ0J30sXG4gICAgICAgICAgICAke2NvbG9yfSxcbiAgICAgICAgICAgICR7Y29sb3J9IDEuNXB4LFxuICAgICAgICAgICAgdHJhbnNwYXJlbnQgMS41cHgsXG4gICAgICAgICAgICB0cmFuc3BhcmVudCAke2ludGVydmFsfSVcbiAgICAgICAgKSwgcmVwZWF0aW5nLWxpbmVhci1ncmFkaWVudChcbiAgICAgICAgICAgICR7J3RvIHJpZ2h0J30sXG4gICAgICAgICAgICAke2NvbG9yfSxcbiAgICAgICAgICAgICR7Y29sb3J9IDEuNXB4LFxuICAgICAgICAgICAgdHJhbnNwYXJlbnQgMS41cHgsXG4gICAgICAgICAgICB0cmFuc3BhcmVudCAke2ludGVydmFsfSVcbiAgICAgICAgKWAgOiBpbnRlcnZhbDtcbiAgICB9XG5cbiAgICBwcml2YXRlIHBvc2l0aW9uSGFuZGxlKGhhbmRsZTogRWxlbWVudFJlZiwgcG9zaXRpb246IG51bWJlcikge1xuICAgICAgICBpZiAoIWhhbmRsZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaGFuZGxlLm5hdGl2ZUVsZW1lbnQuc3R5bGUubGVmdCA9IGAke3RoaXMudmFsdWVUb0ZyYWN0aW9uKHBvc2l0aW9uKSAqIDEwMH0lYDtcbiAgICB9XG5cbiAgICBwcml2YXRlIHBvc2l0aW9uSGFuZGxlc0FuZFVwZGF0ZVRyYWNrKCkge1xuICAgICAgICBpZiAoIXRoaXMuaXNSYW5nZSkge1xuICAgICAgICAgICAgdGhpcy5wb3NpdGlvbkhhbmRsZSh0aGlzLnRodW1iVG8sIHRoaXMudmFsdWUgYXMgbnVtYmVyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMucG9zaXRpb25IYW5kbGUodGhpcy50aHVtYlRvLCAodGhpcy52YWx1ZSBhcyBJUmFuZ2VTbGlkZXJWYWx1ZSkudXBwZXIpO1xuICAgICAgICAgICAgdGhpcy5wb3NpdGlvbkhhbmRsZSh0aGlzLnRodW1iRnJvbSwgKHRoaXMudmFsdWUgYXMgSVJhbmdlU2xpZGVyVmFsdWUpLmxvd2VyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMudXBkYXRlVHJhY2soKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIGNsb3Nlc3RIYW5kbGUobW91c2VYKSB7XG4gICAgICAgIGNvbnN0IGZyb21PZmZzZXQgPSB0aGlzLnRodW1iRnJvbS5uYXRpdmVFbGVtZW50Lm9mZnNldExlZnQgKyB0aGlzLnRodW1iRnJvbS5uYXRpdmVFbGVtZW50Lm9mZnNldFdpZHRoIC8gMjtcbiAgICAgICAgY29uc3QgdG9PZmZzZXQgPSB0aGlzLnRodW1iVG8ubmF0aXZlRWxlbWVudC5vZmZzZXRMZWZ0ICsgdGhpcy50aHVtYlRvLm5hdGl2ZUVsZW1lbnQub2Zmc2V0V2lkdGggLyAyO1xuICAgICAgICBjb25zdCB4UG9pbnRlciA9IG1vdXNlWCAtIHRoaXMuX2VsLm5hdGl2ZUVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkubGVmdDtcbiAgICAgICAgY29uc3QgbWF0Y2ggPSB0aGlzLmNsb3Nlc3RUbyh4UG9pbnRlciwgW2Zyb21PZmZzZXQsIHRvT2Zmc2V0XSk7XG5cbiAgICAgICAgaWYgKG1hdGNoID09PSBmcm9tT2Zmc2V0KSB7XG4gICAgICAgICAgICB0aGlzLnRodW1iRnJvbS5uYXRpdmVFbGVtZW50LmZvY3VzKCk7XG4gICAgICAgIH0gZWxzZSBpZiAobWF0Y2ggPT09IHRvT2Zmc2V0KSB7XG4gICAgICAgICAgICB0aGlzLnRodW1iVG8ubmF0aXZlRWxlbWVudC5mb2N1cygpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBzZXRUaWNrSW50ZXJ2YWwobGFiZWxzKSB7XG4gICAgICAgIGlmICh0aGlzLmNvbnRpbnVvdXMpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBpbnRlcnZhbDtcbiAgICAgICAgY29uc3QgdHJhY2tQcm9ncmVzcyA9IDEwMDtcbiAgICAgICAgaWYgKHRoaXMubGFiZWxzVmlld0VuYWJsZWQpIHtcbiAgICAgICAgICAgIC8vIENhbGMgdGlja3MgZGVwZW5kaW5nIG9uIHRoZSBsYWJlbHMgbGVuZ3RoO1xuICAgICAgICAgICAgaW50ZXJ2YWwgPSAoKHRyYWNrUHJvZ3Jlc3MgLyAodGhpcy5sYWJlbHMubGVuZ3RoIC0gMSkgKiAxMCkpIC8gMTA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zdCB0cmFja1JhbmdlID0gdGhpcy5tYXhWYWx1ZSAtIHRoaXMubWluVmFsdWU7XG4gICAgICAgICAgICBpbnRlcnZhbCA9IHRoaXMuc3RlcCA+IDEgP1xuICAgICAgICAgICAgICAgICh0cmFja1Byb2dyZXNzIC8gKCh0cmFja1JhbmdlIC8gdGhpcy5zdGVwKSkgKiAxMCkgLyAxMFxuICAgICAgICAgICAgICAgIDogbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJlbmRlcmVyLnNldFN0eWxlKHRoaXMudGlja3MubmF0aXZlRWxlbWVudCwgJ2JhY2tncm91bmQnLCB0aGlzLmdlbmVyYXRlVGlja01hcmtzKCd3aGl0ZScsIGludGVydmFsKSk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBzaG93VGh1bWJMYWJlbHMoKSB7XG4gICAgICAgIGlmICh0aGlzLmRpc2FibGVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnRodW1iVG8uc2hvd1RodW1iTGFiZWwoKTtcbiAgICAgICAgaWYgKHRoaXMudGh1bWJGcm9tKSB7XG4gICAgICAgICAgICB0aGlzLnRodW1iRnJvbS5zaG93VGh1bWJMYWJlbCgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBoaWRlVGh1bWJMYWJlbHMoKSB7XG4gICAgICAgIGlmICh0aGlzLmRpc2FibGVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnRodW1iVG8uaGlkZVRodW1iTGFiZWwoKTtcbiAgICAgICAgaWYgKHRoaXMudGh1bWJGcm9tKSB7XG4gICAgICAgICAgICB0aGlzLnRodW1iRnJvbS5oaWRlVGh1bWJMYWJlbCgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJpdmF0ZSB0b2dnbGVUaHVtYkxhYmVscygpIHtcbiAgICAgICAgdGhpcy5zaG93VGh1bWJMYWJlbHMoKTtcbiAgICAgICAgdGhpcy5oaWRlVGh1bWJMYWJlbHMoKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIGNsb3Nlc3RUbyhnb2FsOiBudW1iZXIsIHBvc2l0aW9uczogbnVtYmVyW10pOiBudW1iZXIge1xuICAgICAgICByZXR1cm4gcG9zaXRpb25zLnJlZHVjZSgocHJldmlvdXMsIGN1cnJlbnQpID0+IHtcbiAgICAgICAgICAgIHJldHVybiAoTWF0aC5hYnMoZ29hbCAtIGN1cnJlbnQpIDwgTWF0aC5hYnMoZ29hbCAtIHByZXZpb3VzKSA/IGN1cnJlbnQgOiBwcmV2aW91cyk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHByaXZhdGUgdmFsdWVUb0ZyYWN0aW9uKHZhbHVlOiBudW1iZXIsIHBNaW4gPSB0aGlzLl9wTWluLCBwTWF4ID0gdGhpcy5fcE1heCkge1xuICAgICAgICByZXR1cm4gdGhpcy52YWx1ZUluUmFuZ2UoKHZhbHVlIC0gdGhpcy5taW5WYWx1ZSkgLyAodGhpcy5tYXhWYWx1ZSAtIHRoaXMubWluVmFsdWUpLCBwTWluLCBwTWF4KTtcbiAgICB9XG5cbiAgICBwcml2YXRlIHVwZGF0ZVRyYWNrKCkge1xuICAgICAgICBjb25zdCBmcm9tUG9zaXRpb24gPSB0aGlzLnZhbHVlVG9GcmFjdGlvbih0aGlzLmxvd2VyVmFsdWUpO1xuICAgICAgICBjb25zdCB0b1Bvc2l0aW9uID0gdGhpcy52YWx1ZVRvRnJhY3Rpb24odGhpcy51cHBlclZhbHVlKTtcbiAgICAgICAgY29uc3QgcG9zaXRpb25HYXAgPSB0b1Bvc2l0aW9uIC0gZnJvbVBvc2l0aW9uO1xuXG4gICAgICAgIGxldCB0cmFja0xlZnRJbmRlbnRpb24gPSBmcm9tUG9zaXRpb247XG4gICAgICAgIGlmICh0aGlzLmlzUmFuZ2UpIHtcbiAgICAgICAgICAgIGlmIChwb3NpdGlvbkdhcCkge1xuICAgICAgICAgICAgICAgIHRyYWNrTGVmdEluZGVudGlvbiA9IE1hdGgucm91bmQoKDEgLyBwb3NpdGlvbkdhcCAqIGZyb21Qb3NpdGlvbikgKiAxMDApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLnJlbmRlcmVyLnNldFN0eWxlKHRoaXMudHJhY2submF0aXZlRWxlbWVudCwgJ3RyYW5zZm9ybScsIGBzY2FsZVgoJHtwb3NpdGlvbkdhcH0pIHRyYW5zbGF0ZVgoJHt0cmFja0xlZnRJbmRlbnRpb259JSlgKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMucmVuZGVyZXIuc2V0U3R5bGUodGhpcy50cmFjay5uYXRpdmVFbGVtZW50LCAndHJhbnNmb3JtJywgYHNjYWxlWCgke3RvUG9zaXRpb259KWApO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJpdmF0ZSB2YWxpZGF0ZUluaXRpYWxWYWx1ZSh2YWx1ZTogSVJhbmdlU2xpZGVyVmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlLmxvd2VyIDwgdGhpcy5sb3dlckJvdW5kICYmIHZhbHVlLnVwcGVyIDwgdGhpcy5sb3dlckJvdW5kKSB7XG4gICAgICAgICAgICB2YWx1ZS51cHBlciA9IHRoaXMubG93ZXJCb3VuZDtcbiAgICAgICAgICAgIHZhbHVlLmxvd2VyID0gdGhpcy5sb3dlckJvdW5kO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHZhbHVlLmxvd2VyID4gdGhpcy51cHBlckJvdW5kICYmIHZhbHVlLnVwcGVyID4gdGhpcy51cHBlckJvdW5kKSB7XG4gICAgICAgICAgICB2YWx1ZS51cHBlciA9IHRoaXMudXBwZXJCb3VuZDtcbiAgICAgICAgICAgIHZhbHVlLmxvd2VyID0gdGhpcy51cHBlckJvdW5kO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHZhbHVlLnVwcGVyIDwgdmFsdWUubG93ZXIpIHtcbiAgICAgICAgICAgIHZhbHVlLnVwcGVyID0gdGhpcy51cHBlclZhbHVlO1xuICAgICAgICAgICAgdmFsdWUubG93ZXIgPSB0aGlzLmxvd2VyVmFsdWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBzdWJzY3JpYmVUbyh0aHVtYjogSWd4U2xpZGVyVGh1bWJDb21wb25lbnQsIGNhbGxiYWNrOiAoYTogbnVtYmVyLCBiOiBudW1iZXIpID0+IHZvaWQpIHtcbiAgICAgICAgaWYgKCF0aHVtYikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGh1bWIub25UaHVtYlZhbHVlQ2hhbmdlXG4gICAgICAgICAgICAucGlwZSh0YWtlVW50aWwodGhpcy51bnN1YnNjcmliZXIodGh1bWIpKSlcbiAgICAgICAgICAgIC5zdWJzY3JpYmUodmFsdWUgPT4gY2FsbGJhY2sodmFsdWUsIHRodW1iLnR5cGUpKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIHVuc3Vic2NyaWJlcih0aHVtYjogSWd4U2xpZGVyVGh1bWJDb21wb25lbnQpIHtcbiAgICAgICAgcmV0dXJuIG1lcmdlKHRoaXMuX2Rlc3Ryb3kkLCB0aHVtYi5kZXN0cm95KTtcbiAgICB9XG5cbiAgICBwcml2YXRlIGhhc1ZhbHVlQ2hhbmdlZChvbGRWYWx1ZSkge1xuICAgICAgICBjb25zdCBpc1NsaWRlcldpdGhEaWZmZXJlbnRWYWx1ZTogYm9vbGVhbiA9ICF0aGlzLmlzUmFuZ2UgJiYgb2xkVmFsdWUgIT09IHRoaXMudmFsdWU7XG4gICAgICAgIGNvbnN0IGlzUmFuZ2VXaXRoT25lRGlmZmVyZW50VmFsdWU6IGJvb2xlYW4gPSB0aGlzLmlzUmFuZ2UgJiZcbiAgICAgICAgICAgICgob2xkVmFsdWUgYXMgSVJhbmdlU2xpZGVyVmFsdWUpLmxvd2VyICE9PSAodGhpcy52YWx1ZSBhcyBJUmFuZ2VTbGlkZXJWYWx1ZSkubG93ZXIgfHxcbiAgICAgICAgICAgICAgICAob2xkVmFsdWUgYXMgSVJhbmdlU2xpZGVyVmFsdWUpLnVwcGVyICE9PSAodGhpcy52YWx1ZSBhcyBJUmFuZ2VTbGlkZXJWYWx1ZSkudXBwZXIpO1xuXG4gICAgICAgIHJldHVybiBpc1NsaWRlcldpdGhEaWZmZXJlbnRWYWx1ZSB8fCBpc1JhbmdlV2l0aE9uZURpZmZlcmVudFZhbHVlO1xuICAgIH1cblxuICAgIHByaXZhdGUgZW1pdFZhbHVlQ2hhbmdlZChvbGRWYWx1ZTogbnVtYmVyIHwgSVJhbmdlU2xpZGVyVmFsdWUpIHtcbiAgICAgICAgdGhpcy5vblZhbHVlQ2hhbmdlLmVtaXQoeyBvbGRWYWx1ZSwgdmFsdWU6IHRoaXMudmFsdWUgfSk7XG4gICAgfVxufVxuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuQE5nTW9kdWxlKHtcbiAgICBkZWNsYXJhdGlvbnM6IFtJZ3hTbGlkZXJDb21wb25lbnQsIElneFRodW1iRnJvbVRlbXBsYXRlRGlyZWN0aXZlLCBJZ3hUaHVtYlRvVGVtcGxhdGVEaXJlY3RpdmVdLFxuICAgIGV4cG9ydHM6IFtJZ3hTbGlkZXJDb21wb25lbnQsIElneFRodW1iRnJvbVRlbXBsYXRlRGlyZWN0aXZlLCBJZ3hUaHVtYlRvVGVtcGxhdGVEaXJlY3RpdmVdLFxuICAgIGltcG9ydHM6IFtDb21tb25Nb2R1bGUsIElneFNsaWRlclRodW1iTW9kdWxlXVxufSlcbmV4cG9ydCBjbGFzcyBJZ3hTbGlkZXJNb2R1bGUge1xufVxuIl19