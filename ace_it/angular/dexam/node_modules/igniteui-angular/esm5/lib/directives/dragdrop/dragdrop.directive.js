/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { Directive, ElementRef, EventEmitter, HostBinding, HostListener, Input, NgModule, NgZone, Output, Renderer2, ChangeDetectorRef } from '@angular/core';
import { animationFrameScheduler, fromEvent, interval, Subject } from 'rxjs';
import { takeUntil, throttle } from 'rxjs/operators';
/** @enum {number} */
var RestrictDrag = {
    VERTICALLY: 0,
    HORIZONTALLY: 1,
    NONE: 2,
};
export { RestrictDrag };
RestrictDrag[RestrictDrag.VERTICALLY] = 'VERTICALLY';
RestrictDrag[RestrictDrag.HORIZONTALLY] = 'HORIZONTALLY';
RestrictDrag[RestrictDrag.NONE] = 'NONE';
var IgxDragCustomEventDetails = /** @class */ (function () {
    function IgxDragCustomEventDetails() {
    }
    return IgxDragCustomEventDetails;
}());
export { IgxDragCustomEventDetails };
if (false) {
    /** @type {?} */
    IgxDragCustomEventDetails.prototype.startX;
    /** @type {?} */
    IgxDragCustomEventDetails.prototype.startY;
    /** @type {?} */
    IgxDragCustomEventDetails.prototype.pageX;
    /** @type {?} */
    IgxDragCustomEventDetails.prototype.pageY;
    /** @type {?} */
    IgxDragCustomEventDetails.prototype.owner;
    /** @type {?} */
    IgxDragCustomEventDetails.prototype.originalEvent;
}
var IgxDropEnterEventArgs = /** @class */ (function () {
    function IgxDropEnterEventArgs() {
    }
    return IgxDropEnterEventArgs;
}());
export { IgxDropEnterEventArgs };
if (false) {
    /**
     * Reference to the original event that caused the draggable element to enter the igxDrop element.
     * Can be PointerEvent, TouchEvent or MouseEvent.
     * @type {?}
     */
    IgxDropEnterEventArgs.prototype.originalEvent;
    /**
     * The owner igxDrop directive that triggered this event.
     * @type {?}
     */
    IgxDropEnterEventArgs.prototype.owner;
    /**
     * The igxDrag directive instanced on an element that entered the area of the igxDrop element
     * @type {?}
     */
    IgxDropEnterEventArgs.prototype.drag;
    /**
     * The data contained for the draggable element in igxDrag directive.
     * @type {?}
     */
    IgxDropEnterEventArgs.prototype.dragData;
    /**
     * The initial position of the pointer on X axis when the dragged element began moving
     * @type {?}
     */
    IgxDropEnterEventArgs.prototype.startX;
    /**
     * The initial position of the pointer on Y axis when the dragged element began moving
     * @type {?}
     */
    IgxDropEnterEventArgs.prototype.startY;
    /**
     * The current position of the pointer on X axis when the event was triggered.
     * Note: The browser might trigger the event with some delay and pointer would be already inside the igxDrop.
     * @type {?}
     */
    IgxDropEnterEventArgs.prototype.pageX;
    /**
     * The current position of the pointer on Y axis when the event was triggered.
     * Note: The browser might trigger the event with some delay and pointer would be already inside the igxDrop.
     * @type {?}
     */
    IgxDropEnterEventArgs.prototype.pageY;
    /**
     * The current position of the pointer on X axis relative to the container that initializes the igxDrop.
     * Note: The browser might trigger the event with some delay and pointer would be already inside the igxDrop.
     * @type {?}
     */
    IgxDropEnterEventArgs.prototype.offsetX;
    /**
     * The current position of the pointer on Y axis relative to the container that initializes the igxDrop.
     * Note: The browser might trigger the event with some delay and pointer would be already inside the igxDrop.
     * @type {?}
     */
    IgxDropEnterEventArgs.prototype.offsetY;
}
var IgxDropLeaveEventArgs = /** @class */ (function () {
    function IgxDropLeaveEventArgs() {
    }
    return IgxDropLeaveEventArgs;
}());
export { IgxDropLeaveEventArgs };
if (false) {
    /**
     * Reference to the original event that caused the draggable element to enter the igxDrop element.
     * Can be PointerEvent, TouchEvent or MouseEvent.
     * @type {?}
     */
    IgxDropLeaveEventArgs.prototype.originalEvent;
    /**
     * The owner igxDrop directive that triggered this event.
     * @type {?}
     */
    IgxDropLeaveEventArgs.prototype.owner;
    /**
     * The igxDrag directive instanced on an element that entered the area of the igxDrop element
     * @type {?}
     */
    IgxDropLeaveEventArgs.prototype.drag;
    /**
     * The data contained for the draggable element in igxDrag directive.
     * @type {?}
     */
    IgxDropLeaveEventArgs.prototype.dragData;
    /**
     * The initial position of the pointer on X axis when the dragged element began moving
     * @type {?}
     */
    IgxDropLeaveEventArgs.prototype.startX;
    /**
     * The initial position of the pointer on Y axis when the dragged element began moving
     * @type {?}
     */
    IgxDropLeaveEventArgs.prototype.startY;
    /**
     * The current position of the pointer on X axis when the event was triggered.
     * Note: The browser might trigger the event with some delay and pointer would be already inside the igxDrop.
     * @type {?}
     */
    IgxDropLeaveEventArgs.prototype.pageX;
    /**
     * The current position of the pointer on Y axis when the event was triggered.
     * Note: The browser might trigger the event with some delay and pointer would be already inside the igxDrop.
     * @type {?}
     */
    IgxDropLeaveEventArgs.prototype.pageY;
    /**
     * The current position of the pointer on X axis relative to the container that initializes the igxDrop.
     * Note: The browser might trigger the event with some delay and pointer would be already inside the igxDrop.
     * @type {?}
     */
    IgxDropLeaveEventArgs.prototype.offsetX;
    /**
     * The current position of the pointer on Y axis relative to the container that initializes the igxDrop.
     * Note: The browser might trigger the event with some delay and pointer would be already inside the igxDrop.
     * @type {?}
     */
    IgxDropLeaveEventArgs.prototype.offsetY;
}
var IgxDropEventArgs = /** @class */ (function () {
    function IgxDropEventArgs() {
    }
    return IgxDropEventArgs;
}());
export { IgxDropEventArgs };
if (false) {
    /**
     * Reference to the original event that caused the draggable element to enter the igxDrop element.
     * Can be PointerEvent, TouchEvent or MouseEvent.
     * @type {?}
     */
    IgxDropEventArgs.prototype.originalEvent;
    /**
     * The owner igxDrop directive that triggered this event.
     * @type {?}
     */
    IgxDropEventArgs.prototype.owner;
    /**
     * The igxDrag directive instanced on an element that entered the area of the igxDrop element
     * @type {?}
     */
    IgxDropEventArgs.prototype.drag;
    /**
     * The current position of the pointer on X axis relative to the container that initializes the igxDrop.
     * Note: The browser might trigger the event with some delay and pointer would be already inside the igxDrop.
     * @type {?}
     */
    IgxDropEventArgs.prototype.offsetX;
    /**
     * The current position of the pointer on Y axis relative to the container that initializes the igxDrop.
     * Note: The browser might trigger the event with some delay and pointer would be already inside the igxDrop.
     * @type {?}
     */
    IgxDropEventArgs.prototype.offsetY;
    /**
     * Whether the default drop behavior of the igxDrop directive should be canceled.
     * Note: If you implement custom behavior and you use `animateOnRelease` for the igxDrag make sure to call 'event.drag.dropFinished();'
     * to notify the igxDrag directive that it has been dropped so it animates properly.
     * @type {?}
     */
    IgxDropEventArgs.prototype.cancel;
}
/**
 * @record
 */
export function IDragBaseEventArgs() { }
if (false) {
    /**
     * Reference to the original event that caused the interaction with the element.
     * Can be PointerEvent, TouchEvent or MouseEvent.
     * @type {?}
     */
    IDragBaseEventArgs.prototype.originalEvent;
    /**
     * The owner igxDrag directive that triggered this event.
     * @type {?}
     */
    IDragBaseEventArgs.prototype.owner;
}
/**
 * @record
 */
export function IDragStartEventArgs() { }
if (false) {
    /**
     * Set if the the dragging should be canceled.
     * @type {?}
     */
    IDragStartEventArgs.prototype.cancel;
}
var IgxDragDirective = /** @class */ (function () {
    function IgxDragDirective(cdr, element, zone, renderer) {
        this.cdr = cdr;
        this.element = element;
        this.zone = zone;
        this.renderer = renderer;
        /**
         * An \@Input property that indicates when the drag should start
         * By default the drag starts after the draggable element is moved by 5px
         * ```html
         * <div igxDrag [dragTolerance]="100">
         *         <span>Drag Me!</span>
         * </div>
         * ```
         */
        this.dragTolerance = 5;
        /**
         * Sets a custom class that will be added to the `dragGhost` element.
         * ```html
         * <div igxDrag [ghostImageClass]="'dragGhost'">
         *         <span>Drag Me!</span>
         * </div>
         * ```
         */
        this.ghostImageClass = '';
        /**
         * An \@Input property that hides the draggable element.
         * By default it's set to false.
         * ```html
         * <div igxDrag [dragTolerance]="100" [hideBaseOnDrag]="'true'">
         *         <span>Drag Me!</span>
         * </div>
         * ```
         */
        this.hideBaseOnDrag = false;
        /**
         * An \@Input property that enables/disables the draggable element animation
         * when the element is released.
         * By default it's set to false.
         * ```html
         * <div igxDrag [animateOnRelease]="'true'">
         *         <span>Drag Me!</span>
         * </div>
         * ```
         */
        this.animateOnRelease = false;
        /**
         * An \@Input property that sets the element to which the dragged element will be appended.
         * By default it's set to null and the dragged element is appended to the body.
         * ```html
         * <div #hostDiv></div>
         * <div igxDrag [dragGhostHost]="hostDiv">
         *         <span>Drag Me!</span>
         * </div>
         * ```
         */
        this.dragGhostHost = null;
        /**
         * Event triggered when the draggable element drag starts.
         * ```html
         * <div igxDrag [animateOnRelease]="'true'" (dragStart)="onDragStart()">
         *         <span>Drag Me!</span>
         * </div>
         * ```
         * ```typescript
         * public onDragStart(){
         *      alert("The drag has stared!");
         * }
         * ```
         */
        this.dragStart = new EventEmitter();
        /**
         * Event triggered when the draggable element is released.
         * ```html
         * <div igxDrag [animateOnRelease]="'true'" (dragEnd)="onDragEnd()">
         *         <span>Drag Me!</span>
         * </div>
         * ```
         * ```typescript
         * public onDragEnd(){
         *      alert("The drag has ended!");
         * }
         * ```
         */
        this.dragEnd = new EventEmitter();
        /**
         * Event triggered after the draggable element is released and after its animation has finished.
         * ```html
         * <div igxDrag [animateOnRelease]="'true'" (returnMoveEnd)="onMoveEnd()">
         *         <span>Drag Me!</span>
         * </div>
         * ```
         * ```typescript
         * public onMoveEnd(){
         *      alert("The move has ended!");
         * }
         * ```
         */
        this.returnMoveEnd = new EventEmitter();
        /**
         * Event triggered when the draggable element is clicked.
         * ```html
         * <div igxDrag [animateOnRelease]="'true'" (dragClicked)="dragClicked()">
         *         <span>Drag Me!</span>
         * </div>
         * ```
         * ```typescript
         * public dragClicked(){
         *      alert("The elemented has been clicked!");
         * }
         * ```
         */
        this.dragClicked = new EventEmitter();
        /**
         * @hidden
         */
        this.touch = 'none';
        /**
         * @hidden
         */
        this.transitionProperty = 'top, left';
        /**
         * @hidden
         */
        this._visibility = 'visible';
        /**
         * @hidden
         */
        this.defaultReturnDuration = '0.5s';
        /**
         * @hidden
         */
        this._startX = 0;
        /**
         * @hidden
         */
        this._startY = 0;
        /**
         * @hidden
         */
        this._dragStarted = false;
        /**
         * @hidden
         */
        this._pointerDownId = null;
        /**
         * @hidden
         */
        this._clicked = false;
        /**
         * @hidden
         */
        this._lastDropArea = null;
        /**
         * @hidden
         */
        this._destroy = new Subject();
        /**
         * @hidden
         */
        this._removeOnDestroy = true;
    }
    Object.defineProperty(IgxDragDirective.prototype, "visible", {
        /**
         * Returns the visibility state of the draggable element.
         * ```typescript
         * @ViewChild("myDrag" ,{read: IgxDragDirective})
         * public myDrag: IgxDragDirective;
         * ngAfterViewInit(){
         *     let dragVisibilty = this.myDrag.visible;
         * }
         * ```
         */
        get: /**
         * Returns the visibility state of the draggable element.
         * ```typescript
         * \@ViewChild("myDrag" ,{read: IgxDragDirective})
         * public myDrag: IgxDragDirective;
         * ngAfterViewInit(){
         *     let dragVisibilty = this.myDrag.visible;
         * }
         * ```
         * @return {?}
         */
        function () {
            return this._visibility === 'visible';
        },
        /**
         * Sets the visibility of the draggable element.
         * ```typescript
         * @ViewChild("myDrag" ,{read: IgxDragDirective})
         * public myDrag: IgxDragDirective;
         * ngAfterViewInit(){
         *     this.myDrag.visible = false;
         * }
         * ```
         */
        set: /**
         * Sets the visibility of the draggable element.
         * ```typescript
         * \@ViewChild("myDrag" ,{read: IgxDragDirective})
         * public myDrag: IgxDragDirective;
         * ngAfterViewInit(){
         *     this.myDrag.visible = false;
         * }
         * ```
         * @param {?} bVisible
         * @return {?}
         */
        function (bVisible) {
            this._visibility = bVisible ? 'visible' : 'hidden';
            this.cdr.detectChanges();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxDragDirective.prototype, "left", {
        /**
         * @hidden
         */
        get: /**
         * @hidden
         * @return {?}
         */
        function () {
            return parseInt(this._dragGhost.style.left, 10);
        },
        /**
         * @hidden
         */
        set: /**
         * @hidden
         * @param {?} val
         * @return {?}
         */
        function (val) {
            var _this = this;
            requestAnimationFrame(function () {
                if (_this._dragGhost) {
                    _this._dragGhost.style.left = val + 'px';
                }
            });
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxDragDirective.prototype, "top", {
        /**
         * @hidden
         */
        get: /**
         * @hidden
         * @return {?}
         */
        function () {
            return parseInt(this._dragGhost.style.top, 10);
        },
        /**
         * @hidden
         */
        set: /**
         * @hidden
         * @param {?} val
         * @return {?}
         */
        function (val) {
            var _this = this;
            requestAnimationFrame(function () {
                if (_this._dragGhost) {
                    _this._dragGhost.style.top = val + 'px';
                }
            });
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxDragDirective.prototype, "pointerEventsEnabled", {
        /**
         * Returns if the browser supports pointer events.
         * ```typescript
         * @ViewChild("myDrag" ,{read: IgxDragDirective})
         * public myDrag: IgxDragDirective;
         * ngAfterViewInit(){
         *     let pointerEvents = this.myDrag.pointerEventsEnabled;
         * }
         * ```
         */
        get: /**
         * Returns if the browser supports pointer events.
         * ```typescript
         * \@ViewChild("myDrag" ,{read: IgxDragDirective})
         * public myDrag: IgxDragDirective;
         * ngAfterViewInit(){
         *     let pointerEvents = this.myDrag.pointerEventsEnabled;
         * }
         * ```
         * @return {?}
         */
        function () {
            return typeof PointerEvent !== 'undefined';
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxDragDirective.prototype, "touchEventsEnabled", {
        /**
         * Returns if the browser supports touch events.
         * ```typescript
         * @ViewChild("myDrag" ,{read: IgxDragDirective})
         * public myDrag: IgxDragDirective;
         * ngAfterViewInit(){
         *     let touchEvents = this.myDrag.pointerEventsEnabled;
         * }
         * ```
         */
        get: /**
         * Returns if the browser supports touch events.
         * ```typescript
         * \@ViewChild("myDrag" ,{read: IgxDragDirective})
         * public myDrag: IgxDragDirective;
         * ngAfterViewInit(){
         *     let touchEvents = this.myDrag.pointerEventsEnabled;
         * }
         * ```
         * @return {?}
         */
        function () {
            return 'ontouchstart' in window;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @hidden
     */
    /**
     * @hidden
     * @return {?}
     */
    IgxDragDirective.prototype.ngOnInit = /**
     * @hidden
     * @return {?}
     */
    function () {
        var _this = this;
        this.zone.runOutsideAngular(function () {
            if (_this.pointerEventsEnabled) {
                fromEvent(_this.element.nativeElement, 'pointerdown').pipe(takeUntil(_this._destroy))
                    .subscribe(function (res) { return _this.onPointerDown(res); });
                fromEvent(_this.element.nativeElement, 'pointermove').pipe(throttle(function () { return interval(0, animationFrameScheduler); }), takeUntil(_this._destroy)).subscribe(function (res) { return _this.onPointerMove(res); });
                fromEvent(_this.element.nativeElement, 'pointerup').pipe(takeUntil(_this._destroy))
                    .subscribe(function (res) { return _this.onPointerUp(res); });
            }
            else if (_this.touchEventsEnabled) {
                // We don't have pointer events and touch events. Use then mouse events.
                fromEvent(_this.element.nativeElement, 'touchstart').pipe(takeUntil(_this._destroy))
                    .subscribe(function (res) { return _this.onPointerDown(res); });
                fromEvent(document.defaultView, 'touchmove').pipe(throttle(function () { return interval(0, animationFrameScheduler); }), takeUntil(_this._destroy)).subscribe(function (res) { return _this.onPointerMove(res); });
                fromEvent(document.defaultView, 'touchend').pipe(takeUntil(_this._destroy))
                    .subscribe(function (res) { return _this.onPointerUp(res); });
            }
            else {
                // We don't have pointer events and touch events. Use then mouse events.
                fromEvent(_this.element.nativeElement, 'mousedown').pipe(takeUntil(_this._destroy))
                    .subscribe(function (res) { return _this.onPointerDown(res); });
                fromEvent(document.defaultView, 'mousemove').pipe(throttle(function () { return interval(0, animationFrameScheduler); }), takeUntil(_this._destroy)).subscribe(function (res) { return _this.onPointerMove(res); });
                fromEvent(document.defaultView, 'mouseup').pipe(takeUntil(_this._destroy))
                    .subscribe(function (res) { return _this.onPointerUp(res); });
            }
        });
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @return {?}
     */
    IgxDragDirective.prototype.ngOnDestroy = /**
     * @hidden
     * @return {?}
     */
    function () {
        this._destroy.next(true);
        this._destroy.complete();
        if (this._dragGhost && this._removeOnDestroy) {
            this._dragGhost.parentNode.removeChild(this._dragGhost);
            this._dragGhost = null;
        }
    };
    /**
     * @hidden
     * Method bound to the PointerDown event of the base element igxDrag is initialized.
     * @param event PointerDown event captured
     */
    /**
     * @hidden
     * Method bound to the PointerDown event of the base element igxDrag is initialized.
     * @param {?} event PointerDown event captured
     * @return {?}
     */
    IgxDragDirective.prototype.onPointerDown = /**
     * @hidden
     * Method bound to the PointerDown event of the base element igxDrag is initialized.
     * @param {?} event PointerDown event captured
     * @return {?}
     */
    function (event) {
        this._clicked = true;
        this._pointerDownId = event.pointerId;
        if (this.pointerEventsEnabled || !this.touchEventsEnabled) {
            // Check first for pointer events or non touch, because we can have pointer events and touch events at once.
            this._startX = event.pageX;
            this._startY = event.pageY;
        }
        else if (this.touchEventsEnabled) {
            this._startX = event.touches[0].pageX;
            this._startY = event.touches[0].pageY;
        }
        // Take margins because getBoundingClientRect() doesn't include margins of the element
        /** @type {?} */
        var marginTop = parseInt(document.defaultView.getComputedStyle(this.element.nativeElement)['margin-top'], 10);
        /** @type {?} */
        var marginLeft = parseInt(document.defaultView.getComputedStyle(this.element.nativeElement)['margin-left'], 10);
        this._dragOffsetX =
            (this._startX - this.element.nativeElement.getBoundingClientRect().left - this.getWindowScrollLeft()) + marginLeft;
        this._dragOffsetY =
            (this._startY - this.element.nativeElement.getBoundingClientRect().top - this.getWindowScrollTop()) + marginTop;
        this._dragStartX = this._startX - this._dragOffsetX;
        this._dragStartY = this._startY - this._dragOffsetY;
        // Set pointer capture so we detect pointermove even if mouse is out of bounds until dragGhost is created.
        if (this.pointerEventsEnabled) {
            this.element.nativeElement.setPointerCapture(this._pointerDownId);
        }
        else {
            this.element.nativeElement.focus();
            event.preventDefault();
        }
    };
    /**
     * @hidden
     * Perfmorm drag move logic when dragging and dispatching events if there is igxDrop under the pointer.
     * This method is bound at first at the base element.
     * If dragging starts and after the dragGhost is rendered the pointerId is reassigned to the dragGhost. Then this method is bound to it.
     * @param event PointerMove event captured
     */
    /**
     * @hidden
     * Perfmorm drag move logic when dragging and dispatching events if there is igxDrop under the pointer.
     * This method is bound at first at the base element.
     * If dragging starts and after the dragGhost is rendered the pointerId is reassigned to the dragGhost. Then this method is bound to it.
     * @param {?} event PointerMove event captured
     * @return {?}
     */
    IgxDragDirective.prototype.onPointerMove = /**
     * @hidden
     * Perfmorm drag move logic when dragging and dispatching events if there is igxDrop under the pointer.
     * This method is bound at first at the base element.
     * If dragging starts and after the dragGhost is rendered the pointerId is reassigned to the dragGhost. Then this method is bound to it.
     * @param {?} event PointerMove event captured
     * @return {?}
     */
    function (event) {
        var _this = this;
        if (this._clicked) {
            /** @type {?} */
            var dragStartArgs_1 = {
                originalEvent: event,
                owner: this,
                cancel: false
            };
            /** @type {?} */
            var pageX = void 0;
            /** @type {?} */
            var pageY = void 0;
            if (this.pointerEventsEnabled || !this.touchEventsEnabled) {
                // Check first for pointer events or non touch, because we can have pointer events and touch events at once.
                pageX = event.pageX;
                pageY = event.pageY;
            }
            else if (this.touchEventsEnabled) {
                pageX = event.touches[0].pageX;
                pageY = event.touches[0].pageY;
                // Prevent scrolling on touch while dragging
                event.preventDefault();
            }
            /** @type {?} */
            var totalMovedX = pageX - this._startX;
            /** @type {?} */
            var totalMovedY = pageY - this._startY;
            if (!this._dragStarted &&
                (Math.abs(totalMovedX) > this.dragTolerance || Math.abs(totalMovedY) > this.dragTolerance)) {
                this.zone.run(function () {
                    _this.dragStart.emit(dragStartArgs_1);
                });
                if (!dragStartArgs_1.cancel) {
                    this._dragStarted = true;
                    // We moved enough so dragGhost can be rendered and actual dragging to start.
                    this.createDragGhost(event);
                }
                return;
            }
            else if (!this._dragStarted) {
                return;
            }
            this.left = this._dragStartX + totalMovedX;
            this.top = this._dragStartY + totalMovedY;
            this.dispatchDragEvents(pageX, pageY, event);
        }
    };
    /**
     * @hidden
     * Perform drag end logic when releasing the dragGhost and dispatchind drop event if igxDrop is under the pointer.
     * This method is bound at first at the base element.
     * If dragging starts and after the dragGhost is rendered the pointerId is reassigned to the dragGhost. Then this method is bound to it.
     * @param event PointerUp event captured
     */
    /**
     * @hidden
     * Perform drag end logic when releasing the dragGhost and dispatchind drop event if igxDrop is under the pointer.
     * This method is bound at first at the base element.
     * If dragging starts and after the dragGhost is rendered the pointerId is reassigned to the dragGhost. Then this method is bound to it.
     * @param {?} event PointerUp event captured
     * @return {?}
     */
    IgxDragDirective.prototype.onPointerUp = /**
     * @hidden
     * Perform drag end logic when releasing the dragGhost and dispatchind drop event if igxDrop is under the pointer.
     * This method is bound at first at the base element.
     * If dragging starts and after the dragGhost is rendered the pointerId is reassigned to the dragGhost. Then this method is bound to it.
     * @param {?} event PointerUp event captured
     * @return {?}
     */
    function (event) {
        var _this = this;
        if (!this._clicked) {
            return;
        }
        /** @type {?} */
        var eventArgs = {
            originalEvent: event,
            owner: this
        };
        this._clicked = false;
        if (this._dragStarted) {
            if (this._lastDropArea && this._lastDropArea !== this.element.nativeElement) {
                if (!this.animateOnRelease) {
                    this.onTransitionEnd(null);
                }
                // dragging ended over a drop area. Call this after transition because onDrop might remove the element.
                this.dispatchDropEvent(event.pageX, event.pageY, event);
                // else the drop directive needs to call the dropFinished() method so the animation can perform
            }
            else if (this.animateOnRelease &&
                (this.left !== Math.floor(this._dragStartX) || this.top !== Math.floor(this._dragStartY))) {
                // If the start positions are the same as the current the transition will not execute.
                // return the ghost to start position before removing it. See onTransitionEnd.
                this._dragGhost.style.transitionDuration = this.defaultReturnDuration;
                this.left = this._dragStartX;
                this.top = this._dragStartY;
            }
            else {
                this.onTransitionEnd(null);
            }
            this.zone.run(function () {
                _this.dragEnd.emit(eventArgs);
            });
        }
        else {
            this.zone.run(function () {
                _this.dragClicked.emit(eventArgs);
            });
        }
    };
    /**
     * @hidden
     * Create dragGhost element - if a Node object is provided it creates a clone of that node,
     * otherwise it clones the host element.
     * Bind all needed events.
     * @param event Pointer event required when the dragGhost is being initialized.
     * @param node The Node object to be cloned.
     */
    /**
     * @hidden
     * Create dragGhost element - if a Node object is provided it creates a clone of that node,
     * otherwise it clones the host element.
     * Bind all needed events.
     * @protected
     * @param {?} event Pointer event required when the dragGhost is being initialized.
     * @param {?=} node The Node object to be cloned.
     * @return {?}
     */
    IgxDragDirective.prototype.createDragGhost = /**
     * @hidden
     * Create dragGhost element - if a Node object is provided it creates a clone of that node,
     * otherwise it clones the host element.
     * Bind all needed events.
     * @protected
     * @param {?} event Pointer event required when the dragGhost is being initialized.
     * @param {?=} node The Node object to be cloned.
     * @return {?}
     */
    function (event, node) {
        var _this = this;
        if (node === void 0) { node = null; }
        this._dragGhost = node ? node.cloneNode(true) : this.element.nativeElement.cloneNode(true);
        this._dragGhost.style.transitionDuration = '0.0s';
        this._dragGhost.style.position = 'absolute';
        /** @type {?} */
        var hostLeft = this.dragGhostHost ? this.dragGhostHost.getBoundingClientRect().left : 0;
        /** @type {?} */
        var hostTop = this.dragGhostHost ? this.dragGhostHost.getBoundingClientRect().top : 0;
        this._dragGhost.style.top = this._dragStartY - hostTop + 'px';
        this._dragGhost.style.left = this._dragStartX - hostLeft + 'px';
        if (this.ghostImageClass) {
            this.renderer.addClass(this._dragGhost, this.ghostImageClass);
        }
        if (this.dragGhostHost) {
            this.dragGhostHost.appendChild(this._dragGhost);
        }
        else {
            document.body.appendChild(this._dragGhost);
        }
        if (this.pointerEventsEnabled) {
            // The dragGhost takes control for moving and dragging after it has been shown.
            this._dragGhost.setPointerCapture(this._pointerDownId);
            this._dragGhost.addEventListener('pointermove', function (args) {
                _this.onPointerMove(args);
            });
            this._dragGhost.addEventListener('pointerup', function (args) {
                _this.onPointerUp(args);
            });
        }
        if (this.animateOnRelease) {
            // Transition animation when the dragGhost is released and it returns to it's original position.
            this._dragGhost.addEventListener('transitionend', function (args) {
                _this.onTransitionEnd(args);
            });
        }
        // Hide the base after the dragGhost is created, because otherwise the dragGhost will be not visible.
        if (this.hideBaseOnDrag) {
            this.visible = false;
        }
    };
    /**
     * @hidden
     * Dispatch custom igxDragEnter/igxDragLeave events based on current pointer position and if drop area is under.
     */
    /**
     * @hidden
     * Dispatch custom igxDragEnter/igxDragLeave events based on current pointer position and if drop area is under.
     * @protected
     * @param {?} pageX
     * @param {?} pageY
     * @param {?} originalEvent
     * @return {?}
     */
    IgxDragDirective.prototype.dispatchDragEvents = /**
     * @hidden
     * Dispatch custom igxDragEnter/igxDragLeave events based on current pointer position and if drop area is under.
     * @protected
     * @param {?} pageX
     * @param {?} pageY
     * @param {?} originalEvent
     * @return {?}
     */
    function (pageX, pageY, originalEvent) {
        /** @type {?} */
        var topDropArea;
        /** @type {?} */
        var eventArgs = {
            startX: this._startX,
            startY: this._startY,
            pageX: pageX,
            pageY: pageY,
            owner: this,
            originalEvent: originalEvent
        };
        /** @type {?} */
        var elementsFromPoint = this.getElementsAtPoint(pageX, pageY);
        for (var i = 0; i < elementsFromPoint.length; i++) {
            if (elementsFromPoint[i].getAttribute('droppable') === 'true' && elementsFromPoint[i] !== this._dragGhost) {
                topDropArea = elementsFromPoint[i];
                break;
            }
        }
        if (topDropArea) {
            this.dispatchEvent(topDropArea, 'igxDragOver', eventArgs);
        }
        if (topDropArea &&
            (!this._lastDropArea || (this._lastDropArea && this._lastDropArea !== topDropArea))) {
            if (this._lastDropArea) {
                this.dispatchEvent(this._lastDropArea, 'igxDragLeave', eventArgs);
            }
            this._lastDropArea = topDropArea;
            this.dispatchEvent(this._lastDropArea, 'igxDragEnter', eventArgs);
        }
        else if (!topDropArea && this._lastDropArea) {
            this.dispatchEvent(this._lastDropArea, 'igxDragLeave', eventArgs);
            this._lastDropArea = null;
        }
    };
    /**
     * @hidden
     * Dispatch custom igxDrop event based on current pointer position if there is last recorder drop area under the pointer.
     * Last recorder drop area is updated in @dispatchDragEvents method.
     */
    /**
     * @hidden
     * Dispatch custom igxDrop event based on current pointer position if there is last recorder drop area under the pointer.
     * Last recorder drop area is updated in \@dispatchDragEvents method.
     * @protected
     * @param {?} pageX
     * @param {?} pageY
     * @param {?} originalEvent
     * @return {?}
     */
    IgxDragDirective.prototype.dispatchDropEvent = /**
     * @hidden
     * Dispatch custom igxDrop event based on current pointer position if there is last recorder drop area under the pointer.
     * Last recorder drop area is updated in \@dispatchDragEvents method.
     * @protected
     * @param {?} pageX
     * @param {?} pageY
     * @param {?} originalEvent
     * @return {?}
     */
    function (pageX, pageY, originalEvent) {
        /** @type {?} */
        var eventArgs = {
            startX: this._startX,
            startY: this._startY,
            pageX: pageX,
            pageY: pageY,
            owner: this,
            originalEvent: originalEvent
        };
        this.dispatchEvent(this._lastDropArea, 'igxDrop', eventArgs);
        this.dispatchEvent(this._lastDropArea, 'igxDragLeave', eventArgs);
        this._lastDropArea = null;
    };
    /**
     * @hidden
     * Update relative positions
     */
    /**
     * @hidden
     * Update relative positions
     * @return {?}
     */
    IgxDragDirective.prototype.updateDragRelativePos = /**
     * @hidden
     * Update relative positions
     * @return {?}
     */
    function () {
        if (!this._dragGhost) {
            return;
        }
        // Calculate the new dragGhost position to remain where the mouse is, so it doesn't jump
        /** @type {?} */
        var totalDraggedX = this.left - this._dragStartX;
        /** @type {?} */
        var totalDraggedY = this.top - this._dragStartY;
        /** @type {?} */
        var newPosX = this.element.nativeElement.getBoundingClientRect().left;
        /** @type {?} */
        var newPosY = this.element.nativeElement.getBoundingClientRect().top;
        /** @type {?} */
        var diffStartX = this._dragStartX - newPosX;
        /** @type {?} */
        var diffStartY = this._dragStartY - newPosY;
        this.top = newPosX + totalDraggedX - diffStartX;
        this.left = newPosY + totalDraggedY - diffStartY;
    };
    /**
     * Informs the `igxDrag` directive that it has been dropped/released.
     * This should usully be called when `animateOnRelease` is set to `true`.
     * When canceling or defining custom drop logic this tells the igxDrag to update it's positions and
     * animate correctly to the new position.
     * ```typescript
     * public onDropElem(event) {
     *     // Function bound to the igxDrop directive event `onDrop`
     *     // This cancels the default drop logic of the `igxDrop`
     *     event.cancel = true;
     *     event.drag.dropFinished();
     * }
     * ```
     */
    /**
     * Informs the `igxDrag` directive that it has been dropped/released.
     * This should usully be called when `animateOnRelease` is set to `true`.
     * When canceling or defining custom drop logic this tells the igxDrag to update it's positions and
     * animate correctly to the new position.
     * ```typescript
     * public onDropElem(event) {
     *     // Function bound to the igxDrop directive event `onDrop`
     *     // This cancels the default drop logic of the `igxDrop`
     *     event.cancel = true;
     *     event.drag.dropFinished();
     * }
     * ```
     * @return {?}
     */
    IgxDragDirective.prototype.dropFinished = /**
     * Informs the `igxDrag` directive that it has been dropped/released.
     * This should usully be called when `animateOnRelease` is set to `true`.
     * When canceling or defining custom drop logic this tells the igxDrag to update it's positions and
     * animate correctly to the new position.
     * ```typescript
     * public onDropElem(event) {
     *     // Function bound to the igxDrop directive event `onDrop`
     *     // This cancels the default drop logic of the `igxDrop`
     *     event.cancel = true;
     *     event.drag.dropFinished();
     * }
     * ```
     * @return {?}
     */
    function () {
        if (this.animateOnRelease && this._dragGhost) {
            this.updateDragRelativePos();
            // Return the dragged element to the start. See onTransitionEnd next.
            // Take margins becuase getBoundingClientRect() doesn't include margins
            /** @type {?} */
            var marginTop = parseInt(document.defaultView.getComputedStyle(this.element.nativeElement)['margin-top'], 10);
            /** @type {?} */
            var marginLeft = parseInt(document.defaultView.getComputedStyle(this.element.nativeElement)['margin-left'], 10);
            /** @type {?} */
            var newPosX = this.element.nativeElement.getBoundingClientRect().left + this.getWindowScrollLeft();
            /** @type {?} */
            var newPosY = this.element.nativeElement.getBoundingClientRect().top + this.getWindowScrollTop();
            this._dragGhost.style.transitionDuration = this.defaultReturnDuration;
            this.left = newPosX - marginLeft;
            this.top = newPosY - marginTop;
        }
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    IgxDragDirective.prototype.onTransitionEnd = /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    function (event) {
        var _this = this;
        if (this._dragStarted && !this._clicked) {
            if (this.hideBaseOnDrag) {
                this.visible = true;
            }
            this._dragGhost.parentNode.removeChild(this._dragGhost);
            this._dragGhost = null;
            this.element.nativeElement.style.transitionDuration = '0.0s';
            this._dragStarted = false;
            this.zone.run(function () {
                _this.returnMoveEnd.emit({
                    originalEvent: event,
                    owner: _this
                });
            });
        }
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @protected
     * @param {?} pageX
     * @param {?} pageY
     * @return {?}
     */
    IgxDragDirective.prototype.getElementsAtPoint = /**
     * @hidden
     * @protected
     * @param {?} pageX
     * @param {?} pageY
     * @return {?}
     */
    function (pageX, pageY) {
        // correct the coordinates with the current scroll position, because
        // document.elementsFromPoint conider position within the current viewport
        // window.pageXOffset == window.scrollX; // always true
        // using window.pageXOffset for IE9 compatibility
        /** @type {?} */
        var viewPortX = pageX - window.pageXOffset;
        /** @type {?} */
        var viewPortY = pageY - window.pageYOffset;
        if (document['msElementsFromPoint']) {
            // Edge and IE special snowflakes
            return document['msElementsFromPoint'](viewPortX, viewPortY);
        }
        else {
            // Other browsers like Chrome, Firefox, Opera
            return document.elementsFromPoint(viewPortX, viewPortY);
        }
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @protected
     * @param {?} target
     * @param {?} eventName
     * @param {?} eventArgs
     * @return {?}
     */
    IgxDragDirective.prototype.dispatchEvent = /**
     * @hidden
     * @protected
     * @param {?} target
     * @param {?} eventName
     * @param {?} eventArgs
     * @return {?}
     */
    function (target, eventName, eventArgs) {
        // This way is IE11 compatible.
        /** @type {?} */
        var dragLeaveEvent = document.createEvent('CustomEvent');
        dragLeaveEvent.initCustomEvent(eventName, false, false, eventArgs);
        target.dispatchEvent(dragLeaveEvent);
        // Othersie can be used `target.dispatchEvent(new CustomEvent(eventName, eventArgs));`
    };
    /**
     * @protected
     * @return {?}
     */
    IgxDragDirective.prototype.getWindowScrollTop = /**
     * @protected
     * @return {?}
     */
    function () {
        return window.scrollY ? window.scrollY : (window.pageYOffset ? window.pageYOffset : 0);
    };
    /**
     * @protected
     * @return {?}
     */
    IgxDragDirective.prototype.getWindowScrollLeft = /**
     * @protected
     * @return {?}
     */
    function () {
        return window.scrollX ? window.scrollX : (window.pageXOffset ? window.pageXOffset : 0);
    };
    IgxDragDirective.decorators = [
        { type: Directive, args: [{
                    selector: '[igxDrag]'
                },] }
    ];
    /** @nocollapse */
    IgxDragDirective.ctorParameters = function () { return [
        { type: ChangeDetectorRef },
        { type: ElementRef },
        { type: NgZone },
        { type: Renderer2 }
    ]; };
    IgxDragDirective.propDecorators = {
        data: [{ type: Input, args: ['igxDrag',] }],
        dragTolerance: [{ type: Input }],
        ghostImageClass: [{ type: Input }],
        hideBaseOnDrag: [{ type: Input }],
        animateOnRelease: [{ type: Input }],
        dragGhostHost: [{ type: Input }],
        dragStart: [{ type: Output }],
        dragEnd: [{ type: Output }],
        returnMoveEnd: [{ type: Output }],
        dragClicked: [{ type: Output }],
        touch: [{ type: HostBinding, args: ['style.touchAction',] }],
        transitionProperty: [{ type: HostBinding, args: ['style.transitionProperty',] }],
        _visibility: [{ type: HostBinding, args: ['style.visibility',] }]
    };
    return IgxDragDirective;
}());
export { IgxDragDirective };
if (false) {
    /**
     * - Save data inside the `igxDrag` directive. This can be set when instancing `igxDrag` on an element.
     * ```html
     * <div [igxDrag]="{ source: myElement }"></div>
     * ```
     * @type {?}
     */
    IgxDragDirective.prototype.data;
    /**
     * An \@Input property that indicates when the drag should start
     * By default the drag starts after the draggable element is moved by 5px
     * ```html
     * <div igxDrag [dragTolerance]="100">
     *         <span>Drag Me!</span>
     * </div>
     * ```
     * @type {?}
     */
    IgxDragDirective.prototype.dragTolerance;
    /**
     * Sets a custom class that will be added to the `dragGhost` element.
     * ```html
     * <div igxDrag [ghostImageClass]="'dragGhost'">
     *         <span>Drag Me!</span>
     * </div>
     * ```
     * @type {?}
     */
    IgxDragDirective.prototype.ghostImageClass;
    /**
     * An \@Input property that hides the draggable element.
     * By default it's set to false.
     * ```html
     * <div igxDrag [dragTolerance]="100" [hideBaseOnDrag]="'true'">
     *         <span>Drag Me!</span>
     * </div>
     * ```
     * @type {?}
     */
    IgxDragDirective.prototype.hideBaseOnDrag;
    /**
     * An \@Input property that enables/disables the draggable element animation
     * when the element is released.
     * By default it's set to false.
     * ```html
     * <div igxDrag [animateOnRelease]="'true'">
     *         <span>Drag Me!</span>
     * </div>
     * ```
     * @type {?}
     */
    IgxDragDirective.prototype.animateOnRelease;
    /**
     * An \@Input property that sets the element to which the dragged element will be appended.
     * By default it's set to null and the dragged element is appended to the body.
     * ```html
     * <div #hostDiv></div>
     * <div igxDrag [dragGhostHost]="hostDiv">
     *         <span>Drag Me!</span>
     * </div>
     * ```
     * @type {?}
     */
    IgxDragDirective.prototype.dragGhostHost;
    /**
     * Event triggered when the draggable element drag starts.
     * ```html
     * <div igxDrag [animateOnRelease]="'true'" (dragStart)="onDragStart()">
     *         <span>Drag Me!</span>
     * </div>
     * ```
     * ```typescript
     * public onDragStart(){
     *      alert("The drag has stared!");
     * }
     * ```
     * @type {?}
     */
    IgxDragDirective.prototype.dragStart;
    /**
     * Event triggered when the draggable element is released.
     * ```html
     * <div igxDrag [animateOnRelease]="'true'" (dragEnd)="onDragEnd()">
     *         <span>Drag Me!</span>
     * </div>
     * ```
     * ```typescript
     * public onDragEnd(){
     *      alert("The drag has ended!");
     * }
     * ```
     * @type {?}
     */
    IgxDragDirective.prototype.dragEnd;
    /**
     * Event triggered after the draggable element is released and after its animation has finished.
     * ```html
     * <div igxDrag [animateOnRelease]="'true'" (returnMoveEnd)="onMoveEnd()">
     *         <span>Drag Me!</span>
     * </div>
     * ```
     * ```typescript
     * public onMoveEnd(){
     *      alert("The move has ended!");
     * }
     * ```
     * @type {?}
     */
    IgxDragDirective.prototype.returnMoveEnd;
    /**
     * Event triggered when the draggable element is clicked.
     * ```html
     * <div igxDrag [animateOnRelease]="'true'" (dragClicked)="dragClicked()">
     *         <span>Drag Me!</span>
     * </div>
     * ```
     * ```typescript
     * public dragClicked(){
     *      alert("The elemented has been clicked!");
     * }
     * ```
     * @type {?}
     */
    IgxDragDirective.prototype.dragClicked;
    /**
     * @hidden
     * @type {?}
     */
    IgxDragDirective.prototype.touch;
    /**
     * @hidden
     * @type {?}
     */
    IgxDragDirective.prototype.transitionProperty;
    /**
     * @hidden
     * @type {?}
     */
    IgxDragDirective.prototype._visibility;
    /**
     * @hidden
     * @type {?}
     */
    IgxDragDirective.prototype.defaultReturnDuration;
    /**
     * @hidden
     * @type {?}
     * @protected
     */
    IgxDragDirective.prototype._startX;
    /**
     * @hidden
     * @type {?}
     * @protected
     */
    IgxDragDirective.prototype._startY;
    /**
     * @hidden
     * @type {?}
     * @protected
     */
    IgxDragDirective.prototype._dragGhost;
    /**
     * @hidden
     * @type {?}
     * @protected
     */
    IgxDragDirective.prototype._dragStarted;
    /**
     * @hidden
     * @type {?}
     * @protected
     */
    IgxDragDirective.prototype._dragOffsetX;
    /**
     * @hidden
     * @type {?}
     * @protected
     */
    IgxDragDirective.prototype._dragOffsetY;
    /**
     * @hidden
     * @type {?}
     * @protected
     */
    IgxDragDirective.prototype._dragStartX;
    /**
     * @hidden
     * @type {?}
     * @protected
     */
    IgxDragDirective.prototype._dragStartY;
    /**
     * @hidden
     * @type {?}
     * @protected
     */
    IgxDragDirective.prototype._pointerDownId;
    /**
     * @hidden
     * @type {?}
     * @protected
     */
    IgxDragDirective.prototype._clicked;
    /**
     * @hidden
     * @type {?}
     * @protected
     */
    IgxDragDirective.prototype._lastDropArea;
    /**
     * @hidden
     * @type {?}
     * @protected
     */
    IgxDragDirective.prototype._destroy;
    /**
     * @hidden
     * @type {?}
     * @protected
     */
    IgxDragDirective.prototype._removeOnDestroy;
    /** @type {?} */
    IgxDragDirective.prototype.cdr;
    /** @type {?} */
    IgxDragDirective.prototype.element;
    /** @type {?} */
    IgxDragDirective.prototype.zone;
    /** @type {?} */
    IgxDragDirective.prototype.renderer;
}
var IgxDropDirective = /** @class */ (function () {
    function IgxDropDirective(element, _renderer, _zone) {
        this.element = element;
        this._renderer = _renderer;
        this._zone = _zone;
        /**
         * Event triggered when dragged element enters the area of the element.
         * ```html
         * <div class="cageArea" igxDrop (onEnter)="dragEnter()" (igxDragEnter)="onDragCageEnter()" (igxDragLeave)="onDragCageLeave()">
         * </div>
         * ```
         * ```typescript
         * public dragEnter(){
         *     alert("A draggable elemente has entered the chip area!");
         * }
         * ```
         */
        this.onEnter = new EventEmitter();
        /**
         * Event triggered when dragged element leaves the area of the element.
         * ```html
         * <div class="cageArea" igxDrop (onLeave)="dragLeave()" (igxDragEnter)="onDragCageEnter()" (igxDragLeave)="onDragCageLeave()">
         * </div>
         * ```
         * ```typescript
         * public dragLeave(){
         *     alert("A draggable elemente has left the chip area!");
         * }
         * ```
         */
        this.onLeave = new EventEmitter();
        /**
         * Event triggered when dragged element is dropped in the area of the element.
         * Since the `igxDrop` has default logic that appends the dropped element as a child, it can be canceled here.
         * To cancel the default logic the `cancel` property of the event needs to be set to true.
         * ```html
         * <div class="cageArea" igxDrop (onDrop)="dragDrop()" (igxDragEnter)="onDragCageEnter()" (igxDragLeave)="onDragCageLeave()">
         * </div>
         * ```
         * ```typescript
         * public dragDrop(){
         *     alert("A draggable elemente has been dropped in the chip area!");
         * }
         * ```
         */
        this.onDrop = new EventEmitter();
        /**
         * @hidden
         */
        this.droppable = true;
        /**
         * @hidden
         */
        this.dragover = false;
        /**
         * @hidden
         */
        this._destroy = new Subject();
    }
    /**
     * @return {?}
     */
    IgxDropDirective.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        this._zone.runOutsideAngular(function () {
            fromEvent(_this.element.nativeElement, 'igxDragEnter').pipe(takeUntil(_this._destroy))
                .subscribe(function (res) { return _this.onDragEnter((/** @type {?} */ (res))); });
            fromEvent(_this.element.nativeElement, 'igxDragLeave').pipe(takeUntil(_this._destroy)).subscribe(function (res) { return _this.onDragLeave(res); });
            fromEvent(_this.element.nativeElement, 'igxDragOver').pipe(takeUntil(_this._destroy)).subscribe(function (res) { return _this.onDragOver(res); });
        });
    };
    /**
     * @return {?}
     */
    IgxDropDirective.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this._destroy.next(true);
        this._destroy.complete();
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    IgxDropDirective.prototype.onDragOver = /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    function (event) { };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    IgxDropDirective.prototype.onDragEnter = /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    function (event) {
        var _this = this;
        this.dragover = true;
        /** @type {?} */
        var elementPosX = this.element.nativeElement.getBoundingClientRect().left + this.getWindowScrollLeft();
        /** @type {?} */
        var elementPosY = this.element.nativeElement.getBoundingClientRect().top + this.getWindowScrollTop();
        /** @type {?} */
        var offsetX = event.detail.pageX - elementPosX;
        /** @type {?} */
        var offsetY = event.detail.pageY - elementPosY;
        /** @type {?} */
        var eventArgs = {
            originalEvent: event.detail.originalEvent,
            owner: this,
            drag: event.detail.owner,
            dragData: event.detail.owner.data,
            startX: event.detail.startX,
            startY: event.detail.startY,
            pageX: event.detail.pageX,
            pageY: event.detail.pageY,
            offsetX: offsetX,
            offsetY: offsetY
        };
        this._zone.run(function () {
            _this.onEnter.emit(eventArgs);
        });
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    IgxDropDirective.prototype.onDragLeave = /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    function (event) {
        var _this = this;
        this.dragover = false;
        /** @type {?} */
        var elementPosX = this.element.nativeElement.getBoundingClientRect().left + this.getWindowScrollLeft();
        /** @type {?} */
        var elementPosY = this.element.nativeElement.getBoundingClientRect().top + this.getWindowScrollTop();
        /** @type {?} */
        var offsetX = event.detail.pageX - elementPosX;
        /** @type {?} */
        var offsetY = event.detail.pageY - elementPosY;
        /** @type {?} */
        var eventArgs = {
            originalEvent: event.detail.originalEvent,
            owner: this,
            drag: event.detail.owner,
            dragData: event.detail.owner.data,
            startX: event.detail.startX,
            startY: event.detail.startY,
            pageX: event.detail.pageX,
            pageY: event.detail.pageY,
            offsetX: offsetX,
            offsetY: offsetY
        };
        this._zone.run(function () {
            _this.onLeave.emit(eventArgs);
        });
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    IgxDropDirective.prototype.onDragDrop = /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    function (event) {
        var _this = this;
        /** @type {?} */
        var elementPosX = this.element.nativeElement.getBoundingClientRect().left + this.getWindowScrollLeft();
        /** @type {?} */
        var elementPosY = this.element.nativeElement.getBoundingClientRect().top + this.getWindowScrollTop();
        /** @type {?} */
        var offsetX = event.detail.pageX - elementPosX;
        /** @type {?} */
        var offsetY = event.detail.pageY - elementPosY;
        /** @type {?} */
        var args = {
            owner: this,
            originalEvent: event.detail.originalEvent,
            drag: event.detail.owner,
            offsetX: offsetX,
            offsetY: offsetY,
            cancel: false
        };
        this._zone.run(function () {
            _this.onDrop.emit(args);
        });
        if (!args.cancel) {
            // To do for generic scenario
            this._renderer.removeChild(event.detail.owner.element.nativeElement.parentNode, event.detail.owner.element.nativeElement);
            this._renderer.appendChild(this.element.nativeElement, event.detail.owner.element.nativeElement);
            setTimeout(function () {
                event.detail.owner.dropFinished();
            }, 0);
        }
    };
    /**
     * @protected
     * @return {?}
     */
    IgxDropDirective.prototype.getWindowScrollTop = /**
     * @protected
     * @return {?}
     */
    function () {
        return window.scrollY ? window.scrollY : (window.pageYOffset ? window.pageYOffset : 0);
    };
    /**
     * @protected
     * @return {?}
     */
    IgxDropDirective.prototype.getWindowScrollLeft = /**
     * @protected
     * @return {?}
     */
    function () {
        return window.scrollX ? window.scrollX : (window.pageXOffset ? window.pageXOffset : 0);
    };
    IgxDropDirective.decorators = [
        { type: Directive, args: [{
                    selector: '[igxDrop]'
                },] }
    ];
    /** @nocollapse */
    IgxDropDirective.ctorParameters = function () { return [
        { type: ElementRef },
        { type: Renderer2 },
        { type: NgZone }
    ]; };
    IgxDropDirective.propDecorators = {
        data: [{ type: Input, args: ['igxDrop',] }],
        onEnter: [{ type: Output }],
        onLeave: [{ type: Output }],
        onDrop: [{ type: Output }],
        droppable: [{ type: HostBinding, args: ['attr.droppable',] }],
        dragover: [{ type: HostBinding, args: ['class.dragOver',] }],
        onDragDrop: [{ type: HostListener, args: ['igxDrop', ['$event'],] }]
    };
    return IgxDropDirective;
}());
export { IgxDropDirective };
if (false) {
    /**
     * - Save data inside the `igxDrop` directive. This can be set when instancing `igxDrop` on an element.
     * ```html
     * <div [igxDrop]="{ source: myElement }"></div>
     * ```
     * @type {?}
     */
    IgxDropDirective.prototype.data;
    /**
     * Event triggered when dragged element enters the area of the element.
     * ```html
     * <div class="cageArea" igxDrop (onEnter)="dragEnter()" (igxDragEnter)="onDragCageEnter()" (igxDragLeave)="onDragCageLeave()">
     * </div>
     * ```
     * ```typescript
     * public dragEnter(){
     *     alert("A draggable elemente has entered the chip area!");
     * }
     * ```
     * @type {?}
     */
    IgxDropDirective.prototype.onEnter;
    /**
     * Event triggered when dragged element leaves the area of the element.
     * ```html
     * <div class="cageArea" igxDrop (onLeave)="dragLeave()" (igxDragEnter)="onDragCageEnter()" (igxDragLeave)="onDragCageLeave()">
     * </div>
     * ```
     * ```typescript
     * public dragLeave(){
     *     alert("A draggable elemente has left the chip area!");
     * }
     * ```
     * @type {?}
     */
    IgxDropDirective.prototype.onLeave;
    /**
     * Event triggered when dragged element is dropped in the area of the element.
     * Since the `igxDrop` has default logic that appends the dropped element as a child, it can be canceled here.
     * To cancel the default logic the `cancel` property of the event needs to be set to true.
     * ```html
     * <div class="cageArea" igxDrop (onDrop)="dragDrop()" (igxDragEnter)="onDragCageEnter()" (igxDragLeave)="onDragCageLeave()">
     * </div>
     * ```
     * ```typescript
     * public dragDrop(){
     *     alert("A draggable elemente has been dropped in the chip area!");
     * }
     * ```
     * @type {?}
     */
    IgxDropDirective.prototype.onDrop;
    /**
     * @hidden
     * @type {?}
     */
    IgxDropDirective.prototype.droppable;
    /**
     * @hidden
     * @type {?}
     */
    IgxDropDirective.prototype.dragover;
    /**
     * @hidden
     * @type {?}
     * @protected
     */
    IgxDropDirective.prototype._destroy;
    /** @type {?} */
    IgxDropDirective.prototype.element;
    /**
     * @type {?}
     * @private
     */
    IgxDropDirective.prototype._renderer;
    /**
     * @type {?}
     * @private
     */
    IgxDropDirective.prototype._zone;
}
/**
 * @hidden
 */
var IgxDragDropModule = /** @class */ (function () {
    function IgxDragDropModule() {
    }
    IgxDragDropModule.decorators = [
        { type: NgModule, args: [{
                    declarations: [IgxDragDirective, IgxDropDirective],
                    exports: [IgxDragDirective, IgxDropDirective]
                },] }
    ];
    return IgxDragDropModule;
}());
export { IgxDragDropModule };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZHJhZ2Ryb3AuZGlyZWN0aXZlLmpzIiwic291cmNlUm9vdCI6Im5nOi8vaWduaXRldWktYW5ndWxhci8iLCJzb3VyY2VzIjpbImxpYi9kaXJlY3RpdmVzL2RyYWdkcm9wL2RyYWdkcm9wLmRpcmVjdGl2ZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7O0FBQUEsT0FBTyxFQUNILFNBQVMsRUFDVCxVQUFVLEVBQ1YsWUFBWSxFQUNaLFdBQVcsRUFDWCxZQUFZLEVBQ1osS0FBSyxFQUNMLFFBQVEsRUFDUixNQUFNLEVBR04sTUFBTSxFQUNOLFNBQVMsRUFDVCxpQkFBaUIsRUFDcEIsTUFBTSxlQUFlLENBQUM7QUFDdkIsT0FBTyxFQUFFLHVCQUF1QixFQUFFLFNBQVMsRUFBRSxRQUFRLEVBQUUsT0FBTyxFQUFFLE1BQU0sTUFBTSxDQUFDO0FBQzdFLE9BQU8sRUFBRSxTQUFTLEVBQUUsUUFBUSxFQUFFLE1BQU0sZ0JBQWdCLENBQUM7OztJQUdqRCxhQUFVO0lBQ1YsZUFBWTtJQUNaLE9BQUk7Ozs7OztBQUdSO0lBQUE7SUFPQSxDQUFDO0lBQUQsZ0NBQUM7QUFBRCxDQUFDLEFBUEQsSUFPQzs7OztJQU5HLDJDQUFlOztJQUNmLDJDQUFlOztJQUNmLDBDQUFjOztJQUNkLDBDQUFjOztJQUNkLDBDQUF3Qjs7SUFDeEIsa0RBQW1COztBQUd2QjtJQUFBO0lBb0NBLENBQUM7SUFBRCw0QkFBQztBQUFELENBQUMsQUFwQ0QsSUFvQ0M7Ozs7Ozs7O0lBL0JHLDhDQUFtQjs7Ozs7SUFFbkIsc0NBQXdCOzs7OztJQUV4QixxQ0FBdUI7Ozs7O0lBRXZCLHlDQUFjOzs7OztJQUVkLHVDQUFlOzs7OztJQUVmLHVDQUFlOzs7Ozs7SUFLZixzQ0FBYzs7Ozs7O0lBS2Qsc0NBQWM7Ozs7OztJQUtkLHdDQUFnQjs7Ozs7O0lBS2hCLHdDQUFnQjs7QUFHcEI7SUFBQTtJQW9DQSxDQUFDO0lBQUQsNEJBQUM7QUFBRCxDQUFDLEFBcENELElBb0NDOzs7Ozs7OztJQS9CRyw4Q0FB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O0lBb0N2Qyx1QkFBQztDQUFBLEFBN0xELElBNkxDO1NBMUxZLGdCQUFnQjs7Ozs7Ozs7O0lBUXpCLGdDQUNpQjs7Ozs7Ozs7Ozs7Ozs7SUFhakIsbUNBQzJEOzs7Ozs7Ozs7Ozs7OztJQWEzRCxtQ0FDMkQ7Ozs7Ozs7Ozs7Ozs7Ozs7SUFlM0Qsa0NBQ3FEOzs7OztJQUtyRCxxQ0FDd0I7Ozs7O0lBS3hCLG9DQUN3Qjs7Ozs7O0lBS3hCLG9DQUE0Qzs7SUFFaEMsbUNBQTBCOzs7OztJQUFFLHFDQUE0Qjs7Ozs7SUFBRSxpQ0FBcUI7Ozs7O0FBd0gvRjtJQUFBO0lBSWlDLENBQUM7O2dCQUpqQyxRQUFRLFNBQUM7b0JBQ04sWUFBWSxFQUFFLENBQUMsZ0JBQWdCLEVBQUUsZ0JBQWdCLENBQUM7b0JBQ2xELE9BQU8sRUFBRSxDQUFDLGdCQUFnQixFQUFFLGdCQUFnQixDQUFDO2lCQUNoRDs7SUFDZ0Msd0JBQUM7Q0FBQSxBQUpsQyxJQUlrQztTQUFyQixpQkFBaUIiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xuICAgIERpcmVjdGl2ZSxcbiAgICBFbGVtZW50UmVmLFxuICAgIEV2ZW50RW1pdHRlcixcbiAgICBIb3N0QmluZGluZyxcbiAgICBIb3N0TGlzdGVuZXIsXG4gICAgSW5wdXQsXG4gICAgTmdNb2R1bGUsXG4gICAgTmdab25lLFxuICAgIE9uRGVzdHJveSxcbiAgICBPbkluaXQsXG4gICAgT3V0cHV0LFxuICAgIFJlbmRlcmVyMixcbiAgICBDaGFuZ2VEZXRlY3RvclJlZlxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IGFuaW1hdGlvbkZyYW1lU2NoZWR1bGVyLCBmcm9tRXZlbnQsIGludGVydmFsLCBTdWJqZWN0IH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyB0YWtlVW50aWwsIHRocm90dGxlIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuXG5leHBvcnQgZW51bSBSZXN0cmljdERyYWcge1xuICAgIFZFUlRJQ0FMTFksXG4gICAgSE9SSVpPTlRBTExZLFxuICAgIE5PTkVcbn1cblxuZXhwb3J0IGNsYXNzIElneERyYWdDdXN0b21FdmVudERldGFpbHMge1xuICAgIHN0YXJ0WDogbnVtYmVyO1xuICAgIHN0YXJ0WTogbnVtYmVyO1xuICAgIHBhZ2VYOiBudW1iZXI7XG4gICAgcGFnZVk6IG51bWJlcjtcbiAgICBvd25lcjogSWd4RHJhZ0RpcmVjdGl2ZTtcbiAgICBvcmlnaW5hbEV2ZW50OiBhbnk7XG59XG5cbmV4cG9ydCBjbGFzcyBJZ3hEcm9wRW50ZXJFdmVudEFyZ3Mge1xuICAgICAgICAvKipcbiAgICAgKiBSZWZlcmVuY2UgdG8gdGhlIG9yaWdpbmFsIGV2ZW50IHRoYXQgY2F1c2VkIHRoZSBkcmFnZ2FibGUgZWxlbWVudCB0byBlbnRlciB0aGUgaWd4RHJvcCBlbGVtZW50LlxuICAgICAqIENhbiBiZSBQb2ludGVyRXZlbnQsIFRvdWNoRXZlbnQgb3IgTW91c2VFdmVudC5cbiAgICAgKi9cbiAgICBvcmlnaW5hbEV2ZW50OiBhbnk7XG4gICAgLyoqIFRoZSBvd25lciBpZ3hEcm9wIGRpcmVjdGl2ZSB0aGF0IHRyaWdnZXJlZCB0aGlzIGV2ZW50LiAqL1xuICAgIG93bmVyOiBJZ3hEcm9wRGlyZWN0aXZlO1xuICAgIC8qKiBUaGUgaWd4RHJhZyBkaXJlY3RpdmUgaW5zdGFuY2VkIG9uIGFuIGVsZW1lbnQgdGhhdCBlbnRlcmVkIHRoZSBhcmVhIG9mIHRoZSBpZ3hEcm9wIGVsZW1lbnQgKi9cbiAgICBkcmFnOiBJZ3hEcmFnRGlyZWN0aXZlO1xuICAgIC8qKiBUaGUgZGF0YSBjb250YWluZWQgZm9yIHRoZSBkcmFnZ2FibGUgZWxlbWVudCBpbiBpZ3hEcmFnIGRpcmVjdGl2ZS4gKi9cbiAgICBkcmFnRGF0YTogYW55O1xuICAgIC8qKiBUaGUgaW5pdGlhbCBwb3NpdGlvbiBvZiB0aGUgcG9pbnRlciBvbiBYIGF4aXMgd2hlbiB0aGUgZHJhZ2dlZCBlbGVtZW50IGJlZ2FuIG1vdmluZyAqL1xuICAgIHN0YXJ0WDogbnVtYmVyO1xuICAgIC8qKiBUaGUgaW5pdGlhbCBwb3NpdGlvbiBvZiB0aGUgcG9pbnRlciBvbiBZIGF4aXMgd2hlbiB0aGUgZHJhZ2dlZCBlbGVtZW50IGJlZ2FuIG1vdmluZyAqL1xuICAgIHN0YXJ0WTogbnVtYmVyO1xuICAgIC8qKlxuICAgICAqIFRoZSBjdXJyZW50IHBvc2l0aW9uIG9mIHRoZSBwb2ludGVyIG9uIFggYXhpcyB3aGVuIHRoZSBldmVudCB3YXMgdHJpZ2dlcmVkLlxuICAgICAqIE5vdGU6IFRoZSBicm93c2VyIG1pZ2h0IHRyaWdnZXIgdGhlIGV2ZW50IHdpdGggc29tZSBkZWxheSBhbmQgcG9pbnRlciB3b3VsZCBiZSBhbHJlYWR5IGluc2lkZSB0aGUgaWd4RHJvcC5cbiAgICAgKi9cbiAgICBwYWdlWDogbnVtYmVyO1xuICAgIC8qKlxuICAgICAqIFRoZSBjdXJyZW50IHBvc2l0aW9uIG9mIHRoZSBwb2ludGVyIG9uIFkgYXhpcyB3aGVuIHRoZSBldmVudCB3YXMgdHJpZ2dlcmVkLlxuICAgICAqIE5vdGU6IFRoZSBicm93c2VyIG1pZ2h0IHRyaWdnZXIgdGhlIGV2ZW50IHdpdGggc29tZSBkZWxheSBhbmQgcG9pbnRlciB3b3VsZCBiZSBhbHJlYWR5IGluc2lkZSB0aGUgaWd4RHJvcC5cbiAgICAgKi9cbiAgICBwYWdlWTogbnVtYmVyO1xuICAgIC8qKlxuICAgICAqIFRoZSBjdXJyZW50IHBvc2l0aW9uIG9mIHRoZSBwb2ludGVyIG9uIFggYXhpcyByZWxhdGl2ZSB0byB0aGUgY29udGFpbmVyIHRoYXQgaW5pdGlhbGl6ZXMgdGhlIGlneERyb3AuXG4gICAgICogTm90ZTogVGhlIGJyb3dzZXIgbWlnaHQgdHJpZ2dlciB0aGUgZXZlbnQgd2l0aCBzb21lIGRlbGF5IGFuZCBwb2ludGVyIHdvdWxkIGJlIGFscmVhZHkgaW5zaWRlIHRoZSBpZ3hEcm9wLlxuICAgICAqL1xuICAgIG9mZnNldFg6IG51bWJlcjtcbiAgICAvKipcbiAgICAgKiBUaGUgY3VycmVudCBwb3NpdGlvbiBvZiB0aGUgcG9pbnRlciBvbiBZIGF4aXMgcmVsYXRpdmUgdG8gdGhlIGNvbnRhaW5lciB0aGF0IGluaXRpYWxpemVzIHRoZSBpZ3hEcm9wLlxuICAgICAqIE5vdGU6IFRoZSBicm93c2VyIG1pZ2h0IHRyaWdnZXIgdGhlIGV2ZW50IHdpdGggc29tZSBkZWxheSBhbmQgcG9pbnRlciB3b3VsZCBiZSBhbHJlYWR5IGluc2lkZSB0aGUgaWd4RHJvcC5cbiAgICAgKi9cbiAgICBvZmZzZXRZOiBudW1iZXI7XG59XG5cbmV4cG9ydCBjbGFzcyBJZ3hEcm9wTGVhdmVFdmVudEFyZ3Mge1xuICAgIC8qKlxuICAgICAqIFJlZmVyZW5jZSB0byB0aGUgb3JpZ2luYWwgZXZlbnQgdGhhdCBjYXVzZWQgdGhlIGRyYWdnYWJsZSBlbGVtZW50IHRvIGVudGVyIHRoZSBpZ3hEcm9wIGVsZW1lbnQuXG4gICAgICogQ2FuIGJlIFBvaW50ZXJFdmVudCwgVG91Y2hFdmVudCBvciBNb3VzZUV2ZW50LlxuICAgICAqL1xuICAgIG9yaWdpbmFsRXZlbnQ6IGFueTtcbiAgICAvKiogVGhlIG93bmVyIGlneERyb3AgZGlyZWN0aXZlIHRoYXQgdHJpZ2dlcmVkIHRoaXMgZXZlbnQuICovXG4gICAgb3duZXI6IElneERyb3BEaXJlY3RpdmU7XG4gICAgLyoqIFRoZSBpZ3hEcmFnIGRpcmVjdGl2ZSBpbnN0YW5jZWQgb24gYW4gZWxlbWVudCB0aGF0IGVudGVyZWQgdGhlIGFyZWEgb2YgdGhlIGlneERyb3AgZWxlbWVudCAqL1xuICAgIGRyYWc6IElneERyYWdEaXJlY3RpdmU7XG4gICAgLyoqIFRoZSBkYXRhIGNvbnRhaW5lZCBmb3IgdGhlIGRyYWdnYWJsZSBlbGVtZW50IGluIGlneERyYWcgZGlyZWN0aXZlLiAqL1xuICAgIGRyYWdEYXRhOiBhbnk7XG4gICAgLyoqIFRoZSBpbml0aWFsIHBvc2l0aW9uIG9mIHRoZSBwb2ludGVyIG9uIFggYXhpcyB3aGVuIHRoZSBkcmFnZ2VkIGVsZW1lbnQgYmVnYW4gbW92aW5nICovXG4gICAgc3RhcnRYOiBudW1iZXI7XG4gICAgLyoqIFRoZSBpbml0aWFsIHBvc2l0aW9uIG9mIHRoZSBwb2ludGVyIG9uIFkgYXhpcyB3aGVuIHRoZSBkcmFnZ2VkIGVsZW1lbnQgYmVnYW4gbW92aW5nICovXG4gICAgc3RhcnRZOiBudW1iZXI7XG4gICAgLyoqXG4gICAgICogVGhlIGN1cnJlbnQgcG9zaXRpb24gb2YgdGhlIHBvaW50ZXIgb24gWCBheGlzIHdoZW4gdGhlIGV2ZW50IHdhcyB0cmlnZ2VyZWQuXG4gICAgICogTm90ZTogVGhlIGJyb3dzZXIgbWlnaHQgdHJpZ2dlciB0aGUgZXZlbnQgd2l0aCBzb21lIGRlbGF5IGFuZCBwb2ludGVyIHdvdWxkIGJlIGFscmVhZHkgaW5zaWRlIHRoZSBpZ3hEcm9wLlxuICAgICAqL1xuICAgIHBhZ2VYOiBudW1iZXI7XG4gICAgICAgIC8qKlxuICAgICAqIFRoZSBjdXJyZW50IHBvc2l0aW9uIG9mIHRoZSBwb2ludGVyIG9uIFkgYXhpcyB3aGVuIHRoZSBldmVudCB3YXMgdHJpZ2dlcmVkLlxuICAgICAqIE5vdGU6IFRoZSBicm93c2VyIG1pZ2h0IHRyaWdnZXIgdGhlIGV2ZW50IHdpdGggc29tZSBkZWxheSBhbmQgcG9pbnRlciB3b3VsZCBiZSBhbHJlYWR5IGluc2lkZSB0aGUgaWd4RHJvcC5cbiAgICAgKi9cbiAgICBwYWdlWTogbnVtYmVyO1xuICAgIC8qKlxuICAgICAqIFRoZSBjdXJyZW50IHBvc2l0aW9uIG9mIHRoZSBwb2ludGVyIG9uIFggYXhpcyByZWxhdGl2ZSB0byB0aGUgY29udGFpbmVyIHRoYXQgaW5pdGlhbGl6ZXMgdGhlIGlneERyb3AuXG4gICAgICogTm90ZTogVGhlIGJyb3dzZXIgbWlnaHQgdHJpZ2dlciB0aGUgZXZlbnQgd2l0aCBzb21lIGRlbGF5IGFuZCBwb2ludGVyIHdvdWxkIGJlIGFscmVhZHkgaW5zaWRlIHRoZSBpZ3hEcm9wLlxuICAgICAqL1xuICAgIG9mZnNldFg6IG51bWJlcjtcbiAgICAvKipcbiAgICAgKiBUaGUgY3VycmVudCBwb3NpdGlvbiBvZiB0aGUgcG9pbnRlciBvbiBZIGF4aXMgcmVsYXRpdmUgdG8gdGhlIGNvbnRhaW5lciB0aGF0IGluaXRpYWxpemVzIHRoZSBpZ3hEcm9wLlxuICAgICAqIE5vdGU6IFRoZSBicm93c2VyIG1pZ2h0IHRyaWdnZXIgdGhlIGV2ZW50IHdpdGggc29tZSBkZWxheSBhbmQgcG9pbnRlciB3b3VsZCBiZSBhbHJlYWR5IGluc2lkZSB0aGUgaWd4RHJvcC5cbiAgICAgKi9cbiAgICBvZmZzZXRZOiBudW1iZXI7XG59XG5cbmV4cG9ydCBjbGFzcyBJZ3hEcm9wRXZlbnRBcmdzIHtcbiAgICAvKipcbiAgICAgKiBSZWZlcmVuY2UgdG8gdGhlIG9yaWdpbmFsIGV2ZW50IHRoYXQgY2F1c2VkIHRoZSBkcmFnZ2FibGUgZWxlbWVudCB0byBlbnRlciB0aGUgaWd4RHJvcCBlbGVtZW50LlxuICAgICAqIENhbiBiZSBQb2ludGVyRXZlbnQsIFRvdWNoRXZlbnQgb3IgTW91c2VFdmVudC5cbiAgICAgKi9cbiAgICBvcmlnaW5hbEV2ZW50OiBhbnk7XG4gICAgLyoqIFRoZSBvd25lciBpZ3hEcm9wIGRpcmVjdGl2ZSB0aGF0IHRyaWdnZXJlZCB0aGlzIGV2ZW50LiAqL1xuICAgIG93bmVyOiBJZ3hEcm9wRGlyZWN0aXZlO1xuICAgIC8qKiBUaGUgaWd4RHJhZyBkaXJlY3RpdmUgaW5zdGFuY2VkIG9uIGFuIGVsZW1lbnQgdGhhdCBlbnRlcmVkIHRoZSBhcmVhIG9mIHRoZSBpZ3hEcm9wIGVsZW1lbnQgKi9cbiAgICBkcmFnOiBJZ3hEcmFnRGlyZWN0aXZlO1xuICAgIC8qKlxuICAgICAqIFRoZSBjdXJyZW50IHBvc2l0aW9uIG9mIHRoZSBwb2ludGVyIG9uIFggYXhpcyByZWxhdGl2ZSB0byB0aGUgY29udGFpbmVyIHRoYXQgaW5pdGlhbGl6ZXMgdGhlIGlneERyb3AuXG4gICAgICogTm90ZTogVGhlIGJyb3dzZXIgbWlnaHQgdHJpZ2dlciB0aGUgZXZlbnQgd2l0aCBzb21lIGRlbGF5IGFuZCBwb2ludGVyIHdvdWxkIGJlIGFscmVhZHkgaW5zaWRlIHRoZSBpZ3hEcm9wLlxuICAgICAqL1xuICAgIG9mZnNldFg6IG51bWJlcjtcbiAgICAvKipcbiAgICAgKiBUaGUgY3VycmVudCBwb3NpdGlvbiBvZiB0aGUgcG9pbnRlciBvbiBZIGF4aXMgcmVsYXRpdmUgdG8gdGhlIGNvbnRhaW5lciB0aGF0IGluaXRpYWxpemVzIHRoZSBpZ3hEcm9wLlxuICAgICAqIE5vdGU6IFRoZSBicm93c2VyIG1pZ2h0IHRyaWdnZXIgdGhlIGV2ZW50IHdpdGggc29tZSBkZWxheSBhbmQgcG9pbnRlciB3b3VsZCBiZSBhbHJlYWR5IGluc2lkZSB0aGUgaWd4RHJvcC5cbiAgICAgKi9cbiAgICBvZmZzZXRZOiBudW1iZXI7XG4gICAgLyoqXG4gICAgICogV2hldGhlciB0aGUgZGVmYXVsdCBkcm9wIGJlaGF2aW9yIG9mIHRoZSBpZ3hEcm9wIGRpcmVjdGl2ZSBzaG91bGQgYmUgY2FuY2VsZWQuXG4gICAgICogTm90ZTogSWYgeW91IGltcGxlbWVudCBjdXN0b20gYmVoYXZpb3IgYW5kIHlvdSB1c2UgYGFuaW1hdGVPblJlbGVhc2VgIGZvciB0aGUgaWd4RHJhZyBtYWtlIHN1cmUgdG8gY2FsbCAnZXZlbnQuZHJhZy5kcm9wRmluaXNoZWQoKTsnXG4gICAgICogdG8gbm90aWZ5IHRoZSBpZ3hEcmFnIGRpcmVjdGl2ZSB0aGF0IGl0IGhhcyBiZWVuIGRyb3BwZWQgc28gaXQgYW5pbWF0ZXMgcHJvcGVybHkuXG4gICAgICovXG4gICAgY2FuY2VsOiBib29sZWFuO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIElEcmFnQmFzZUV2ZW50QXJncyB7XG4gICAgLyoqXG4gICAgICogUmVmZXJlbmNlIHRvIHRoZSBvcmlnaW5hbCBldmVudCB0aGF0IGNhdXNlZCB0aGUgaW50ZXJhY3Rpb24gd2l0aCB0aGUgZWxlbWVudC5cbiAgICAgKiBDYW4gYmUgUG9pbnRlckV2ZW50LCBUb3VjaEV2ZW50IG9yIE1vdXNlRXZlbnQuXG4gICAgICovXG4gICAgb3JpZ2luYWxFdmVudDogUG9pbnRlckV2ZW50IHwgTW91c2VFdmVudCB8IFRvdWNoRXZlbnQ7XG4gICAgLyoqIFRoZSBvd25lciBpZ3hEcmFnIGRpcmVjdGl2ZSB0aGF0IHRyaWdnZXJlZCB0aGlzIGV2ZW50LiAqL1xuICAgIG93bmVyOiBJZ3hEcmFnRGlyZWN0aXZlO1xufVxuZXhwb3J0IGludGVyZmFjZSBJRHJhZ1N0YXJ0RXZlbnRBcmdzIGV4dGVuZHMgSURyYWdCYXNlRXZlbnRBcmdzIHtcbiAgICAvKiogU2V0IGlmIHRoZSB0aGUgZHJhZ2dpbmcgc2hvdWxkIGJlIGNhbmNlbGVkLiAqL1xuICAgIGNhbmNlbDogYm9vbGVhbjtcbn1cblxuQERpcmVjdGl2ZSh7XG4gICAgc2VsZWN0b3I6ICdbaWd4RHJhZ10nXG59KVxuZXhwb3J0IGNsYXNzIElneERyYWdEaXJlY3RpdmUgaW1wbGVtZW50cyBPbkluaXQsIE9uRGVzdHJveSB7XG5cbiAgICAvKipcbiAgICAgKiAtIFNhdmUgZGF0YSBpbnNpZGUgdGhlIGBpZ3hEcmFnYCBkaXJlY3RpdmUuIFRoaXMgY2FuIGJlIHNldCB3aGVuIGluc3RhbmNpbmcgYGlneERyYWdgIG9uIGFuIGVsZW1lbnQuXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxkaXYgW2lneERyYWddPVwieyBzb3VyY2U6IG15RWxlbWVudCB9XCI+PC9kaXY+XG4gICAgICogYGBgXG4gICAgICovXG4gICAgQElucHV0KCdpZ3hEcmFnJylcbiAgICBwdWJsaWMgZGF0YTogYW55O1xuXG4gICAgLyoqXG4gICAgICogQW4gQElucHV0IHByb3BlcnR5IHRoYXQgaW5kaWNhdGVzIHdoZW4gdGhlIGRyYWcgc2hvdWxkIHN0YXJ0XG4gICAgICogQnkgZGVmYXVsdCB0aGUgZHJhZyBzdGFydHMgYWZ0ZXIgdGhlIGRyYWdnYWJsZSBlbGVtZW50IGlzIG1vdmVkIGJ5IDVweFxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8ZGl2IGlneERyYWcgW2RyYWdUb2xlcmFuY2VdPVwiMTAwXCI+XG4gICAgICogICAgICAgICA8c3Bhbj5EcmFnIE1lITwvc3Bhbj5cbiAgICAgKiA8L2Rpdj5cbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHB1YmxpYyBkcmFnVG9sZXJhbmNlID0gNTtcblxuICAgIC8qKlxuICAgICAqIFNldHMgYSBjdXN0b20gY2xhc3MgdGhhdCB3aWxsIGJlIGFkZGVkIHRvIHRoZSBgZHJhZ0dob3N0YCBlbGVtZW50LlxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8ZGl2IGlneERyYWcgW2dob3N0SW1hZ2VDbGFzc109XCInZHJhZ0dob3N0J1wiPlxuICAgICAqICAgICAgICAgPHNwYW4+RHJhZyBNZSE8L3NwYW4+XG4gICAgICogPC9kaXY+XG4gICAgICogYGBgXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBwdWJsaWMgZ2hvc3RJbWFnZUNsYXNzID0gJyc7XG5cbiAgICAvKipcbiAgICAgKiBBbiBASW5wdXQgcHJvcGVydHkgdGhhdCBoaWRlcyB0aGUgZHJhZ2dhYmxlIGVsZW1lbnQuXG4gICAgICogQnkgZGVmYXVsdCBpdCdzIHNldCB0byBmYWxzZS5cbiAgICAgKiBgYGBodG1sXG4gICAgICogPGRpdiBpZ3hEcmFnIFtkcmFnVG9sZXJhbmNlXT1cIjEwMFwiIFtoaWRlQmFzZU9uRHJhZ109XCIndHJ1ZSdcIj5cbiAgICAgKiAgICAgICAgIDxzcGFuPkRyYWcgTWUhPC9zcGFuPlxuICAgICAqIDwvZGl2PlxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgcHVibGljIGhpZGVCYXNlT25EcmFnID0gZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBBbiBASW5wdXQgcHJvcGVydHkgdGhhdCBlbmFibGVzL2Rpc2FibGVzIHRoZSBkcmFnZ2FibGUgZWxlbWVudCBhbmltYXRpb25cbiAgICAgKiB3aGVuIHRoZSBlbGVtZW50IGlzIHJlbGVhc2VkLlxuICAgICAqIEJ5IGRlZmF1bHQgaXQncyBzZXQgdG8gZmFsc2UuXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxkaXYgaWd4RHJhZyBbYW5pbWF0ZU9uUmVsZWFzZV09XCIndHJ1ZSdcIj5cbiAgICAgKiAgICAgICAgIDxzcGFuPkRyYWcgTWUhPC9zcGFuPlxuICAgICAqIDwvZGl2PlxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgcHVibGljIGFuaW1hdGVPblJlbGVhc2UgPSBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqIEFuIEBJbnB1dCBwcm9wZXJ0eSB0aGF0IHNldHMgdGhlIGVsZW1lbnQgdG8gd2hpY2ggdGhlIGRyYWdnZWQgZWxlbWVudCB3aWxsIGJlIGFwcGVuZGVkLlxuICAgICAqIEJ5IGRlZmF1bHQgaXQncyBzZXQgdG8gbnVsbCBhbmQgdGhlIGRyYWdnZWQgZWxlbWVudCBpcyBhcHBlbmRlZCB0byB0aGUgYm9keS5cbiAgICAgKiBgYGBodG1sXG4gICAgICogPGRpdiAjaG9zdERpdj48L2Rpdj5cbiAgICAgKiA8ZGl2IGlneERyYWcgW2RyYWdHaG9zdEhvc3RdPVwiaG9zdERpdlwiPlxuICAgICAqICAgICAgICAgPHNwYW4+RHJhZyBNZSE8L3NwYW4+XG4gICAgICogPC9kaXY+XG4gICAgICogYGBgXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBwdWJsaWMgZHJhZ0dob3N0SG9zdCA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBFdmVudCB0cmlnZ2VyZWQgd2hlbiB0aGUgZHJhZ2dhYmxlIGVsZW1lbnQgZHJhZyBzdGFydHMuXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxkaXYgaWd4RHJhZyBbYW5pbWF0ZU9uUmVsZWFzZV09XCIndHJ1ZSdcIiAoZHJhZ1N0YXJ0KT1cIm9uRHJhZ1N0YXJ0KClcIj5cbiAgICAgKiAgICAgICAgIDxzcGFuPkRyYWcgTWUhPC9zcGFuPlxuICAgICAqIDwvZGl2PlxuICAgICAqIGBgYFxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBwdWJsaWMgb25EcmFnU3RhcnQoKXtcbiAgICAgKiAgICAgIGFsZXJ0KFwiVGhlIGRyYWcgaGFzIHN0YXJlZCFcIik7XG4gICAgICogfVxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIEBPdXRwdXQoKVxuICAgIHB1YmxpYyBkcmFnU3RhcnQgPSBuZXcgRXZlbnRFbWl0dGVyPElEcmFnU3RhcnRFdmVudEFyZ3M+KCk7XG5cbiAgICAvKipcbiAgICAgKiBFdmVudCB0cmlnZ2VyZWQgd2hlbiB0aGUgZHJhZ2dhYmxlIGVsZW1lbnQgaXMgcmVsZWFzZWQuXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxkaXYgaWd4RHJhZyBbYW5pbWF0ZU9uUmVsZWFzZV09XCIndHJ1ZSdcIiAoZHJhZ0VuZCk9XCJvbkRyYWdFbmQoKVwiPlxuICAgICAqICAgICAgICAgPHNwYW4+RHJhZyBNZSE8L3NwYW4+XG4gICAgICogPC9kaXY+XG4gICAgICogYGBgXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIHB1YmxpYyBvbkRyYWdFbmQoKXtcbiAgICAgKiAgICAgIGFsZXJ0KFwiVGhlIGRyYWcgaGFzIGVuZGVkIVwiKTtcbiAgICAgKiB9XG4gICAgICogYGBgXG4gICAgICovXG4gICAgQE91dHB1dCgpXG4gICAgcHVibGljIGRyYWdFbmQgPSBuZXcgRXZlbnRFbWl0dGVyPElEcmFnQmFzZUV2ZW50QXJncz4oKTtcblxuICAgIC8qKlxuICAgICAqIEV2ZW50IHRyaWdnZXJlZCBhZnRlciB0aGUgZHJhZ2dhYmxlIGVsZW1lbnQgaXMgcmVsZWFzZWQgYW5kIGFmdGVyIGl0cyBhbmltYXRpb24gaGFzIGZpbmlzaGVkLlxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8ZGl2IGlneERyYWcgW2FuaW1hdGVPblJlbGVhc2VdPVwiJ3RydWUnXCIgKHJldHVybk1vdmVFbmQpPVwib25Nb3ZlRW5kKClcIj5cbiAgICAgKiAgICAgICAgIDxzcGFuPkRyYWcgTWUhPC9zcGFuPlxuICAgICAqIDwvZGl2PlxuICAgICAqIGBgYFxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBwdWJsaWMgb25Nb3ZlRW5kKCl7XG4gICAgICogICAgICBhbGVydChcIlRoZSBtb3ZlIGhhcyBlbmRlZCFcIik7XG4gICAgICogfVxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIEBPdXRwdXQoKVxuICAgIHB1YmxpYyByZXR1cm5Nb3ZlRW5kID0gbmV3IEV2ZW50RW1pdHRlcjxJRHJhZ0Jhc2VFdmVudEFyZ3M+KCk7XG5cbiAgICAvKipcbiAgICAgKiBFdmVudCB0cmlnZ2VyZWQgd2hlbiB0aGUgZHJhZ2dhYmxlIGVsZW1lbnQgaXMgY2xpY2tlZC5cbiAgICAgKiBgYGBodG1sXG4gICAgICogPGRpdiBpZ3hEcmFnIFthbmltYXRlT25SZWxlYXNlXT1cIid0cnVlJ1wiIChkcmFnQ2xpY2tlZCk9XCJkcmFnQ2xpY2tlZCgpXCI+XG4gICAgICogICAgICAgICA8c3Bhbj5EcmFnIE1lITwvc3Bhbj5cbiAgICAgKiA8L2Rpdj5cbiAgICAgKiBgYGBcbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogcHVibGljIGRyYWdDbGlja2VkKCl7XG4gICAgICogICAgICBhbGVydChcIlRoZSBlbGVtZW50ZWQgaGFzIGJlZW4gY2xpY2tlZCFcIik7XG4gICAgICogfVxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIEBPdXRwdXQoKVxuICAgIHB1YmxpYyBkcmFnQ2xpY2tlZCA9IG5ldyBFdmVudEVtaXR0ZXI8SURyYWdCYXNlRXZlbnRBcmdzPigpO1xuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIEBIb3N0QmluZGluZygnc3R5bGUudG91Y2hBY3Rpb24nKVxuICAgIHB1YmxpYyB0b3VjaCA9ICdub25lJztcblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBASG9zdEJpbmRpbmcoJ3N0eWxlLnRyYW5zaXRpb25Qcm9wZXJ0eScpXG4gICAgcHVibGljIHRyYW5zaXRpb25Qcm9wZXJ0eSA9ICd0b3AsIGxlZnQnO1xuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIEBIb3N0QmluZGluZygnc3R5bGUudmlzaWJpbGl0eScpXG4gICAgcHVibGljIF92aXNpYmlsaXR5ID0gJ3Zpc2libGUnO1xuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgdmlzaWJpbGl0eSBvZiB0aGUgZHJhZ2dhYmxlIGVsZW1lbnQuXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIEBWaWV3Q2hpbGQoXCJteURyYWdcIiAse3JlYWQ6IElneERyYWdEaXJlY3RpdmV9KVxuICAgICAqIHB1YmxpYyBteURyYWc6IElneERyYWdEaXJlY3RpdmU7XG4gICAgICogbmdBZnRlclZpZXdJbml0KCl7XG4gICAgICogICAgIHRoaXMubXlEcmFnLnZpc2libGUgPSBmYWxzZTtcbiAgICAgKiB9XG4gICAgICogYGBgXG4gICAgICovXG4gICAgcHVibGljIHNldCB2aXNpYmxlKGJWaXNpYmxlKSB7XG4gICAgICAgIHRoaXMuX3Zpc2liaWxpdHkgPSBiVmlzaWJsZSA/ICd2aXNpYmxlJyA6ICdoaWRkZW4nO1xuICAgICAgICB0aGlzLmNkci5kZXRlY3RDaGFuZ2VzKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgdmlzaWJpbGl0eSBzdGF0ZSBvZiB0aGUgZHJhZ2dhYmxlIGVsZW1lbnQuXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIEBWaWV3Q2hpbGQoXCJteURyYWdcIiAse3JlYWQ6IElneERyYWdEaXJlY3RpdmV9KVxuICAgICAqIHB1YmxpYyBteURyYWc6IElneERyYWdEaXJlY3RpdmU7XG4gICAgICogbmdBZnRlclZpZXdJbml0KCl7XG4gICAgICogICAgIGxldCBkcmFnVmlzaWJpbHR5ID0gdGhpcy5teURyYWcudmlzaWJsZTtcbiAgICAgKiB9XG4gICAgICogYGBgXG4gICAgICovXG4gICAgcHVibGljIGdldCB2aXNpYmxlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdmlzaWJpbGl0eSA9PT0gJ3Zpc2libGUnO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwdWJsaWMgc2V0IGxlZnQodmFsOiBudW1iZXIpIHtcbiAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9kcmFnR2hvc3QpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9kcmFnR2hvc3Quc3R5bGUubGVmdCA9IHZhbCArICdweCc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0IGxlZnQoKSB7XG4gICAgICAgIHJldHVybiBwYXJzZUludCh0aGlzLl9kcmFnR2hvc3Quc3R5bGUubGVmdCwgMTApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwdWJsaWMgc2V0IHRvcCh2YWw6IG51bWJlcikge1xuICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2RyYWdHaG9zdCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2RyYWdHaG9zdC5zdHlsZS50b3AgPSB2YWwgKyAncHgnO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHVibGljIGdldCB0b3AoKSB7XG4gICAgICAgIHJldHVybiBwYXJzZUludCh0aGlzLl9kcmFnR2hvc3Quc3R5bGUudG9wLCAxMCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBpZiB0aGUgYnJvd3NlciBzdXBwb3J0cyBwb2ludGVyIGV2ZW50cy5cbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogQFZpZXdDaGlsZChcIm15RHJhZ1wiICx7cmVhZDogSWd4RHJhZ0RpcmVjdGl2ZX0pXG4gICAgICogcHVibGljIG15RHJhZzogSWd4RHJhZ0RpcmVjdGl2ZTtcbiAgICAgKiBuZ0FmdGVyVmlld0luaXQoKXtcbiAgICAgKiAgICAgbGV0IHBvaW50ZXJFdmVudHMgPSB0aGlzLm15RHJhZy5wb2ludGVyRXZlbnRzRW5hYmxlZDtcbiAgICAgKiB9XG4gICAgICogYGBgXG4gICAgICovXG4gICAgcHVibGljIGdldCBwb2ludGVyRXZlbnRzRW5hYmxlZCgpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBQb2ludGVyRXZlbnQgIT09ICd1bmRlZmluZWQnO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgaWYgdGhlIGJyb3dzZXIgc3VwcG9ydHMgdG91Y2ggZXZlbnRzLlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBAVmlld0NoaWxkKFwibXlEcmFnXCIgLHtyZWFkOiBJZ3hEcmFnRGlyZWN0aXZlfSlcbiAgICAgKiBwdWJsaWMgbXlEcmFnOiBJZ3hEcmFnRGlyZWN0aXZlO1xuICAgICAqIG5nQWZ0ZXJWaWV3SW5pdCgpe1xuICAgICAqICAgICBsZXQgdG91Y2hFdmVudHMgPSB0aGlzLm15RHJhZy5wb2ludGVyRXZlbnRzRW5hYmxlZDtcbiAgICAgKiB9XG4gICAgICogYGBgXG4gICAgICovXG4gICAgcHVibGljIGdldCB0b3VjaEV2ZW50c0VuYWJsZWQoKSB7XG4gICAgICAgIHJldHVybiAnb250b3VjaHN0YXJ0JyBpbiB3aW5kb3c7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHB1YmxpYyBkZWZhdWx0UmV0dXJuRHVyYXRpb24gPSAnMC41cyc7XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHJvdGVjdGVkIF9zdGFydFggPSAwO1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgX3N0YXJ0WSA9IDA7XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHJvdGVjdGVkIF9kcmFnR2hvc3Q7XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHByb3RlY3RlZCBfZHJhZ1N0YXJ0ZWQgPSBmYWxzZTtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHJvdGVjdGVkIF9kcmFnT2Zmc2V0WDtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHJvdGVjdGVkIF9kcmFnT2Zmc2V0WTtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHJvdGVjdGVkIF9kcmFnU3RhcnRYO1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgX2RyYWdTdGFydFk7XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHByb3RlY3RlZCBfcG9pbnRlckRvd25JZCA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHJvdGVjdGVkIF9jbGlja2VkID0gZmFsc2U7XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHByb3RlY3RlZCBfbGFzdERyb3BBcmVhID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgX2Rlc3Ryb3kgPSBuZXcgU3ViamVjdDxib29sZWFuPigpO1xuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHByb3RlY3RlZCBfcmVtb3ZlT25EZXN0cm95ID0gdHJ1ZTtcblxuICAgIGNvbnN0cnVjdG9yKHB1YmxpYyBjZHI6IENoYW5nZURldGVjdG9yUmVmLCBwdWJsaWMgZWxlbWVudDogRWxlbWVudFJlZiwgcHVibGljIHpvbmU6IE5nWm9uZSwgcHVibGljIHJlbmRlcmVyOiBSZW5kZXJlcjIpIHtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgbmdPbkluaXQoKSB7XG4gICAgICAgIHRoaXMuem9uZS5ydW5PdXRzaWRlQW5ndWxhcigoKSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5wb2ludGVyRXZlbnRzRW5hYmxlZCkge1xuICAgICAgICAgICAgICAgIGZyb21FdmVudCh0aGlzLmVsZW1lbnQubmF0aXZlRWxlbWVudCwgJ3BvaW50ZXJkb3duJykucGlwZSh0YWtlVW50aWwodGhpcy5fZGVzdHJveSkpXG4gICAgICAgICAgICAgICAgLnN1YnNjcmliZSgocmVzKSA9PiB0aGlzLm9uUG9pbnRlckRvd24ocmVzKSk7XG5cbiAgICAgICAgICAgICAgICBmcm9tRXZlbnQodGhpcy5lbGVtZW50Lm5hdGl2ZUVsZW1lbnQsICdwb2ludGVybW92ZScpLnBpcGUoXG4gICAgICAgICAgICAgICAgICAgIHRocm90dGxlKCgpID0+IGludGVydmFsKDAsIGFuaW1hdGlvbkZyYW1lU2NoZWR1bGVyKSksXG4gICAgICAgICAgICAgICAgICAgIHRha2VVbnRpbCh0aGlzLl9kZXN0cm95KVxuICAgICAgICAgICAgICAgICkuc3Vic2NyaWJlKChyZXMpID0+IHRoaXMub25Qb2ludGVyTW92ZShyZXMpKTtcblxuICAgICAgICAgICAgICAgIGZyb21FdmVudCh0aGlzLmVsZW1lbnQubmF0aXZlRWxlbWVudCwgJ3BvaW50ZXJ1cCcpLnBpcGUodGFrZVVudGlsKHRoaXMuX2Rlc3Ryb3kpKVxuICAgICAgICAgICAgICAgICAgICAuc3Vic2NyaWJlKChyZXMpID0+IHRoaXMub25Qb2ludGVyVXAocmVzKSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMudG91Y2hFdmVudHNFbmFibGVkKSB7XG4gICAgICAgICAgICAgICAgLy8gV2UgZG9uJ3QgaGF2ZSBwb2ludGVyIGV2ZW50cyBhbmQgdG91Y2ggZXZlbnRzLiBVc2UgdGhlbiBtb3VzZSBldmVudHMuXG4gICAgICAgICAgICAgICAgZnJvbUV2ZW50KHRoaXMuZWxlbWVudC5uYXRpdmVFbGVtZW50LCAndG91Y2hzdGFydCcpLnBpcGUodGFrZVVudGlsKHRoaXMuX2Rlc3Ryb3kpKVxuICAgICAgICAgICAgICAgIC5zdWJzY3JpYmUoKHJlcykgPT4gdGhpcy5vblBvaW50ZXJEb3duKHJlcykpO1xuXG4gICAgICAgICAgICAgICAgZnJvbUV2ZW50KGRvY3VtZW50LmRlZmF1bHRWaWV3LCAndG91Y2htb3ZlJykucGlwZShcbiAgICAgICAgICAgICAgICAgICAgdGhyb3R0bGUoKCkgPT4gaW50ZXJ2YWwoMCwgYW5pbWF0aW9uRnJhbWVTY2hlZHVsZXIpKSxcbiAgICAgICAgICAgICAgICAgICAgdGFrZVVudGlsKHRoaXMuX2Rlc3Ryb3kpXG4gICAgICAgICAgICAgICAgKS5zdWJzY3JpYmUoKHJlcykgPT4gdGhpcy5vblBvaW50ZXJNb3ZlKHJlcykpO1xuXG4gICAgICAgICAgICAgICAgZnJvbUV2ZW50KGRvY3VtZW50LmRlZmF1bHRWaWV3LCAndG91Y2hlbmQnKS5waXBlKHRha2VVbnRpbCh0aGlzLl9kZXN0cm95KSlcbiAgICAgICAgICAgICAgICAgICAgLnN1YnNjcmliZSgocmVzKSA9PiB0aGlzLm9uUG9pbnRlclVwKHJlcykpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBXZSBkb24ndCBoYXZlIHBvaW50ZXIgZXZlbnRzIGFuZCB0b3VjaCBldmVudHMuIFVzZSB0aGVuIG1vdXNlIGV2ZW50cy5cbiAgICAgICAgICAgICAgICBmcm9tRXZlbnQodGhpcy5lbGVtZW50Lm5hdGl2ZUVsZW1lbnQsICdtb3VzZWRvd24nKS5waXBlKHRha2VVbnRpbCh0aGlzLl9kZXN0cm95KSlcbiAgICAgICAgICAgICAgICAuc3Vic2NyaWJlKChyZXMpID0+IHRoaXMub25Qb2ludGVyRG93bihyZXMpKTtcblxuICAgICAgICAgICAgICAgIGZyb21FdmVudChkb2N1bWVudC5kZWZhdWx0VmlldywgJ21vdXNlbW92ZScpLnBpcGUoXG4gICAgICAgICAgICAgICAgICAgIHRocm90dGxlKCgpID0+IGludGVydmFsKDAsIGFuaW1hdGlvbkZyYW1lU2NoZWR1bGVyKSksXG4gICAgICAgICAgICAgICAgICAgIHRha2VVbnRpbCh0aGlzLl9kZXN0cm95KVxuICAgICAgICAgICAgICAgICkuc3Vic2NyaWJlKChyZXMpID0+IHRoaXMub25Qb2ludGVyTW92ZShyZXMpKTtcblxuICAgICAgICAgICAgICAgIGZyb21FdmVudChkb2N1bWVudC5kZWZhdWx0VmlldywgJ21vdXNldXAnKS5waXBlKHRha2VVbnRpbCh0aGlzLl9kZXN0cm95KSlcbiAgICAgICAgICAgICAgICAgICAgLnN1YnNjcmliZSgocmVzKSA9PiB0aGlzLm9uUG9pbnRlclVwKHJlcykpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgbmdPbkRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuX2Rlc3Ryb3kubmV4dCh0cnVlKTtcbiAgICAgICAgdGhpcy5fZGVzdHJveS5jb21wbGV0ZSgpO1xuXG4gICAgICAgIGlmICh0aGlzLl9kcmFnR2hvc3QgJiYgdGhpcy5fcmVtb3ZlT25EZXN0cm95KSB7XG4gICAgICAgICAgICB0aGlzLl9kcmFnR2hvc3QucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLl9kcmFnR2hvc3QpO1xuICAgICAgICAgICAgdGhpcy5fZHJhZ0dob3N0ID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKiBNZXRob2QgYm91bmQgdG8gdGhlIFBvaW50ZXJEb3duIGV2ZW50IG9mIHRoZSBiYXNlIGVsZW1lbnQgaWd4RHJhZyBpcyBpbml0aWFsaXplZC5cbiAgICAgKiBAcGFyYW0gZXZlbnQgUG9pbnRlckRvd24gZXZlbnQgY2FwdHVyZWRcbiAgICAgKi9cbiAgICBwdWJsaWMgb25Qb2ludGVyRG93bihldmVudCkge1xuICAgICAgICB0aGlzLl9jbGlja2VkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5fcG9pbnRlckRvd25JZCA9IGV2ZW50LnBvaW50ZXJJZDtcblxuICAgICAgICBpZiAodGhpcy5wb2ludGVyRXZlbnRzRW5hYmxlZCB8fCAhdGhpcy50b3VjaEV2ZW50c0VuYWJsZWQpIHtcbiAgICAgICAgICAgIC8vIENoZWNrIGZpcnN0IGZvciBwb2ludGVyIGV2ZW50cyBvciBub24gdG91Y2gsIGJlY2F1c2Ugd2UgY2FuIGhhdmUgcG9pbnRlciBldmVudHMgYW5kIHRvdWNoIGV2ZW50cyBhdCBvbmNlLlxuICAgICAgICAgICAgdGhpcy5fc3RhcnRYID0gZXZlbnQucGFnZVg7XG4gICAgICAgICAgICB0aGlzLl9zdGFydFkgPSBldmVudC5wYWdlWTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLnRvdWNoRXZlbnRzRW5hYmxlZCkge1xuICAgICAgICAgICAgdGhpcy5fc3RhcnRYID0gZXZlbnQudG91Y2hlc1swXS5wYWdlWDtcbiAgICAgICAgICAgIHRoaXMuX3N0YXJ0WSA9IGV2ZW50LnRvdWNoZXNbMF0ucGFnZVk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUYWtlIG1hcmdpbnMgYmVjYXVzZSBnZXRCb3VuZGluZ0NsaWVudFJlY3QoKSBkb2Vzbid0IGluY2x1ZGUgbWFyZ2lucyBvZiB0aGUgZWxlbWVudFxuICAgICAgICBjb25zdCBtYXJnaW5Ub3AgPSBwYXJzZUludChkb2N1bWVudC5kZWZhdWx0Vmlldy5nZXRDb21wdXRlZFN0eWxlKHRoaXMuZWxlbWVudC5uYXRpdmVFbGVtZW50KVsnbWFyZ2luLXRvcCddLCAxMCk7XG4gICAgICAgIGNvbnN0IG1hcmdpbkxlZnQgPSBwYXJzZUludChkb2N1bWVudC5kZWZhdWx0Vmlldy5nZXRDb21wdXRlZFN0eWxlKHRoaXMuZWxlbWVudC5uYXRpdmVFbGVtZW50KVsnbWFyZ2luLWxlZnQnXSwgMTApO1xuXG4gICAgICAgIHRoaXMuX2RyYWdPZmZzZXRYID1cbiAgICAgICAgICAgICh0aGlzLl9zdGFydFggLSB0aGlzLmVsZW1lbnQubmF0aXZlRWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5sZWZ0IC0gdGhpcy5nZXRXaW5kb3dTY3JvbGxMZWZ0KCkpICsgbWFyZ2luTGVmdDtcbiAgICAgICAgdGhpcy5fZHJhZ09mZnNldFkgPVxuICAgICAgICAgICAgKHRoaXMuX3N0YXJ0WSAtIHRoaXMuZWxlbWVudC5uYXRpdmVFbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLnRvcCAtIHRoaXMuZ2V0V2luZG93U2Nyb2xsVG9wKCkpICsgbWFyZ2luVG9wO1xuICAgICAgICB0aGlzLl9kcmFnU3RhcnRYID0gdGhpcy5fc3RhcnRYIC0gdGhpcy5fZHJhZ09mZnNldFg7XG4gICAgICAgIHRoaXMuX2RyYWdTdGFydFkgPSB0aGlzLl9zdGFydFkgLSB0aGlzLl9kcmFnT2Zmc2V0WTtcblxuICAgICAgICAvLyBTZXQgcG9pbnRlciBjYXB0dXJlIHNvIHdlIGRldGVjdCBwb2ludGVybW92ZSBldmVuIGlmIG1vdXNlIGlzIG91dCBvZiBib3VuZHMgdW50aWwgZHJhZ0dob3N0IGlzIGNyZWF0ZWQuXG4gICAgICAgIGlmICh0aGlzLnBvaW50ZXJFdmVudHNFbmFibGVkKSB7XG4gICAgICAgICAgICB0aGlzLmVsZW1lbnQubmF0aXZlRWxlbWVudC5zZXRQb2ludGVyQ2FwdHVyZSh0aGlzLl9wb2ludGVyRG93bklkKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZWxlbWVudC5uYXRpdmVFbGVtZW50LmZvY3VzKCk7XG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqIFBlcmZtb3JtIGRyYWcgbW92ZSBsb2dpYyB3aGVuIGRyYWdnaW5nIGFuZCBkaXNwYXRjaGluZyBldmVudHMgaWYgdGhlcmUgaXMgaWd4RHJvcCB1bmRlciB0aGUgcG9pbnRlci5cbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBib3VuZCBhdCBmaXJzdCBhdCB0aGUgYmFzZSBlbGVtZW50LlxuICAgICAqIElmIGRyYWdnaW5nIHN0YXJ0cyBhbmQgYWZ0ZXIgdGhlIGRyYWdHaG9zdCBpcyByZW5kZXJlZCB0aGUgcG9pbnRlcklkIGlzIHJlYXNzaWduZWQgdG8gdGhlIGRyYWdHaG9zdC4gVGhlbiB0aGlzIG1ldGhvZCBpcyBib3VuZCB0byBpdC5cbiAgICAgKiBAcGFyYW0gZXZlbnQgUG9pbnRlck1vdmUgZXZlbnQgY2FwdHVyZWRcbiAgICAgKi9cbiAgICBwdWJsaWMgb25Qb2ludGVyTW92ZShldmVudCkge1xuICAgICAgICBpZiAodGhpcy5fY2xpY2tlZCkge1xuICAgICAgICAgICAgY29uc3QgZHJhZ1N0YXJ0QXJnczogSURyYWdTdGFydEV2ZW50QXJncyA9IHtcbiAgICAgICAgICAgICAgICBvcmlnaW5hbEV2ZW50OiBldmVudCxcbiAgICAgICAgICAgICAgICBvd25lcjogdGhpcyxcbiAgICAgICAgICAgICAgICBjYW5jZWw6IGZhbHNlXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgbGV0IHBhZ2VYLCBwYWdlWTtcbiAgICAgICAgICAgIGlmICh0aGlzLnBvaW50ZXJFdmVudHNFbmFibGVkIHx8ICF0aGlzLnRvdWNoRXZlbnRzRW5hYmxlZCkge1xuICAgICAgICAgICAgICAgIC8vIENoZWNrIGZpcnN0IGZvciBwb2ludGVyIGV2ZW50cyBvciBub24gdG91Y2gsIGJlY2F1c2Ugd2UgY2FuIGhhdmUgcG9pbnRlciBldmVudHMgYW5kIHRvdWNoIGV2ZW50cyBhdCBvbmNlLlxuICAgICAgICAgICAgICAgIHBhZ2VYID0gZXZlbnQucGFnZVg7XG4gICAgICAgICAgICAgICAgcGFnZVkgPSBldmVudC5wYWdlWTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy50b3VjaEV2ZW50c0VuYWJsZWQpIHtcbiAgICAgICAgICAgICAgICBwYWdlWCA9IGV2ZW50LnRvdWNoZXNbMF0ucGFnZVg7XG4gICAgICAgICAgICAgICAgcGFnZVkgPSBldmVudC50b3VjaGVzWzBdLnBhZ2VZO1xuXG4gICAgICAgICAgICAgICAgLy8gUHJldmVudCBzY3JvbGxpbmcgb24gdG91Y2ggd2hpbGUgZHJhZ2dpbmdcbiAgICAgICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdCB0b3RhbE1vdmVkWCA9IHBhZ2VYIC0gdGhpcy5fc3RhcnRYO1xuICAgICAgICAgICAgY29uc3QgdG90YWxNb3ZlZFkgPSBwYWdlWSAtIHRoaXMuX3N0YXJ0WTtcbiAgICAgICAgICAgIGlmICghdGhpcy5fZHJhZ1N0YXJ0ZWQgJiZcbiAgICAgICAgICAgICAgICAoTWF0aC5hYnModG90YWxNb3ZlZFgpID4gdGhpcy5kcmFnVG9sZXJhbmNlIHx8IE1hdGguYWJzKHRvdGFsTW92ZWRZKSA+IHRoaXMuZHJhZ1RvbGVyYW5jZSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnpvbmUucnVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmFnU3RhcnQuZW1pdChkcmFnU3RhcnRBcmdzKTtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIGlmICghZHJhZ1N0YXJ0QXJncy5jYW5jZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZHJhZ1N0YXJ0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAvLyBXZSBtb3ZlZCBlbm91Z2ggc28gZHJhZ0dob3N0IGNhbiBiZSByZW5kZXJlZCBhbmQgYWN0dWFsIGRyYWdnaW5nIHRvIHN0YXJ0LlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNyZWF0ZURyYWdHaG9zdChldmVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIXRoaXMuX2RyYWdTdGFydGVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLmxlZnQgPSB0aGlzLl9kcmFnU3RhcnRYICsgdG90YWxNb3ZlZFg7XG4gICAgICAgICAgICB0aGlzLnRvcCA9IHRoaXMuX2RyYWdTdGFydFkgKyB0b3RhbE1vdmVkWTtcblxuICAgICAgICAgICAgdGhpcy5kaXNwYXRjaERyYWdFdmVudHMocGFnZVgsIHBhZ2VZLCBldmVudCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICogUGVyZm9ybSBkcmFnIGVuZCBsb2dpYyB3aGVuIHJlbGVhc2luZyB0aGUgZHJhZ0dob3N0IGFuZCBkaXNwYXRjaGluZCBkcm9wIGV2ZW50IGlmIGlneERyb3AgaXMgdW5kZXIgdGhlIHBvaW50ZXIuXG4gICAgICogVGhpcyBtZXRob2QgaXMgYm91bmQgYXQgZmlyc3QgYXQgdGhlIGJhc2UgZWxlbWVudC5cbiAgICAgKiBJZiBkcmFnZ2luZyBzdGFydHMgYW5kIGFmdGVyIHRoZSBkcmFnR2hvc3QgaXMgcmVuZGVyZWQgdGhlIHBvaW50ZXJJZCBpcyByZWFzc2lnbmVkIHRvIHRoZSBkcmFnR2hvc3QuIFRoZW4gdGhpcyBtZXRob2QgaXMgYm91bmQgdG8gaXQuXG4gICAgICogQHBhcmFtIGV2ZW50IFBvaW50ZXJVcCBldmVudCBjYXB0dXJlZFxuICAgICAqL1xuICAgIHB1YmxpYyBvblBvaW50ZXJVcChldmVudCkge1xuICAgICAgICBpZiAoIXRoaXMuX2NsaWNrZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGV2ZW50QXJncyA9IHtcbiAgICAgICAgICAgIG9yaWdpbmFsRXZlbnQ6IGV2ZW50LFxuICAgICAgICAgICAgb3duZXI6IHRoaXNcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5fY2xpY2tlZCA9IGZhbHNlO1xuICAgICAgICBpZiAodGhpcy5fZHJhZ1N0YXJ0ZWQpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9sYXN0RHJvcEFyZWEgJiYgdGhpcy5fbGFzdERyb3BBcmVhICE9PSB0aGlzLmVsZW1lbnQubmF0aXZlRWxlbWVudCkge1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5hbmltYXRlT25SZWxlYXNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMub25UcmFuc2l0aW9uRW5kKG51bGwpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIGRyYWdnaW5nIGVuZGVkIG92ZXIgYSBkcm9wIGFyZWEuIENhbGwgdGhpcyBhZnRlciB0cmFuc2l0aW9uIGJlY2F1c2Ugb25Ecm9wIG1pZ2h0IHJlbW92ZSB0aGUgZWxlbWVudC5cbiAgICAgICAgICAgICAgICB0aGlzLmRpc3BhdGNoRHJvcEV2ZW50KGV2ZW50LnBhZ2VYLCBldmVudC5wYWdlWSwgZXZlbnQpO1xuICAgICAgICAgICAgICAgIC8vIGVsc2UgdGhlIGRyb3AgZGlyZWN0aXZlIG5lZWRzIHRvIGNhbGwgdGhlIGRyb3BGaW5pc2hlZCgpIG1ldGhvZCBzbyB0aGUgYW5pbWF0aW9uIGNhbiBwZXJmb3JtXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuYW5pbWF0ZU9uUmVsZWFzZSAmJlxuICAgICAgICAgICAgICAgICAgICAodGhpcy5sZWZ0ICE9PSBNYXRoLmZsb29yKHRoaXMuX2RyYWdTdGFydFgpIHx8IHRoaXMudG9wICE9PSBNYXRoLmZsb29yKHRoaXMuX2RyYWdTdGFydFkpKSkge1xuICAgICAgICAgICAgICAgIC8vIElmIHRoZSBzdGFydCBwb3NpdGlvbnMgYXJlIHRoZSBzYW1lIGFzIHRoZSBjdXJyZW50IHRoZSB0cmFuc2l0aW9uIHdpbGwgbm90IGV4ZWN1dGUuXG4gICAgICAgICAgICAgICAgLy8gcmV0dXJuIHRoZSBnaG9zdCB0byBzdGFydCBwb3NpdGlvbiBiZWZvcmUgcmVtb3ZpbmcgaXQuIFNlZSBvblRyYW5zaXRpb25FbmQuXG4gICAgICAgICAgICAgICAgdGhpcy5fZHJhZ0dob3N0LnN0eWxlLnRyYW5zaXRpb25EdXJhdGlvbiA9IHRoaXMuZGVmYXVsdFJldHVybkR1cmF0aW9uO1xuICAgICAgICAgICAgICAgIHRoaXMubGVmdCA9IHRoaXMuX2RyYWdTdGFydFg7XG4gICAgICAgICAgICAgICAgdGhpcy50b3AgPSB0aGlzLl9kcmFnU3RhcnRZO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLm9uVHJhbnNpdGlvbkVuZChudWxsKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy56b25lLnJ1bigoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5kcmFnRW5kLmVtaXQoZXZlbnRBcmdzKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy56b25lLnJ1bigoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5kcmFnQ2xpY2tlZC5lbWl0KGV2ZW50QXJncyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKiBDcmVhdGUgZHJhZ0dob3N0IGVsZW1lbnQgLSBpZiBhIE5vZGUgb2JqZWN0IGlzIHByb3ZpZGVkIGl0IGNyZWF0ZXMgYSBjbG9uZSBvZiB0aGF0IG5vZGUsXG4gICAgICogb3RoZXJ3aXNlIGl0IGNsb25lcyB0aGUgaG9zdCBlbGVtZW50LlxuICAgICAqIEJpbmQgYWxsIG5lZWRlZCBldmVudHMuXG4gICAgICogQHBhcmFtIGV2ZW50IFBvaW50ZXIgZXZlbnQgcmVxdWlyZWQgd2hlbiB0aGUgZHJhZ0dob3N0IGlzIGJlaW5nIGluaXRpYWxpemVkLlxuICAgICAqIEBwYXJhbSBub2RlIFRoZSBOb2RlIG9iamVjdCB0byBiZSBjbG9uZWQuXG4gICAgICovXG4gICAgcHJvdGVjdGVkIGNyZWF0ZURyYWdHaG9zdChldmVudCwgbm9kZTogYW55ID0gbnVsbCkge1xuICAgICAgICB0aGlzLl9kcmFnR2hvc3QgPSBub2RlID8gbm9kZS5jbG9uZU5vZGUodHJ1ZSkgOiB0aGlzLmVsZW1lbnQubmF0aXZlRWxlbWVudC5jbG9uZU5vZGUodHJ1ZSk7XG4gICAgICAgIHRoaXMuX2RyYWdHaG9zdC5zdHlsZS50cmFuc2l0aW9uRHVyYXRpb24gPSAnMC4wcyc7XG4gICAgICAgIHRoaXMuX2RyYWdHaG9zdC5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gICAgICAgIGNvbnN0IGhvc3RMZWZ0ID0gdGhpcy5kcmFnR2hvc3RIb3N0ID8gdGhpcy5kcmFnR2hvc3RIb3N0LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmxlZnQgOiAwO1xuICAgICAgICBjb25zdCBob3N0VG9wID0gdGhpcy5kcmFnR2hvc3RIb3N0ID8gdGhpcy5kcmFnR2hvc3RIb3N0LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLnRvcCA6IDA7XG4gICAgICAgIHRoaXMuX2RyYWdHaG9zdC5zdHlsZS50b3AgPSB0aGlzLl9kcmFnU3RhcnRZIC0gaG9zdFRvcCArICdweCc7XG4gICAgICAgIHRoaXMuX2RyYWdHaG9zdC5zdHlsZS5sZWZ0ID0gdGhpcy5fZHJhZ1N0YXJ0WCAtIGhvc3RMZWZ0ICsgJ3B4JztcblxuICAgICAgICBpZiAodGhpcy5naG9zdEltYWdlQ2xhc3MpIHtcbiAgICAgICAgICAgIHRoaXMucmVuZGVyZXIuYWRkQ2xhc3ModGhpcy5fZHJhZ0dob3N0LCB0aGlzLmdob3N0SW1hZ2VDbGFzcyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5kcmFnR2hvc3RIb3N0KSB7XG4gICAgICAgICAgICB0aGlzLmRyYWdHaG9zdEhvc3QuYXBwZW5kQ2hpbGQodGhpcy5fZHJhZ0dob3N0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQodGhpcy5fZHJhZ0dob3N0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLnBvaW50ZXJFdmVudHNFbmFibGVkKSB7XG4gICAgICAgICAgICAvLyBUaGUgZHJhZ0dob3N0IHRha2VzIGNvbnRyb2wgZm9yIG1vdmluZyBhbmQgZHJhZ2dpbmcgYWZ0ZXIgaXQgaGFzIGJlZW4gc2hvd24uXG4gICAgICAgICAgICB0aGlzLl9kcmFnR2hvc3Quc2V0UG9pbnRlckNhcHR1cmUodGhpcy5fcG9pbnRlckRvd25JZCk7XG4gICAgICAgICAgICB0aGlzLl9kcmFnR2hvc3QuYWRkRXZlbnRMaXN0ZW5lcigncG9pbnRlcm1vdmUnLCAoYXJncykgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMub25Qb2ludGVyTW92ZShhcmdzKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5fZHJhZ0dob3N0LmFkZEV2ZW50TGlzdGVuZXIoJ3BvaW50ZXJ1cCcsIChhcmdzKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5vblBvaW50ZXJVcChhcmdzKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuYW5pbWF0ZU9uUmVsZWFzZSkge1xuICAgICAgICAgICAgLy8gVHJhbnNpdGlvbiBhbmltYXRpb24gd2hlbiB0aGUgZHJhZ0dob3N0IGlzIHJlbGVhc2VkIGFuZCBpdCByZXR1cm5zIHRvIGl0J3Mgb3JpZ2luYWwgcG9zaXRpb24uXG4gICAgICAgICAgICB0aGlzLl9kcmFnR2hvc3QuYWRkRXZlbnRMaXN0ZW5lcigndHJhbnNpdGlvbmVuZCcsIChhcmdzKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5vblRyYW5zaXRpb25FbmQoYXJncyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEhpZGUgdGhlIGJhc2UgYWZ0ZXIgdGhlIGRyYWdHaG9zdCBpcyBjcmVhdGVkLCBiZWNhdXNlIG90aGVyd2lzZSB0aGUgZHJhZ0dob3N0IHdpbGwgYmUgbm90IHZpc2libGUuXG4gICAgICAgIGlmICh0aGlzLmhpZGVCYXNlT25EcmFnKSB7XG4gICAgICAgICAgICB0aGlzLnZpc2libGUgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKiBEaXNwYXRjaCBjdXN0b20gaWd4RHJhZ0VudGVyL2lneERyYWdMZWF2ZSBldmVudHMgYmFzZWQgb24gY3VycmVudCBwb2ludGVyIHBvc2l0aW9uIGFuZCBpZiBkcm9wIGFyZWEgaXMgdW5kZXIuXG4gICAgICovXG4gICAgcHJvdGVjdGVkIGRpc3BhdGNoRHJhZ0V2ZW50cyhwYWdlWDogbnVtYmVyLCBwYWdlWTogbnVtYmVyLCBvcmlnaW5hbEV2ZW50KSB7XG4gICAgICAgIGxldCB0b3BEcm9wQXJlYTtcbiAgICAgICAgY29uc3QgZXZlbnRBcmdzOiBJZ3hEcmFnQ3VzdG9tRXZlbnREZXRhaWxzID0ge1xuICAgICAgICAgICAgc3RhcnRYOiB0aGlzLl9zdGFydFgsXG4gICAgICAgICAgICBzdGFydFk6IHRoaXMuX3N0YXJ0WSxcbiAgICAgICAgICAgIHBhZ2VYOiBwYWdlWCxcbiAgICAgICAgICAgIHBhZ2VZOiBwYWdlWSxcbiAgICAgICAgICAgIG93bmVyOiB0aGlzLFxuICAgICAgICAgICAgb3JpZ2luYWxFdmVudDogb3JpZ2luYWxFdmVudFxuICAgICAgICB9O1xuXG4gICAgICAgIGNvbnN0IGVsZW1lbnRzRnJvbVBvaW50ID0gdGhpcy5nZXRFbGVtZW50c0F0UG9pbnQocGFnZVgsIHBhZ2VZKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBlbGVtZW50c0Zyb21Qb2ludC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKGVsZW1lbnRzRnJvbVBvaW50W2ldLmdldEF0dHJpYnV0ZSgnZHJvcHBhYmxlJykgPT09ICd0cnVlJyAmJiBlbGVtZW50c0Zyb21Qb2ludFtpXSAhPT0gdGhpcy5fZHJhZ0dob3N0KSB7XG4gICAgICAgICAgICAgICAgdG9wRHJvcEFyZWEgPSBlbGVtZW50c0Zyb21Qb2ludFtpXTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0b3BEcm9wQXJlYSkge1xuICAgICAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KHRvcERyb3BBcmVhLCAnaWd4RHJhZ092ZXInLCBldmVudEFyZ3MpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRvcERyb3BBcmVhICYmXG4gICAgICAgICAgICAoIXRoaXMuX2xhc3REcm9wQXJlYSB8fCAodGhpcy5fbGFzdERyb3BBcmVhICYmIHRoaXMuX2xhc3REcm9wQXJlYSAhPT0gdG9wRHJvcEFyZWEpKSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2xhc3REcm9wQXJlYSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudCh0aGlzLl9sYXN0RHJvcEFyZWEsICdpZ3hEcmFnTGVhdmUnLCBldmVudEFyZ3MpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLl9sYXN0RHJvcEFyZWEgPSB0b3BEcm9wQXJlYTtcbiAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudCh0aGlzLl9sYXN0RHJvcEFyZWEsICdpZ3hEcmFnRW50ZXInLCBldmVudEFyZ3MpO1xuICAgICAgICB9IGVsc2UgaWYgKCF0b3BEcm9wQXJlYSAmJiB0aGlzLl9sYXN0RHJvcEFyZWEpIHtcbiAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudCh0aGlzLl9sYXN0RHJvcEFyZWEsICdpZ3hEcmFnTGVhdmUnLCBldmVudEFyZ3MpO1xuICAgICAgICAgICAgdGhpcy5fbGFzdERyb3BBcmVhID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKiBEaXNwYXRjaCBjdXN0b20gaWd4RHJvcCBldmVudCBiYXNlZCBvbiBjdXJyZW50IHBvaW50ZXIgcG9zaXRpb24gaWYgdGhlcmUgaXMgbGFzdCByZWNvcmRlciBkcm9wIGFyZWEgdW5kZXIgdGhlIHBvaW50ZXIuXG4gICAgICogTGFzdCByZWNvcmRlciBkcm9wIGFyZWEgaXMgdXBkYXRlZCBpbiBAZGlzcGF0Y2hEcmFnRXZlbnRzIG1ldGhvZC5cbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgZGlzcGF0Y2hEcm9wRXZlbnQocGFnZVg6IG51bWJlciwgcGFnZVk6IG51bWJlciwgb3JpZ2luYWxFdmVudCkge1xuICAgICAgICBjb25zdCBldmVudEFyZ3M6IElneERyYWdDdXN0b21FdmVudERldGFpbHMgPSB7XG4gICAgICAgICAgICBzdGFydFg6IHRoaXMuX3N0YXJ0WCxcbiAgICAgICAgICAgIHN0YXJ0WTogdGhpcy5fc3RhcnRZLFxuICAgICAgICAgICAgcGFnZVg6IHBhZ2VYLFxuICAgICAgICAgICAgcGFnZVk6IHBhZ2VZLFxuICAgICAgICAgICAgb3duZXI6IHRoaXMsXG4gICAgICAgICAgICBvcmlnaW5hbEV2ZW50OiBvcmlnaW5hbEV2ZW50XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KHRoaXMuX2xhc3REcm9wQXJlYSwgJ2lneERyb3AnLCBldmVudEFyZ3MpO1xuICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQodGhpcy5fbGFzdERyb3BBcmVhLCAnaWd4RHJhZ0xlYXZlJywgZXZlbnRBcmdzKTtcbiAgICAgICAgdGhpcy5fbGFzdERyb3BBcmVhID0gbnVsbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICogVXBkYXRlIHJlbGF0aXZlIHBvc2l0aW9uc1xuICAgICAqL1xuICAgIHB1YmxpYyB1cGRhdGVEcmFnUmVsYXRpdmVQb3MoKSB7XG4gICAgICAgIGlmICghdGhpcy5fZHJhZ0dob3N0KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDYWxjdWxhdGUgdGhlIG5ldyBkcmFnR2hvc3QgcG9zaXRpb24gdG8gcmVtYWluIHdoZXJlIHRoZSBtb3VzZSBpcywgc28gaXQgZG9lc24ndCBqdW1wXG4gICAgICAgIGNvbnN0IHRvdGFsRHJhZ2dlZFggPSB0aGlzLmxlZnQgLSB0aGlzLl9kcmFnU3RhcnRYO1xuICAgICAgICBjb25zdCB0b3RhbERyYWdnZWRZID0gdGhpcy50b3AgLSB0aGlzLl9kcmFnU3RhcnRZO1xuICAgICAgICBjb25zdCBuZXdQb3NYID0gdGhpcy5lbGVtZW50Lm5hdGl2ZUVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkubGVmdDtcbiAgICAgICAgY29uc3QgbmV3UG9zWSA9IHRoaXMuZWxlbWVudC5uYXRpdmVFbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLnRvcDtcbiAgICAgICAgY29uc3QgZGlmZlN0YXJ0WCA9IHRoaXMuX2RyYWdTdGFydFggLSBuZXdQb3NYO1xuICAgICAgICBjb25zdCBkaWZmU3RhcnRZID0gdGhpcy5fZHJhZ1N0YXJ0WSAtIG5ld1Bvc1k7XG4gICAgICAgIHRoaXMudG9wID0gbmV3UG9zWCArIHRvdGFsRHJhZ2dlZFggLSBkaWZmU3RhcnRYO1xuICAgICAgICB0aGlzLmxlZnQgPSBuZXdQb3NZICsgdG90YWxEcmFnZ2VkWSAtIGRpZmZTdGFydFk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW5mb3JtcyB0aGUgYGlneERyYWdgIGRpcmVjdGl2ZSB0aGF0IGl0IGhhcyBiZWVuIGRyb3BwZWQvcmVsZWFzZWQuXG4gICAgICogVGhpcyBzaG91bGQgdXN1bGx5IGJlIGNhbGxlZCB3aGVuIGBhbmltYXRlT25SZWxlYXNlYCBpcyBzZXQgdG8gYHRydWVgLlxuICAgICAqIFdoZW4gY2FuY2VsaW5nIG9yIGRlZmluaW5nIGN1c3RvbSBkcm9wIGxvZ2ljIHRoaXMgdGVsbHMgdGhlIGlneERyYWcgdG8gdXBkYXRlIGl0J3MgcG9zaXRpb25zIGFuZFxuICAgICAqIGFuaW1hdGUgY29ycmVjdGx5IHRvIHRoZSBuZXcgcG9zaXRpb24uXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIHB1YmxpYyBvbkRyb3BFbGVtKGV2ZW50KSB7XG4gICAgICogICAgIC8vIEZ1bmN0aW9uIGJvdW5kIHRvIHRoZSBpZ3hEcm9wIGRpcmVjdGl2ZSBldmVudCBgb25Ecm9wYFxuICAgICAqICAgICAvLyBUaGlzIGNhbmNlbHMgdGhlIGRlZmF1bHQgZHJvcCBsb2dpYyBvZiB0aGUgYGlneERyb3BgXG4gICAgICogICAgIGV2ZW50LmNhbmNlbCA9IHRydWU7XG4gICAgICogICAgIGV2ZW50LmRyYWcuZHJvcEZpbmlzaGVkKCk7XG4gICAgICogfVxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIHB1YmxpYyBkcm9wRmluaXNoZWQoKSB7XG4gICAgICAgIGlmICh0aGlzLmFuaW1hdGVPblJlbGVhc2UgJiYgdGhpcy5fZHJhZ0dob3N0KSB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZURyYWdSZWxhdGl2ZVBvcygpO1xuXG4gICAgICAgICAgICAvLyBSZXR1cm4gdGhlIGRyYWdnZWQgZWxlbWVudCB0byB0aGUgc3RhcnQuIFNlZSBvblRyYW5zaXRpb25FbmQgbmV4dC5cbiAgICAgICAgICAgIC8vIFRha2UgbWFyZ2lucyBiZWN1YXNlIGdldEJvdW5kaW5nQ2xpZW50UmVjdCgpIGRvZXNuJ3QgaW5jbHVkZSBtYXJnaW5zXG4gICAgICAgICAgICBjb25zdCBtYXJnaW5Ub3AgPSBwYXJzZUludChkb2N1bWVudC5kZWZhdWx0Vmlldy5nZXRDb21wdXRlZFN0eWxlKHRoaXMuZWxlbWVudC5uYXRpdmVFbGVtZW50KVsnbWFyZ2luLXRvcCddLCAxMCk7XG4gICAgICAgICAgICBjb25zdCBtYXJnaW5MZWZ0ID0gcGFyc2VJbnQoZG9jdW1lbnQuZGVmYXVsdFZpZXcuZ2V0Q29tcHV0ZWRTdHlsZSh0aGlzLmVsZW1lbnQubmF0aXZlRWxlbWVudClbJ21hcmdpbi1sZWZ0J10sIDEwKTtcbiAgICAgICAgICAgIGNvbnN0IG5ld1Bvc1ggPSB0aGlzLmVsZW1lbnQubmF0aXZlRWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5sZWZ0ICsgdGhpcy5nZXRXaW5kb3dTY3JvbGxMZWZ0KCk7XG4gICAgICAgICAgICBjb25zdCBuZXdQb3NZID0gdGhpcy5lbGVtZW50Lm5hdGl2ZUVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkudG9wICsgdGhpcy5nZXRXaW5kb3dTY3JvbGxUb3AoKTtcblxuICAgICAgICAgICAgdGhpcy5fZHJhZ0dob3N0LnN0eWxlLnRyYW5zaXRpb25EdXJhdGlvbiA9IHRoaXMuZGVmYXVsdFJldHVybkR1cmF0aW9uO1xuICAgICAgICAgICAgdGhpcy5sZWZ0ID0gbmV3UG9zWCAtIG1hcmdpbkxlZnQ7XG4gICAgICAgICAgICB0aGlzLnRvcCA9IG5ld1Bvc1kgLSBtYXJnaW5Ub3A7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHVibGljIG9uVHJhbnNpdGlvbkVuZChldmVudCkge1xuICAgICAgICBpZiAodGhpcy5fZHJhZ1N0YXJ0ZWQgJiYgIXRoaXMuX2NsaWNrZWQpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmhpZGVCYXNlT25EcmFnKSB7XG4gICAgICAgICAgICAgICAgdGhpcy52aXNpYmxlID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5fZHJhZ0dob3N0LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5fZHJhZ0dob3N0KTtcbiAgICAgICAgICAgIHRoaXMuX2RyYWdHaG9zdCA9IG51bGw7XG5cbiAgICAgICAgICAgIHRoaXMuZWxlbWVudC5uYXRpdmVFbGVtZW50LnN0eWxlLnRyYW5zaXRpb25EdXJhdGlvbiA9ICcwLjBzJztcbiAgICAgICAgICAgIHRoaXMuX2RyYWdTdGFydGVkID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLnpvbmUucnVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnJldHVybk1vdmVFbmQuZW1pdCh7XG4gICAgICAgICAgICAgICAgICAgIG9yaWdpbmFsRXZlbnQ6IGV2ZW50LFxuICAgICAgICAgICAgICAgICAgICBvd25lcjogdGhpc1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHJvdGVjdGVkIGdldEVsZW1lbnRzQXRQb2ludChwYWdlWDogbnVtYmVyLCBwYWdlWTogbnVtYmVyKSB7XG4gICAgICAgIC8vIGNvcnJlY3QgdGhlIGNvb3JkaW5hdGVzIHdpdGggdGhlIGN1cnJlbnQgc2Nyb2xsIHBvc2l0aW9uLCBiZWNhdXNlXG4gICAgICAgIC8vIGRvY3VtZW50LmVsZW1lbnRzRnJvbVBvaW50IGNvbmlkZXIgcG9zaXRpb24gd2l0aGluIHRoZSBjdXJyZW50IHZpZXdwb3J0XG4gICAgICAgIC8vIHdpbmRvdy5wYWdlWE9mZnNldCA9PSB3aW5kb3cuc2Nyb2xsWDsgLy8gYWx3YXlzIHRydWVcbiAgICAgICAgLy8gdXNpbmcgd2luZG93LnBhZ2VYT2Zmc2V0IGZvciBJRTkgY29tcGF0aWJpbGl0eVxuICAgICAgICBjb25zdCB2aWV3UG9ydFggPSBwYWdlWCAtIHdpbmRvdy5wYWdlWE9mZnNldDtcbiAgICAgICAgY29uc3Qgdmlld1BvcnRZID0gcGFnZVkgLSB3aW5kb3cucGFnZVlPZmZzZXQ7XG4gICAgICAgIGlmIChkb2N1bWVudFsnbXNFbGVtZW50c0Zyb21Qb2ludCddKSB7XG4gICAgICAgICAgICAvLyBFZGdlIGFuZCBJRSBzcGVjaWFsIHNub3dmbGFrZXNcbiAgICAgICAgICAgIHJldHVybiBkb2N1bWVudFsnbXNFbGVtZW50c0Zyb21Qb2ludCddKHZpZXdQb3J0WCwgdmlld1BvcnRZKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIE90aGVyIGJyb3dzZXJzIGxpa2UgQ2hyb21lLCBGaXJlZm94LCBPcGVyYVxuICAgICAgICAgICAgcmV0dXJuIGRvY3VtZW50LmVsZW1lbnRzRnJvbVBvaW50KHZpZXdQb3J0WCwgdmlld1BvcnRZKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgZGlzcGF0Y2hFdmVudCh0YXJnZXQsIGV2ZW50TmFtZTogc3RyaW5nLCBldmVudEFyZ3M6IElneERyYWdDdXN0b21FdmVudERldGFpbHMpIHtcbiAgICAgICAgLy8gVGhpcyB3YXkgaXMgSUUxMSBjb21wYXRpYmxlLlxuICAgICAgICBjb25zdCBkcmFnTGVhdmVFdmVudCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdDdXN0b21FdmVudCcpO1xuICAgICAgICBkcmFnTGVhdmVFdmVudC5pbml0Q3VzdG9tRXZlbnQoZXZlbnROYW1lLCBmYWxzZSwgZmFsc2UsIGV2ZW50QXJncyk7XG4gICAgICAgIHRhcmdldC5kaXNwYXRjaEV2ZW50KGRyYWdMZWF2ZUV2ZW50KTtcbiAgICAgICAgLy8gT3RoZXJzaWUgY2FuIGJlIHVzZWQgYHRhcmdldC5kaXNwYXRjaEV2ZW50KG5ldyBDdXN0b21FdmVudChldmVudE5hbWUsIGV2ZW50QXJncykpO2BcbiAgICB9XG5cbiAgICBwcm90ZWN0ZWQgZ2V0V2luZG93U2Nyb2xsVG9wKCkge1xuICAgICAgICByZXR1cm4gd2luZG93LnNjcm9sbFkgPyB3aW5kb3cuc2Nyb2xsWSA6ICh3aW5kb3cucGFnZVlPZmZzZXQgPyB3aW5kb3cucGFnZVlPZmZzZXQgOiAwKTtcbiAgICB9XG5cbiAgICBwcm90ZWN0ZWQgZ2V0V2luZG93U2Nyb2xsTGVmdCgpIHtcbiAgICAgICAgcmV0dXJuIHdpbmRvdy5zY3JvbGxYID8gd2luZG93LnNjcm9sbFggOiAod2luZG93LnBhZ2VYT2Zmc2V0ID8gd2luZG93LnBhZ2VYT2Zmc2V0IDogMCk7XG4gICAgfVxufVxuXG5ARGlyZWN0aXZlKHtcbiAgICBzZWxlY3RvcjogJ1tpZ3hEcm9wXSdcbn0pXG5leHBvcnQgY2xhc3MgSWd4RHJvcERpcmVjdGl2ZSBpbXBsZW1lbnRzIE9uSW5pdCwgT25EZXN0cm95IHtcblxuICAgIC8qKlxuICAgICAqIC0gU2F2ZSBkYXRhIGluc2lkZSB0aGUgYGlneERyb3BgIGRpcmVjdGl2ZS4gVGhpcyBjYW4gYmUgc2V0IHdoZW4gaW5zdGFuY2luZyBgaWd4RHJvcGAgb24gYW4gZWxlbWVudC5cbiAgICAgKiBgYGBodG1sXG4gICAgICogPGRpdiBbaWd4RHJvcF09XCJ7IHNvdXJjZTogbXlFbGVtZW50IH1cIj48L2Rpdj5cbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBASW5wdXQoJ2lneERyb3AnKVxuICAgIHB1YmxpYyBkYXRhOiBhbnk7XG5cbiAgICAvKiogRXZlbnQgdHJpZ2dlcmVkIHdoZW4gZHJhZ2dlZCBlbGVtZW50IGVudGVycyB0aGUgYXJlYSBvZiB0aGUgZWxlbWVudC5cbiAgICAgKiBgYGBodG1sXG4gICAgICogPGRpdiBjbGFzcz1cImNhZ2VBcmVhXCIgaWd4RHJvcCAob25FbnRlcik9XCJkcmFnRW50ZXIoKVwiIChpZ3hEcmFnRW50ZXIpPVwib25EcmFnQ2FnZUVudGVyKClcIiAoaWd4RHJhZ0xlYXZlKT1cIm9uRHJhZ0NhZ2VMZWF2ZSgpXCI+XG4gICAgICogPC9kaXY+XG4gICAgICogYGBgXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIHB1YmxpYyBkcmFnRW50ZXIoKXtcbiAgICAgKiAgICAgYWxlcnQoXCJBIGRyYWdnYWJsZSBlbGVtZW50ZSBoYXMgZW50ZXJlZCB0aGUgY2hpcCBhcmVhIVwiKTtcbiAgICAgKiB9XG4gICAgICogYGBgXG4gICAgICovXG4gICAgQE91dHB1dCgpXG4gICAgcHVibGljIG9uRW50ZXIgPSBuZXcgRXZlbnRFbWl0dGVyPElneERyb3BFbnRlckV2ZW50QXJncz4oKTtcblxuICAgIC8qKiBFdmVudCB0cmlnZ2VyZWQgd2hlbiBkcmFnZ2VkIGVsZW1lbnQgbGVhdmVzIHRoZSBhcmVhIG9mIHRoZSBlbGVtZW50LlxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8ZGl2IGNsYXNzPVwiY2FnZUFyZWFcIiBpZ3hEcm9wIChvbkxlYXZlKT1cImRyYWdMZWF2ZSgpXCIgKGlneERyYWdFbnRlcik9XCJvbkRyYWdDYWdlRW50ZXIoKVwiIChpZ3hEcmFnTGVhdmUpPVwib25EcmFnQ2FnZUxlYXZlKClcIj5cbiAgICAgKiA8L2Rpdj5cbiAgICAgKiBgYGBcbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogcHVibGljIGRyYWdMZWF2ZSgpe1xuICAgICAqICAgICBhbGVydChcIkEgZHJhZ2dhYmxlIGVsZW1lbnRlIGhhcyBsZWZ0IHRoZSBjaGlwIGFyZWEhXCIpO1xuICAgICAqIH1cbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBAT3V0cHV0KClcbiAgICBwdWJsaWMgb25MZWF2ZSA9IG5ldyBFdmVudEVtaXR0ZXI8SWd4RHJvcExlYXZlRXZlbnRBcmdzPigpO1xuXG4gICAgLyoqIEV2ZW50IHRyaWdnZXJlZCB3aGVuIGRyYWdnZWQgZWxlbWVudCBpcyBkcm9wcGVkIGluIHRoZSBhcmVhIG9mIHRoZSBlbGVtZW50LlxuICAgICAqIFNpbmNlIHRoZSBgaWd4RHJvcGAgaGFzIGRlZmF1bHQgbG9naWMgdGhhdCBhcHBlbmRzIHRoZSBkcm9wcGVkIGVsZW1lbnQgYXMgYSBjaGlsZCwgaXQgY2FuIGJlIGNhbmNlbGVkIGhlcmUuXG4gICAgICogVG8gY2FuY2VsIHRoZSBkZWZhdWx0IGxvZ2ljIHRoZSBgY2FuY2VsYCBwcm9wZXJ0eSBvZiB0aGUgZXZlbnQgbmVlZHMgdG8gYmUgc2V0IHRvIHRydWUuXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxkaXYgY2xhc3M9XCJjYWdlQXJlYVwiIGlneERyb3AgKG9uRHJvcCk9XCJkcmFnRHJvcCgpXCIgKGlneERyYWdFbnRlcik9XCJvbkRyYWdDYWdlRW50ZXIoKVwiIChpZ3hEcmFnTGVhdmUpPVwib25EcmFnQ2FnZUxlYXZlKClcIj5cbiAgICAgKiA8L2Rpdj5cbiAgICAgKiBgYGBcbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogcHVibGljIGRyYWdEcm9wKCl7XG4gICAgICogICAgIGFsZXJ0KFwiQSBkcmFnZ2FibGUgZWxlbWVudGUgaGFzIGJlZW4gZHJvcHBlZCBpbiB0aGUgY2hpcCBhcmVhIVwiKTtcbiAgICAgKiB9XG4gICAgICogYGBgXG4gICAgICovXG4gICAgQE91dHB1dCgpXG4gICAgcHVibGljIG9uRHJvcCA9IG5ldyBFdmVudEVtaXR0ZXI8SWd4RHJvcEV2ZW50QXJncz4oKTtcblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBASG9zdEJpbmRpbmcoJ2F0dHIuZHJvcHBhYmxlJylcbiAgICBwdWJsaWMgZHJvcHBhYmxlID0gdHJ1ZTtcblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBASG9zdEJpbmRpbmcoJ2NsYXNzLmRyYWdPdmVyJylcbiAgICBwdWJsaWMgZHJhZ292ZXIgPSBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgX2Rlc3Ryb3kgPSBuZXcgU3ViamVjdDxib29sZWFuPigpO1xuXG4gICAgY29uc3RydWN0b3IocHVibGljIGVsZW1lbnQ6IEVsZW1lbnRSZWYsIHByaXZhdGUgX3JlbmRlcmVyOiBSZW5kZXJlcjIsIHByaXZhdGUgX3pvbmU6IE5nWm9uZSkge1xuICAgIH1cblxuICAgIG5nT25Jbml0KCkge1xuICAgICAgICB0aGlzLl96b25lLnJ1bk91dHNpZGVBbmd1bGFyKCgpID0+IHtcbiAgICAgICAgICAgIGZyb21FdmVudCh0aGlzLmVsZW1lbnQubmF0aXZlRWxlbWVudCwgJ2lneERyYWdFbnRlcicpLnBpcGUodGFrZVVudGlsKHRoaXMuX2Rlc3Ryb3kpKVxuICAgICAgICAgICAgICAgIC5zdWJzY3JpYmUoKHJlcykgPT4gdGhpcy5vbkRyYWdFbnRlcihyZXMgYXMgQ3VzdG9tRXZlbnQ8SWd4RHJhZ0N1c3RvbUV2ZW50RGV0YWlscz4pKTtcblxuICAgICAgICAgICAgZnJvbUV2ZW50KHRoaXMuZWxlbWVudC5uYXRpdmVFbGVtZW50LCAnaWd4RHJhZ0xlYXZlJykucGlwZSh0YWtlVW50aWwodGhpcy5fZGVzdHJveSkpLnN1YnNjcmliZSgocmVzKSA9PiB0aGlzLm9uRHJhZ0xlYXZlKHJlcykpO1xuICAgICAgICAgICAgZnJvbUV2ZW50KHRoaXMuZWxlbWVudC5uYXRpdmVFbGVtZW50LCAnaWd4RHJhZ092ZXInKS5waXBlKHRha2VVbnRpbCh0aGlzLl9kZXN0cm95KSkuc3Vic2NyaWJlKChyZXMpID0+IHRoaXMub25EcmFnT3ZlcihyZXMpKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgbmdPbkRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuX2Rlc3Ryb3kubmV4dCh0cnVlKTtcbiAgICAgICAgdGhpcy5fZGVzdHJveS5jb21wbGV0ZSgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwdWJsaWMgb25EcmFnT3ZlcihldmVudCkgeyB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHVibGljIG9uRHJhZ0VudGVyKGV2ZW50OiBDdXN0b21FdmVudDxJZ3hEcmFnQ3VzdG9tRXZlbnREZXRhaWxzPikge1xuICAgICAgICB0aGlzLmRyYWdvdmVyID0gdHJ1ZTtcbiAgICAgICAgY29uc3QgZWxlbWVudFBvc1ggPSB0aGlzLmVsZW1lbnQubmF0aXZlRWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5sZWZ0ICsgdGhpcy5nZXRXaW5kb3dTY3JvbGxMZWZ0KCk7XG4gICAgICAgIGNvbnN0IGVsZW1lbnRQb3NZID0gdGhpcy5lbGVtZW50Lm5hdGl2ZUVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkudG9wICsgdGhpcy5nZXRXaW5kb3dTY3JvbGxUb3AoKTtcbiAgICAgICAgY29uc3Qgb2Zmc2V0WCA9IGV2ZW50LmRldGFpbC5wYWdlWCAtIGVsZW1lbnRQb3NYO1xuICAgICAgICBjb25zdCBvZmZzZXRZID0gZXZlbnQuZGV0YWlsLnBhZ2VZIC0gZWxlbWVudFBvc1k7XG4gICAgICAgIGNvbnN0IGV2ZW50QXJnczogSWd4RHJvcEVudGVyRXZlbnRBcmdzID0ge1xuICAgICAgICAgICAgb3JpZ2luYWxFdmVudDogZXZlbnQuZGV0YWlsLm9yaWdpbmFsRXZlbnQsXG4gICAgICAgICAgICBvd25lcjogdGhpcyxcbiAgICAgICAgICAgIGRyYWc6IGV2ZW50LmRldGFpbC5vd25lcixcbiAgICAgICAgICAgIGRyYWdEYXRhOiBldmVudC5kZXRhaWwub3duZXIuZGF0YSxcbiAgICAgICAgICAgIHN0YXJ0WDogZXZlbnQuZGV0YWlsLnN0YXJ0WCxcbiAgICAgICAgICAgIHN0YXJ0WTogZXZlbnQuZGV0YWlsLnN0YXJ0WSxcbiAgICAgICAgICAgIHBhZ2VYOiBldmVudC5kZXRhaWwucGFnZVgsXG4gICAgICAgICAgICBwYWdlWTogZXZlbnQuZGV0YWlsLnBhZ2VZLFxuICAgICAgICAgICAgb2Zmc2V0WDogb2Zmc2V0WCxcbiAgICAgICAgICAgIG9mZnNldFk6IG9mZnNldFlcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5fem9uZS5ydW4oKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5vbkVudGVyLmVtaXQoZXZlbnRBcmdzKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHB1YmxpYyBvbkRyYWdMZWF2ZShldmVudCkge1xuICAgICAgICB0aGlzLmRyYWdvdmVyID0gZmFsc2U7XG4gICAgICAgIGNvbnN0IGVsZW1lbnRQb3NYID0gdGhpcy5lbGVtZW50Lm5hdGl2ZUVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkubGVmdCArIHRoaXMuZ2V0V2luZG93U2Nyb2xsTGVmdCgpO1xuICAgICAgICBjb25zdCBlbGVtZW50UG9zWSA9IHRoaXMuZWxlbWVudC5uYXRpdmVFbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLnRvcCArIHRoaXMuZ2V0V2luZG93U2Nyb2xsVG9wKCk7XG4gICAgICAgIGNvbnN0IG9mZnNldFggPSBldmVudC5kZXRhaWwucGFnZVggLSBlbGVtZW50UG9zWDtcbiAgICAgICAgY29uc3Qgb2Zmc2V0WSA9IGV2ZW50LmRldGFpbC5wYWdlWSAtIGVsZW1lbnRQb3NZO1xuICAgICAgICBjb25zdCBldmVudEFyZ3M6IElneERyb3BMZWF2ZUV2ZW50QXJncyA9IHtcbiAgICAgICAgICAgIG9yaWdpbmFsRXZlbnQ6IGV2ZW50LmRldGFpbC5vcmlnaW5hbEV2ZW50LFxuICAgICAgICAgICAgb3duZXI6IHRoaXMsXG4gICAgICAgICAgICBkcmFnOiBldmVudC5kZXRhaWwub3duZXIsXG4gICAgICAgICAgICBkcmFnRGF0YTogZXZlbnQuZGV0YWlsLm93bmVyLmRhdGEsXG4gICAgICAgICAgICBzdGFydFg6IGV2ZW50LmRldGFpbC5zdGFydFgsXG4gICAgICAgICAgICBzdGFydFk6IGV2ZW50LmRldGFpbC5zdGFydFksXG4gICAgICAgICAgICBwYWdlWDogZXZlbnQuZGV0YWlsLnBhZ2VYLFxuICAgICAgICAgICAgcGFnZVk6IGV2ZW50LmRldGFpbC5wYWdlWSxcbiAgICAgICAgICAgIG9mZnNldFg6IG9mZnNldFgsXG4gICAgICAgICAgICBvZmZzZXRZOiBvZmZzZXRZXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuX3pvbmUucnVuKCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMub25MZWF2ZS5lbWl0KGV2ZW50QXJncyk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBASG9zdExpc3RlbmVyKCdpZ3hEcm9wJywgWyckZXZlbnQnXSlcbiAgICBwdWJsaWMgb25EcmFnRHJvcChldmVudCkge1xuICAgICAgICBjb25zdCBlbGVtZW50UG9zWCA9IHRoaXMuZWxlbWVudC5uYXRpdmVFbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmxlZnQgKyB0aGlzLmdldFdpbmRvd1Njcm9sbExlZnQoKTtcbiAgICAgICAgY29uc3QgZWxlbWVudFBvc1kgPSB0aGlzLmVsZW1lbnQubmF0aXZlRWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS50b3AgKyB0aGlzLmdldFdpbmRvd1Njcm9sbFRvcCgpO1xuICAgICAgICBjb25zdCBvZmZzZXRYID0gZXZlbnQuZGV0YWlsLnBhZ2VYIC0gZWxlbWVudFBvc1g7XG4gICAgICAgIGNvbnN0IG9mZnNldFkgPSBldmVudC5kZXRhaWwucGFnZVkgLSBlbGVtZW50UG9zWTtcbiAgICAgICAgY29uc3QgYXJnczogSWd4RHJvcEV2ZW50QXJncyA9IHtcbiAgICAgICAgICAgIG93bmVyOiB0aGlzLFxuICAgICAgICAgICAgb3JpZ2luYWxFdmVudDogZXZlbnQuZGV0YWlsLm9yaWdpbmFsRXZlbnQsXG4gICAgICAgICAgICBkcmFnOiBldmVudC5kZXRhaWwub3duZXIsXG4gICAgICAgICAgICBvZmZzZXRYOiBvZmZzZXRYLFxuICAgICAgICAgICAgb2Zmc2V0WTogb2Zmc2V0WSxcbiAgICAgICAgICAgIGNhbmNlbDogZmFsc2VcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5fem9uZS5ydW4oKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5vbkRyb3AuZW1pdChhcmdzKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKCFhcmdzLmNhbmNlbCkge1xuICAgICAgICAgICAgLy8gVG8gZG8gZm9yIGdlbmVyaWMgc2NlbmFyaW9cbiAgICAgICAgICAgIHRoaXMuX3JlbmRlcmVyLnJlbW92ZUNoaWxkKGV2ZW50LmRldGFpbC5vd25lci5lbGVtZW50Lm5hdGl2ZUVsZW1lbnQucGFyZW50Tm9kZSwgZXZlbnQuZGV0YWlsLm93bmVyLmVsZW1lbnQubmF0aXZlRWxlbWVudCk7XG4gICAgICAgICAgICB0aGlzLl9yZW5kZXJlci5hcHBlbmRDaGlsZCh0aGlzLmVsZW1lbnQubmF0aXZlRWxlbWVudCwgZXZlbnQuZGV0YWlsLm93bmVyLmVsZW1lbnQubmF0aXZlRWxlbWVudCk7XG5cbiAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgIGV2ZW50LmRldGFpbC5vd25lci5kcm9wRmluaXNoZWQoKTtcbiAgICAgICAgICAgIH0sIDApO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIGdldFdpbmRvd1Njcm9sbFRvcCgpIHtcbiAgICAgICAgcmV0dXJuIHdpbmRvdy5zY3JvbGxZID8gd2luZG93LnNjcm9sbFkgOiAod2luZG93LnBhZ2VZT2Zmc2V0ID8gd2luZG93LnBhZ2VZT2Zmc2V0IDogMCk7XG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIGdldFdpbmRvd1Njcm9sbExlZnQoKSB7XG4gICAgICAgIHJldHVybiB3aW5kb3cuc2Nyb2xsWCA/IHdpbmRvdy5zY3JvbGxYIDogKHdpbmRvdy5wYWdlWE9mZnNldCA/IHdpbmRvdy5wYWdlWE9mZnNldCA6IDApO1xuICAgIH1cbn1cblxuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuQE5nTW9kdWxlKHtcbiAgICBkZWNsYXJhdGlvbnM6IFtJZ3hEcmFnRGlyZWN0aXZlLCBJZ3hEcm9wRGlyZWN0aXZlXSxcbiAgICBleHBvcnRzOiBbSWd4RHJhZ0RpcmVjdGl2ZSwgSWd4RHJvcERpcmVjdGl2ZV1cbn0pXG5leHBvcnQgY2xhc3MgSWd4RHJhZ0Ryb3BNb2R1bGUgeyB9XG4iXX0=