/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * This file contains all the directives used by the @link IgxCalendarComponent.
 * Except for the directives which are used for templating the calendar itself
 * you should generally not use them directly.
 * @preferred
 */
import { Directive, EventEmitter, HostBinding, HostListener, Input, Output, TemplateRef, ElementRef } from '@angular/core';
/**
 * @hidden
 */
export class IgxCalendarYearDirective {
    constructor() {
        this.onYearSelection = new EventEmitter();
    }
    /**
     * @return {?}
     */
    get defaultCSS() {
        return !this.isCurrentYear;
    }
    /**
     * @return {?}
     */
    get currentCSS() {
        return this.isCurrentYear;
    }
    /**
     * @return {?}
     */
    get isCurrentYear() {
        return this.date.getFullYear() === this.value.getFullYear();
    }
    /**
     * @return {?}
     */
    onClick() {
        this.onYearSelection.emit(this.value);
    }
}
IgxCalendarYearDirective.decorators = [
    { type: Directive, args: [{
                selector: '[igxCalendarYear]'
            },] }
];
IgxCalendarYearDirective.propDecorators = {
    value: [{ type: Input, args: ['igxCalendarYear',] }],
    date: [{ type: Input }],
    onYearSelection: [{ type: Output }],
    defaultCSS: [{ type: HostBinding, args: ['class.igx-calendar__year',] }],
    currentCSS: [{ type: HostBinding, args: ['class.igx-calendar__year--current',] }],
    onClick: [{ type: HostListener, args: ['click',] }]
};
if (false) {
    /** @type {?} */
    IgxCalendarYearDirective.prototype.value;
    /** @type {?} */
    IgxCalendarYearDirective.prototype.date;
    /** @type {?} */
    IgxCalendarYearDirective.prototype.onYearSelection;
}
export class IgxCalendarMonthDirective {
    /**
     * @param {?} elementRef
     */
    constructor(elementRef) {
        this.elementRef = elementRef;
        this.onMonthSelection = new EventEmitter();
        this.tabindex = 0;
    }
    /**
     * @return {?}
     */
    get defaultCSS() {
        return !this.isCurrentMonth;
    }
    /**
     * @return {?}
     */
    get currentCSS() {
        return this.isCurrentMonth;
    }
    /**
     * @return {?}
     */
    get isCurrentMonth() {
        return this.date.getMonth() === this.value.getMonth();
    }
    /**
     * @return {?}
     */
    get nativeElement() {
        return this.elementRef.nativeElement;
    }
    /**
     * @return {?}
     */
    onClick() {
        /** @type {?} */
        const date = new Date(this.value.getFullYear(), this.value.getMonth(), this.date.getDate());
        this.onMonthSelection.emit(date);
    }
}
IgxCalendarMonthDirective.decorators = [
    { type: Directive, args: [{
                selector: '[igxCalendarMonth]'
            },] }
];
/** @nocollapse */
IgxCalendarMonthDirective.ctorParameters = () => [
    { type: ElementRef }
];
IgxCalendarMonthDirective.propDecorators = {
    value: [{ type: Input, args: ['igxCalendarMonth',] }],
    date: [{ type: Input }],
    index: [{ type: Input }],
    onMonthSelection: [{ type: Output }],
    tabindex: [{ type: HostBinding, args: ['attr.tabindex',] }],
    defaultCSS: [{ type: HostBinding, args: ['class.igx-calendar__month',] }],
    currentCSS: [{ type: HostBinding, args: ['class.igx-calendar__month--current',] }],
    onClick: [{ type: HostListener, args: ['click',] }]
};
if (false) {
    /** @type {?} */
    IgxCalendarMonthDirective.prototype.value;
    /** @type {?} */
    IgxCalendarMonthDirective.prototype.date;
    /** @type {?} */
    IgxCalendarMonthDirective.prototype.index;
    /** @type {?} */
    IgxCalendarMonthDirective.prototype.onMonthSelection;
    /** @type {?} */
    IgxCalendarMonthDirective.prototype.tabindex;
    /** @type {?} */
    IgxCalendarMonthDirective.prototype.elementRef;
}
/**
 * @hidden
 */
export class IgxCalendarHeaderTemplateDirective {
    /**
     * @param {?} template
     */
    constructor(template) {
        this.template = template;
    }
}
IgxCalendarHeaderTemplateDirective.decorators = [
    { type: Directive, args: [{
                selector: '[igxCalendarHeader]'
            },] }
];
/** @nocollapse */
IgxCalendarHeaderTemplateDirective.ctorParameters = () => [
    { type: TemplateRef }
];
if (false) {
    /** @type {?} */
    IgxCalendarHeaderTemplateDirective.prototype.template;
}
/**
 * @hidden
 */
export class IgxCalendarSubheaderTemplateDirective {
    /**
     * @param {?} template
     */
    constructor(template) {
        this.template = template;
    }
}
IgxCalendarSubheaderTemplateDirective.decorators = [
    { type: Directive, args: [{
                selector: '[igxCalendarSubheader]'
            },] }
];
/** @nocollapse */
IgxCalendarSubheaderTemplateDirective.ctorParameters = () => [
    { type: TemplateRef }
];
if (false) {
    /** @type {?} */
    IgxCalendarSubheaderTemplateDirective.prototype.template;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2FsZW5kYXIuZGlyZWN0aXZlcy5qcyIsInNvdXJjZVJvb3QiOiJuZzovL2lnbml0ZXVpLWFuZ3VsYXIvIiwic291cmNlcyI6WyJsaWIvY2FsZW5kYXIvY2FsZW5kYXIuZGlyZWN0aXZlcy50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBTUEsT0FBTyxFQUNILFNBQVMsRUFDVCxZQUFZLEVBQ1osV0FBVyxFQUNYLFlBQVksRUFDWixLQUFLLEVBQ0wsTUFBTSxFQUNOLFdBQVcsRUFDWCxVQUFVLEVBQ2IsTUFBTSxlQUFlLENBQUM7Ozs7QUFRdkIsTUFBTSxPQUFPLHdCQUF3QjtJQUhyQztRQVlXLG9CQUFlLEdBQUcsSUFBSSxZQUFZLEVBQVEsQ0FBQztJQW9CdEQsQ0FBQzs7OztJQWxCRyxJQUNXLFVBQVU7UUFDakIsT0FBTyxDQUFDLElBQUksQ0FBQyxhQUFhLENBQUM7SUFDL0IsQ0FBQzs7OztJQUVELElBQ1csVUFBVTtRQUNqQixPQUFPLElBQUksQ0FBQyxhQUFhLENBQUM7SUFDOUIsQ0FBQzs7OztJQUVELElBQVcsYUFBYTtRQUNwQixPQUFPLElBQUksQ0FBQyxJQUFJLENBQUMsV0FBVyxFQUFFLEtBQUssSUFBSSxDQUFDLEtBQUssQ0FBQyxXQUFXLEVBQUUsQ0FBQztJQUNoRSxDQUFDOzs7O0lBR00sT0FBTztRQUNWLElBQUksQ0FBQyxlQUFlLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQztJQUMxQyxDQUFDOzs7WUEvQkosU0FBUyxTQUFDO2dCQUNQLFFBQVEsRUFBRSxtQkFBbUI7YUFDaEM7OztvQkFHSSxLQUFLLFNBQUMsaUJBQWlCO21CQUd2QixLQUFLOzhCQUdMLE1BQU07eUJBR04sV0FBVyxTQUFDLDBCQUEwQjt5QkFLdEMsV0FBVyxTQUFDLG1DQUFtQztzQkFTL0MsWUFBWSxTQUFDLE9BQU87Ozs7SUF2QnJCLHlDQUNtQjs7SUFFbkIsd0NBQ2tCOztJQUVsQixtREFDa0Q7O0FBeUJ0RCxNQUFNLE9BQU8seUJBQXlCOzs7O0lBbUNsQyxZQUFtQixVQUFzQjtRQUF0QixlQUFVLEdBQVYsVUFBVSxDQUFZO1FBdkJsQyxxQkFBZ0IsR0FBRyxJQUFJLFlBQVksRUFBUSxDQUFDO1FBRzVDLGFBQVEsR0FBRyxDQUFDLENBQUM7SUFvQndCLENBQUM7Ozs7SUFsQjdDLElBQ1csVUFBVTtRQUNqQixPQUFPLENBQUMsSUFBSSxDQUFDLGNBQWMsQ0FBQztJQUNoQyxDQUFDOzs7O0lBRUQsSUFDVyxVQUFVO1FBQ2pCLE9BQU8sSUFBSSxDQUFDLGNBQWMsQ0FBQztJQUMvQixDQUFDOzs7O0lBRUQsSUFBVyxjQUFjO1FBQ3JCLE9BQU8sSUFBSSxDQUFDLElBQUksQ0FBQyxRQUFRLEVBQUUsS0FBSyxJQUFJLENBQUMsS0FBSyxDQUFDLFFBQVEsRUFBRSxDQUFDO0lBQzFELENBQUM7Ozs7SUFFRCxJQUFXLGFBQWE7UUFDcEIsT0FBTyxJQUFJLENBQUMsVUFBVSxDQUFDLGFBQWEsQ0FBQztJQUN6QyxDQUFDOzs7O0lBS00sT0FBTzs7Y0FDSixJQUFJLEdBQUcsSUFBSSxJQUFJLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxXQUFXLEVBQUUsRUFBRSxJQUFJLENBQUMsS0FBSyxDQUFDLFFBQVEsRUFBRSxFQUFFLElBQUksQ0FBQyxJQUFJLENBQUMsT0FBTyxFQUFFLENBQUM7UUFDM0YsSUFBSSxDQUFDLGdCQUFnQixDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQztJQUNyQyxDQUFDOzs7WUE1Q0osU0FBUyxTQUFDO2dCQUNQLFFBQVEsRUFBRSxvQkFBb0I7YUFDakM7Ozs7WUExQ0csVUFBVTs7O29CQTZDVCxLQUFLLFNBQUMsa0JBQWtCO21CQUd4QixLQUFLO29CQUdMLEtBQUs7K0JBR0wsTUFBTTt1QkFHTixXQUFXLFNBQUMsZUFBZTt5QkFHM0IsV0FBVyxTQUFDLDJCQUEyQjt5QkFLdkMsV0FBVyxTQUFDLG9DQUFvQztzQkFlaEQsWUFBWSxTQUFDLE9BQU87Ozs7SUFuQ3JCLDBDQUNtQjs7SUFFbkIseUNBQ2tCOztJQUVsQiwwQ0FDYTs7SUFFYixxREFDbUQ7O0lBRW5ELDZDQUNvQjs7SUFvQlIsK0NBQTZCOzs7OztBQWU3QyxNQUFNLE9BQU8sa0NBQWtDOzs7O0lBRTNDLFlBQW1CLFFBQTBCO1FBQTFCLGFBQVEsR0FBUixRQUFRLENBQWtCO0lBQUcsQ0FBQzs7O1lBTHBELFNBQVMsU0FBQztnQkFDUCxRQUFRLEVBQUUscUJBQXFCO2FBQ2xDOzs7O1lBN0ZHLFdBQVc7Ozs7SUFnR0Msc0RBQWlDOzs7OztBQVNqRCxNQUFNLE9BQU8scUNBQXFDOzs7O0lBQzlDLFlBQW1CLFFBQTBCO1FBQTFCLGFBQVEsR0FBUixRQUFRLENBQWtCO0lBQUcsQ0FBQzs7O1lBSnBELFNBQVMsU0FBQztnQkFDUCxRQUFRLEVBQUUsd0JBQXdCO2FBQ3JDOzs7O1lBeEdHLFdBQVc7Ozs7SUEwR0MseURBQWlDIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBUaGlzIGZpbGUgY29udGFpbnMgYWxsIHRoZSBkaXJlY3RpdmVzIHVzZWQgYnkgdGhlIEBsaW5rIElneENhbGVuZGFyQ29tcG9uZW50LlxuICogRXhjZXB0IGZvciB0aGUgZGlyZWN0aXZlcyB3aGljaCBhcmUgdXNlZCBmb3IgdGVtcGxhdGluZyB0aGUgY2FsZW5kYXIgaXRzZWxmXG4gKiB5b3Ugc2hvdWxkIGdlbmVyYWxseSBub3QgdXNlIHRoZW0gZGlyZWN0bHkuXG4gKiBAcHJlZmVycmVkXG4gKi9cbmltcG9ydCB7XG4gICAgRGlyZWN0aXZlLFxuICAgIEV2ZW50RW1pdHRlcixcbiAgICBIb3N0QmluZGluZyxcbiAgICBIb3N0TGlzdGVuZXIsXG4gICAgSW5wdXQsXG4gICAgT3V0cHV0LFxuICAgIFRlbXBsYXRlUmVmLFxuICAgIEVsZW1lbnRSZWZcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbi8qKlxuICogQGhpZGRlblxuICovXG5ARGlyZWN0aXZlKHtcbiAgICBzZWxlY3RvcjogJ1tpZ3hDYWxlbmRhclllYXJdJ1xufSlcbmV4cG9ydCBjbGFzcyBJZ3hDYWxlbmRhclllYXJEaXJlY3RpdmUge1xuXG4gICAgQElucHV0KCdpZ3hDYWxlbmRhclllYXInKVxuICAgIHB1YmxpYyB2YWx1ZTogRGF0ZTtcblxuICAgIEBJbnB1dCgpXG4gICAgcHVibGljIGRhdGU6IERhdGU7XG5cbiAgICBAT3V0cHV0KClcbiAgICBwdWJsaWMgb25ZZWFyU2VsZWN0aW9uID0gbmV3IEV2ZW50RW1pdHRlcjxEYXRlPigpO1xuXG4gICAgQEhvc3RCaW5kaW5nKCdjbGFzcy5pZ3gtY2FsZW5kYXJfX3llYXInKVxuICAgIHB1YmxpYyBnZXQgZGVmYXVsdENTUygpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuICF0aGlzLmlzQ3VycmVudFllYXI7XG4gICAgfVxuXG4gICAgQEhvc3RCaW5kaW5nKCdjbGFzcy5pZ3gtY2FsZW5kYXJfX3llYXItLWN1cnJlbnQnKVxuICAgIHB1YmxpYyBnZXQgY3VycmVudENTUygpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNDdXJyZW50WWVhcjtcbiAgICB9XG5cbiAgICBwdWJsaWMgZ2V0IGlzQ3VycmVudFllYXIoKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGUuZ2V0RnVsbFllYXIoKSA9PT0gdGhpcy52YWx1ZS5nZXRGdWxsWWVhcigpO1xuICAgIH1cblxuICAgIEBIb3N0TGlzdGVuZXIoJ2NsaWNrJylcbiAgICBwdWJsaWMgb25DbGljaygpIHtcbiAgICAgICAgdGhpcy5vblllYXJTZWxlY3Rpb24uZW1pdCh0aGlzLnZhbHVlKTtcbiAgICB9XG59XG5cbkBEaXJlY3RpdmUoe1xuICAgIHNlbGVjdG9yOiAnW2lneENhbGVuZGFyTW9udGhdJ1xufSlcbmV4cG9ydCBjbGFzcyBJZ3hDYWxlbmRhck1vbnRoRGlyZWN0aXZlIHtcblxuICAgIEBJbnB1dCgnaWd4Q2FsZW5kYXJNb250aCcpXG4gICAgcHVibGljIHZhbHVlOiBEYXRlO1xuXG4gICAgQElucHV0KClcbiAgICBwdWJsaWMgZGF0ZTogRGF0ZTtcblxuICAgIEBJbnB1dCgpXG4gICAgcHVibGljIGluZGV4O1xuXG4gICAgQE91dHB1dCgpXG4gICAgcHVibGljIG9uTW9udGhTZWxlY3Rpb24gPSBuZXcgRXZlbnRFbWl0dGVyPERhdGU+KCk7XG5cbiAgICBASG9zdEJpbmRpbmcoJ2F0dHIudGFiaW5kZXgnKVxuICAgIHB1YmxpYyB0YWJpbmRleCA9IDA7XG5cbiAgICBASG9zdEJpbmRpbmcoJ2NsYXNzLmlneC1jYWxlbmRhcl9fbW9udGgnKVxuICAgIHB1YmxpYyBnZXQgZGVmYXVsdENTUygpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuICF0aGlzLmlzQ3VycmVudE1vbnRoO1xuICAgIH1cblxuICAgIEBIb3N0QmluZGluZygnY2xhc3MuaWd4LWNhbGVuZGFyX19tb250aC0tY3VycmVudCcpXG4gICAgcHVibGljIGdldCBjdXJyZW50Q1NTKCk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gdGhpcy5pc0N1cnJlbnRNb250aDtcbiAgICB9XG5cbiAgICBwdWJsaWMgZ2V0IGlzQ3VycmVudE1vbnRoKCk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gdGhpcy5kYXRlLmdldE1vbnRoKCkgPT09IHRoaXMudmFsdWUuZ2V0TW9udGgoKTtcbiAgICB9XG5cbiAgICBwdWJsaWMgZ2V0IG5hdGl2ZUVsZW1lbnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVsZW1lbnRSZWYubmF0aXZlRWxlbWVudDtcbiAgICB9XG5cbiAgICBjb25zdHJ1Y3RvcihwdWJsaWMgZWxlbWVudFJlZjogRWxlbWVudFJlZikge31cblxuICAgIEBIb3N0TGlzdGVuZXIoJ2NsaWNrJylcbiAgICBwdWJsaWMgb25DbGljaygpIHtcbiAgICAgICAgY29uc3QgZGF0ZSA9IG5ldyBEYXRlKHRoaXMudmFsdWUuZ2V0RnVsbFllYXIoKSwgdGhpcy52YWx1ZS5nZXRNb250aCgpLCB0aGlzLmRhdGUuZ2V0RGF0ZSgpKTtcbiAgICAgICAgdGhpcy5vbk1vbnRoU2VsZWN0aW9uLmVtaXQoZGF0ZSk7XG4gICAgfVxufVxuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuQERpcmVjdGl2ZSh7XG4gICAgc2VsZWN0b3I6ICdbaWd4Q2FsZW5kYXJIZWFkZXJdJ1xufSlcbmV4cG9ydCBjbGFzcyBJZ3hDYWxlbmRhckhlYWRlclRlbXBsYXRlRGlyZWN0aXZlIHtcblxuICAgIGNvbnN0cnVjdG9yKHB1YmxpYyB0ZW1wbGF0ZTogVGVtcGxhdGVSZWY8YW55Pikge31cbn1cblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbkBEaXJlY3RpdmUoe1xuICAgIHNlbGVjdG9yOiAnW2lneENhbGVuZGFyU3ViaGVhZGVyXSdcbn0pXG5leHBvcnQgY2xhc3MgSWd4Q2FsZW5kYXJTdWJoZWFkZXJUZW1wbGF0ZURpcmVjdGl2ZSB7XG4gICAgY29uc3RydWN0b3IocHVibGljIHRlbXBsYXRlOiBUZW1wbGF0ZVJlZjxhbnk+KSB7fVxufVxuIl19