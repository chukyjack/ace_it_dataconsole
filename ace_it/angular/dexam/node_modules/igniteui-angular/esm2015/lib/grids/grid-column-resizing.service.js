/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { Injectable, NgZone } from '@angular/core';
/**
 * @hidden
 */
export class IgxColumnResizingService {
    /**
     * @param {?} zone
     */
    constructor(zone) {
        this.zone = zone;
        /**
         * @hidden
         */
        this.resizeCursor = null;
        /**
         * @hidden
         */
        this.showResizer = false;
    }
    /**
     * @hidden
     * @return {?}
     */
    get resizerHeight() {
        /** @type {?} */
        let height = this.column.grid.getVisibleContentHeight();
        if (this.column.level !== 0) {
            height -= this.column.topLevelParent.headerGroup.height - this.column.headerGroup.height;
        }
        return height;
    }
    /**
     * Returns the minimal possible width to which the column can be resized.
     * @return {?}
     */
    get restrictResizeMin() {
        /** @type {?} */
        const actualMinWidth = parseFloat(this.column.minWidth);
        /** @type {?} */
        const defaultMinWidth = parseFloat(this.column.defaultMinWidth);
        /** @type {?} */
        let minWidth = Number.isNaN(actualMinWidth) || actualMinWidth < defaultMinWidth ? defaultMinWidth : actualMinWidth;
        minWidth = minWidth < parseFloat(this.column.width) ? minWidth : parseFloat(this.column.width);
        return this.column.headerCell.elementRef.nativeElement.getBoundingClientRect().width - minWidth;
    }
    /**
     * Returns the maximal possible width to which the column can be resized.
     * @return {?}
     */
    get restrictResizeMax() {
        /** @type {?} */
        const actualWidth = this.column.headerCell.elementRef.nativeElement.getBoundingClientRect().width;
        if (this.column.pinned) {
            /** @type {?} */
            const pinnedMaxWidth = this.pinnedMaxWidth =
                this.column.grid.calcPinnedContainerMaxWidth - this.column.grid.getPinnedWidth(true) + actualWidth;
            if (this.column.maxWidth && parseFloat(this.column.maxWidth) < pinnedMaxWidth) {
                this.pinnedMaxWidth = this.column.maxWidth;
                return parseFloat(this.column.maxWidth) - actualWidth;
            }
            else {
                return pinnedMaxWidth - actualWidth;
            }
        }
        else {
            if (this.column.maxWidth) {
                return parseFloat(this.column.maxWidth) - actualWidth;
            }
            else {
                return Number.MAX_SAFE_INTEGER;
            }
        }
    }
    /**
     * Autosizes the column to the longest currently visible cell value, including the header cell.
     * If the column has a predifined maxWidth and the autosized column width will become bigger than it,
     * then the column is sized to its maxWidth.
     * If the column is pinned and the autosized column width will cause the pinned area to become bigger
     * than the maximum allowed pinned area width (80% of the total grid width), autosizing will be deismissed.
     * @return {?}
     */
    autosizeColumnOnDblClick() {
        /** @type {?} */
        const currentColWidth = this.column.headerCell.elementRef.nativeElement.getBoundingClientRect().width;
        /** @type {?} */
        const size = this.column.getLargestCellWidth();
        if (this.column.pinned) {
            /** @type {?} */
            const newPinnedWidth = this.column.grid.getPinnedWidth(true) - currentColWidth + parseFloat(size);
            if (newPinnedWidth <= this.column.grid.calcPinnedContainerMaxWidth) {
                this.column.width = size;
            }
        }
        else if (this.column.maxWidth && (parseFloat(size) > parseFloat(this.column.maxWidth))) {
            this.column.width = parseFloat(this.column.maxWidth) + 'px';
        }
        else if (parseFloat(size) < parseFloat(this.column.defaultMinWidth)) {
            this.column.width = this.column.defaultMinWidth + 'px';
        }
        else {
            this.column.width = size;
        }
        this.zone.run(() => { });
        this.column.grid.reflow();
        this.column.grid.onColumnResized.emit({
            column: this.column,
            prevWidth: currentColWidth.toString(),
            newWidth: this.column.width
        });
    }
    /**
     * Resizes the column regaridng to the column minWidth and maxWidth.
     * @param {?} event
     * @return {?}
     */
    resizeColumn(event) {
        this.showResizer = false;
        /** @type {?} */
        const diff = event.clientX - this.startResizePos;
        /** @type {?} */
        let currentColWidth = parseFloat(this.column.width);
        /** @type {?} */
        const actualMinWidth = parseFloat(this.column.minWidth);
        /** @type {?} */
        const defaultMinWidth = parseFloat(this.column.defaultMinWidth);
        /** @type {?} */
        let colMinWidth = Number.isNaN(actualMinWidth) || actualMinWidth < defaultMinWidth ? defaultMinWidth : actualMinWidth;
        /** @type {?} */
        const colMaxWidth = this.column.pinned ? parseFloat(this.pinnedMaxWidth) : parseFloat(this.column.maxWidth);
        /** @type {?} */
        const actualWidth = this.column.headerCell.elementRef.nativeElement.getBoundingClientRect().width;
        currentColWidth = Number.isNaN(currentColWidth) || (currentColWidth < actualWidth) ? actualWidth : currentColWidth;
        colMinWidth = colMinWidth < currentColWidth ? colMinWidth : currentColWidth;
        if (currentColWidth + diff < colMinWidth) {
            this.column.width = colMinWidth + 'px';
        }
        else if (colMaxWidth && (currentColWidth + diff > colMaxWidth)) {
            this.column.width = colMaxWidth + 'px';
        }
        else {
            this.column.width = (currentColWidth + diff) + 'px';
        }
        this.zone.run(() => { });
        this.column.grid.reflow();
        if (currentColWidth !== parseFloat(this.column.width)) {
            this.column.grid.onColumnResized.emit({
                column: this.column,
                prevWidth: currentColWidth.toString(),
                newWidth: this.column.width
            });
        }
        this.isColumnResizing = false;
    }
}
IgxColumnResizingService.decorators = [
    { type: Injectable }
];
/** @nocollapse */
IgxColumnResizingService.ctorParameters = () => [
    { type: NgZone }
];
if (false) {
    /**
     * @type {?}
     * @private
     */
    IgxColumnResizingService.prototype.pinnedMaxWidth;
    /**
     * @hidden
     * @type {?}
     */
    IgxColumnResizingService.prototype.startResizePos;
    /**
     * Indicates that a column is currently being resized.
     * @type {?}
     */
    IgxColumnResizingService.prototype.isColumnResizing;
    /**
     * @hidden
     * @type {?}
     */
    IgxColumnResizingService.prototype.resizeCursor;
    /**
     * @hidden
     * @type {?}
     */
    IgxColumnResizingService.prototype.showResizer;
    /**
     * The column being resized.
     * @type {?}
     */
    IgxColumnResizingService.prototype.column;
    /**
     * @type {?}
     * @private
     */
    IgxColumnResizingService.prototype.zone;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZ3JpZC1jb2x1bW4tcmVzaXppbmcuc2VydmljZS5qcyIsInNvdXJjZVJvb3QiOiJuZzovL2lnbml0ZXVpLWFuZ3VsYXIvIiwic291cmNlcyI6WyJsaWIvZ3JpZHMvZ3JpZC1jb2x1bW4tcmVzaXppbmcuc2VydmljZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7O0FBQUEsT0FBTyxFQUFFLFVBQVUsRUFBRSxNQUFNLEVBQUUsTUFBTSxlQUFlLENBQUM7Ozs7QUFLbkQsTUFBTSxPQUFPLHdCQUF3Qjs7OztJQXlCakMsWUFBb0IsSUFBWTtRQUFaLFNBQUksR0FBSixJQUFJLENBQVE7Ozs7UUFWekIsaUJBQVksR0FBVyxJQUFJLENBQUM7Ozs7UUFJNUIsZ0JBQVcsR0FBRyxLQUFLLENBQUM7SUFNUyxDQUFDOzs7OztJQUtyQyxJQUFJLGFBQWE7O1lBQ1QsTUFBTSxHQUFHLElBQUksQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLHVCQUF1QixFQUFFO1FBRXZELElBQUksSUFBSSxDQUFDLE1BQU0sQ0FBQyxLQUFLLEtBQUssQ0FBQyxFQUFFO1lBQ3pCLE1BQU0sSUFBSSxJQUFJLENBQUMsTUFBTSxDQUFDLGNBQWMsQ0FBQyxXQUFXLENBQUMsTUFBTSxHQUFHLElBQUksQ0FBQyxNQUFNLENBQUMsV0FBVyxDQUFDLE1BQU0sQ0FBQztTQUM1RjtRQUVELE9BQU8sTUFBTSxDQUFDO0lBQ2xCLENBQUM7Ozs7O0lBS0QsSUFBSSxpQkFBaUI7O2NBQ1gsY0FBYyxHQUFHLFVBQVUsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLFFBQVEsQ0FBQzs7Y0FDakQsZUFBZSxHQUFHLFVBQVUsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLGVBQWUsQ0FBQzs7WUFFM0QsUUFBUSxHQUFHLE1BQU0sQ0FBQyxLQUFLLENBQUMsY0FBYyxDQUFDLElBQUksY0FBYyxHQUFHLGVBQWUsQ0FBQyxDQUFDLENBQUMsZUFBZSxDQUFDLENBQUMsQ0FBQyxjQUFjO1FBQ2xILFFBQVEsR0FBRyxRQUFR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LENBQUMsTUFBTSxDQUFDLEtBQUs7YUFDOUIsQ0FBQyxDQUFDO1NBQ047UUFFRCxJQUFJLENBQUMsZ0JBQWdCLEdBQUcsS0FBSyxDQUFDO0lBQ2xDLENBQUM7OztZQTVKSixVQUFVOzs7O1lBSlUsTUFBTTs7Ozs7OztJQU92QixrREFBK0I7Ozs7O0lBSy9CLGtEQUE4Qjs7Ozs7SUFJOUIsb0RBQWlDOzs7OztJQUlqQyxnREFBbUM7Ozs7O0lBSW5DLCtDQUEyQjs7Ozs7SUFJM0IsMENBQWtDOzs7OztJQUV0Qix3Q0FBb0IiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBJbmplY3RhYmxlLCBOZ1pvbmUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IElneENvbHVtbkNvbXBvbmVudCB9IGZyb20gJy4vY29sdW1uLmNvbXBvbmVudCc7XG5cbi8qKiBAaGlkZGVuICovXG5ASW5qZWN0YWJsZSgpXG5leHBvcnQgY2xhc3MgSWd4Q29sdW1uUmVzaXppbmdTZXJ2aWNlIHtcblxuICAgIHByaXZhdGUgcGlubmVkTWF4V2lkdGg6IHN0cmluZztcblxuICAgIC8qKlxuICAgICAqQGhpZGRlblxuICAgICAqL1xuICAgIHB1YmxpYyBzdGFydFJlc2l6ZVBvczogbnVtYmVyO1xuICAgIC8qKlxuICAgICAqIEluZGljYXRlcyB0aGF0IGEgY29sdW1uIGlzIGN1cnJlbnRseSBiZWluZyByZXNpemVkLlxuICAgICAqL1xuICAgIHB1YmxpYyBpc0NvbHVtblJlc2l6aW5nOiBib29sZWFuO1xuICAgIC8qKlxuICAgICAqQGhpZGRlblxuICAgICAqL1xuICAgIHB1YmxpYyByZXNpemVDdXJzb3I6IHN0cmluZyA9IG51bGw7XG4gICAgLyoqXG4gICAgICpAaGlkZGVuXG4gICAgICovXG4gICAgcHVibGljIHNob3dSZXNpemVyID0gZmFsc2U7XG4gICAgLyoqXG4gICAgICogVGhlIGNvbHVtbiBiZWluZyByZXNpemVkLlxuICAgICAqL1xuICAgIHB1YmxpYyBjb2x1bW46IElneENvbHVtbkNvbXBvbmVudDtcblxuICAgIGNvbnN0cnVjdG9yKHByaXZhdGUgem9uZTogTmdab25lKSB7IH1cblxuICAgIC8qKlxuICAgICAqQGhpZGRlblxuICAgICAqL1xuICAgIGdldCByZXNpemVySGVpZ2h0KCk6IG51bWJlciB7XG4gICAgICAgIGxldCBoZWlnaHQgPSB0aGlzLmNvbHVtbi5ncmlkLmdldFZpc2libGVDb250ZW50SGVpZ2h0KCk7XG5cbiAgICAgICAgaWYgKHRoaXMuY29sdW1uLmxldmVsICE9PSAwKSB7XG4gICAgICAgICAgICBoZWlnaHQgLT0gdGhpcy5jb2x1bW4udG9wTGV2ZWxQYXJlbnQuaGVhZGVyR3JvdXAuaGVpZ2h0IC0gdGhpcy5jb2x1bW4uaGVhZGVyR3JvdXAuaGVpZ2h0O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGhlaWdodDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBtaW5pbWFsIHBvc3NpYmxlIHdpZHRoIHRvIHdoaWNoIHRoZSBjb2x1bW4gY2FuIGJlIHJlc2l6ZWQuXG4gICAgICovXG4gICAgZ2V0IHJlc3RyaWN0UmVzaXplTWluKCk6IG51bWJlciB7XG4gICAgICAgIGNvbnN0IGFjdHVhbE1pbldpZHRoID0gcGFyc2VGbG9hdCh0aGlzLmNvbHVtbi5taW5XaWR0aCk7XG4gICAgICAgIGNvbnN0IGRlZmF1bHRNaW5XaWR0aCA9IHBhcnNlRmxvYXQodGhpcy5jb2x1bW4uZGVmYXVsdE1pbldpZHRoKTtcblxuICAgICAgICBsZXQgbWluV2lkdGggPSBOdW1iZXIuaXNOYU4oYWN0dWFsTWluV2lkdGgpIHx8IGFjdHVhbE1pbldpZHRoIDwgZGVmYXVsdE1pbldpZHRoID8gZGVmYXVsdE1pbldpZHRoIDogYWN0dWFsTWluV2lkdGg7XG4gICAgICAgIG1pbldpZHRoID0gbWluV2lkdGggPCBwYXJzZUZsb2F0KHRoaXMuY29sdW1uLndpZHRoKSA/IG1pbldpZHRoIDogcGFyc2VGbG9hdCh0aGlzLmNvbHVtbi53aWR0aCk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuY29sdW1uLmhlYWRlckNlbGwuZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLndpZHRoIC0gbWluV2lkdGg7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgbWF4aW1hbCBwb3NzaWJsZSB3aWR0aCB0byB3aGljaCB0aGUgY29sdW1uIGNhbiBiZSByZXNpemVkLlxuICAgICAqL1xuICAgIGdldCByZXN0cmljdFJlc2l6ZU1heCgpOiBudW1iZXIge1xuICAgICAgICBjb25zdCBhY3R1YWxXaWR0aCA9IHRoaXMuY29sdW1uLmhlYWRlckNlbGwuZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLndpZHRoO1xuXG4gICAgICAgIGlmICh0aGlzLmNvbHVtbi5waW5uZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IHBpbm5lZE1heFdpZHRoID0gdGhpcy5waW5uZWRNYXhXaWR0aCA9XG4gICAgICAgICAgICAgICAgdGhpcy5jb2x1bW4uZ3JpZC5jYWxjUGlubmVkQ29udGFpbmVyTWF4V2lkdGggLSB0aGlzLmNvbHVtbi5ncmlkLmdldFBpbm5lZFdpZHRoKHRydWUpICsgYWN0dWFsV2lkdGg7XG5cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbHVtbi5tYXhXaWR0aCAmJiBwYXJzZUZsb2F0KHRoaXMuY29sdW1uLm1heFdpZHRoKSA8IHBpbm5lZE1heFdpZHRoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5waW5uZWRNYXhXaWR0aCA9IHRoaXMuY29sdW1uLm1heFdpZHRoO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlRmxvYXQodGhpcy5jb2x1bW4ubWF4V2lkdGgpIC0gYWN0dWFsV2lkdGg7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBwaW5uZWRNYXhXaWR0aCAtIGFjdHVhbFdpZHRoO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKHRoaXMuY29sdW1uLm1heFdpZHRoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlRmxvYXQodGhpcy5jb2x1bW4ubWF4V2lkdGgpIC0gYWN0dWFsV2lkdGg7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEF1dG9zaXplcyB0aGUgY29sdW1uIHRvIHRoZSBsb25nZXN0IGN1cnJlbnRseSB2aXNpYmxlIGNlbGwgdmFsdWUsIGluY2x1ZGluZyB0aGUgaGVhZGVyIGNlbGwuXG4gICAgICogSWYgdGhlIGNvbHVtbiBoYXMgYSBwcmVkaWZpbmVkIG1heFdpZHRoIGFuZCB0aGUgYXV0b3NpemVkIGNvbHVtbiB3aWR0aCB3aWxsIGJlY29tZSBiaWdnZXIgdGhhbiBpdCxcbiAgICAgKiB0aGVuIHRoZSBjb2x1bW4gaXMgc2l6ZWQgdG8gaXRzIG1heFdpZHRoLlxuICAgICAqIElmIHRoZSBjb2x1bW4gaXMgcGlubmVkIGFuZCB0aGUgYXV0b3NpemVkIGNvbHVtbiB3aWR0aCB3aWxsIGNhdXNlIHRoZSBwaW5uZWQgYXJlYSB0byBiZWNvbWUgYmlnZ2VyXG4gICAgICogdGhhbiB0aGUgbWF4aW11bSBhbGxvd2VkIHBpbm5lZCBhcmVhIHdpZHRoICg4MCUgb2YgdGhlIHRvdGFsIGdyaWQgd2lkdGgpLCBhdXRvc2l6aW5nIHdpbGwgYmUgZGVpc21pc3NlZC5cbiAgICAgKi9cbiAgICBwdWJsaWMgYXV0b3NpemVDb2x1bW5PbkRibENsaWNrKCkge1xuICAgICAgICBjb25zdCBjdXJyZW50Q29sV2lkdGggPSB0aGlzLmNvbHVtbi5oZWFkZXJDZWxsLmVsZW1lbnRSZWYubmF0aXZlRWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS53aWR0aDtcblxuICAgICAgICBjb25zdCBzaXplID0gdGhpcy5jb2x1bW4uZ2V0TGFyZ2VzdENlbGxXaWR0aCgpO1xuXG4gICAgICAgIGlmICh0aGlzLmNvbHVtbi5waW5uZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IG5ld1Bpbm5lZFdpZHRoID0gdGhpcy5jb2x1bW4uZ3JpZC5nZXRQaW5uZWRXaWR0aCh0cnVlKSAtIGN1cnJlbnRDb2xXaWR0aCArIHBhcnNlRmxvYXQoc2l6ZSk7XG5cbiAgICAgICAgICAgIGlmIChuZXdQaW5uZWRXaWR0aCA8PSB0aGlzLmNvbHVtbi5ncmlkLmNhbGNQaW5uZWRDb250YWluZXJNYXhXaWR0aCkge1xuICAgICAgICAgICAgICAgIHRoaXMuY29sdW1uLndpZHRoID0gc2l6ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLmNvbHVtbi5tYXhXaWR0aCAmJiAocGFyc2VGbG9hdChzaXplKSA+IHBhcnNlRmxvYXQodGhpcy5jb2x1bW4ubWF4V2lkdGgpKSkge1xuICAgICAgICAgICAgdGhpcy5jb2x1bW4ud2lkdGggPSBwYXJzZUZsb2F0KHRoaXMuY29sdW1uLm1heFdpZHRoKSArICdweCc7XG4gICAgICAgIH0gZWxzZSBpZiAocGFyc2VGbG9hdChzaXplKSA8IHBhcnNlRmxvYXQodGhpcy5jb2x1bW4uZGVmYXVsdE1pbldpZHRoKSkge1xuICAgICAgICAgICAgdGhpcy5jb2x1bW4ud2lkdGggPSB0aGlzLmNvbHVtbi5kZWZhdWx0TWluV2lkdGggKyAncHgnO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5jb2x1bW4ud2lkdGggPSBzaXplO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy56b25lLnJ1bigoKSA9PiB7fSk7XG5cbiAgICAgICAgdGhpcy5jb2x1bW4uZ3JpZC5yZWZsb3coKTtcbiAgICAgICAgdGhpcy5jb2x1bW4uZ3JpZC5vbkNvbHVtblJlc2l6ZWQuZW1pdCh7XG4gICAgICAgICAgICBjb2x1bW46IHRoaXMuY29sdW1uLFxuICAgICAgICAgICAgcHJldldpZHRoOiBjdXJyZW50Q29sV2lkdGgudG9TdHJpbmcoKSxcbiAgICAgICAgICAgIG5ld1dpZHRoOiB0aGlzLmNvbHVtbi53aWR0aFxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXNpemVzIHRoZSBjb2x1bW4gcmVnYXJpZG5nIHRvIHRoZSBjb2x1bW4gbWluV2lkdGggYW5kIG1heFdpZHRoLlxuICAgICAqL1xuICAgIHB1YmxpYyByZXNpemVDb2x1bW4oZXZlbnQ6IE1vdXNlRXZlbnQpIHtcbiAgICAgICAgdGhpcy5zaG93UmVzaXplciA9IGZhbHNlO1xuICAgICAgICBjb25zdCBkaWZmID0gZXZlbnQuY2xpZW50WCAtIHRoaXMuc3RhcnRSZXNpemVQb3M7XG5cbiAgICAgICAgbGV0IGN1cnJlbnRDb2xXaWR0aCA9IHBhcnNlRmxvYXQodGhpcy5jb2x1bW4ud2lkdGgpO1xuXG4gICAgICAgIGNvbnN0IGFjdHVhbE1pbldpZHRoID0gcGFyc2VGbG9hdCh0aGlzLmNvbHVtbi5taW5XaWR0aCk7XG4gICAgICAgIGNvbnN0IGRlZmF1bHRNaW5XaWR0aCA9IHBhcnNlRmxvYXQodGhpcy5jb2x1bW4uZGVmYXVsdE1pbldpZHRoKTtcblxuICAgICAgICBsZXQgY29sTWluV2lkdGggPSBOdW1iZXIuaXNOYU4oYWN0dWFsTWluV2lkdGgpIHx8IGFjdHVhbE1pbldpZHRoIDwgZGVmYXVsdE1pbldpZHRoID8gZGVmYXVsdE1pbldpZHRoIDogYWN0dWFsTWluV2lkdGg7XG4gICAgICAgIGNvbnN0IGNvbE1heFdpZHRoID0gdGhpcy5jb2x1bW4ucGlubmVkID8gcGFyc2VGbG9hdCh0aGlzLnBpbm5lZE1heFdpZHRoKSA6IHBhcnNlRmxvYXQodGhpcy5jb2x1bW4ubWF4V2lkdGgpO1xuXG4gICAgICAgIGNvbnN0IGFjdHVhbFdpZHRoID0gdGhpcy5jb2x1bW4uaGVhZGVyQ2VsbC5lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkud2lkdGg7XG5cbiAgICAgICAgY3VycmVudENvbFdpZHRoID0gTnVtYmVyLmlzTmFOKGN1cnJlbnRDb2xXaWR0aCkgfHwgKGN1cnJlbnRDb2xXaWR0aCA8IGFjdHVhbFdpZHRoKSA/IGFjdHVhbFdpZHRoIDogY3VycmVudENvbFdpZHRoO1xuICAgICAgICBjb2xNaW5XaWR0aCA9IGNvbE1pbldpZHRoIDwgY3VycmVudENvbFdpZHRoID8gY29sTWluV2lkdGggOiBjdXJyZW50Q29sV2lkdGg7XG5cbiAgICAgICAgaWYgKGN1cnJlbnRDb2xXaWR0aCArIGRpZmYgPCBjb2xNaW5XaWR0aCkge1xuICAgICAgICAgICAgdGhpcy5jb2x1bW4ud2lkdGggPSBjb2xNaW5XaWR0aCArICdweCc7XG4gICAgICAgIH0gZWxzZSBpZiAoY29sTWF4V2lkdGggJiYgKGN1cnJlbnRDb2xXaWR0aCArIGRpZmYgPiBjb2xNYXhXaWR0aCkpIHtcbiAgICAgICAgICAgIHRoaXMuY29sdW1uLndpZHRoID0gY29sTWF4V2lkdGggKyAncHgnO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5jb2x1bW4ud2lkdGggPSAoY3VycmVudENvbFdpZHRoICsgZGlmZikgKyAncHgnO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy56b25lLnJ1bigoKSA9PiB7fSk7XG4gICAgICAgIHRoaXMuY29sdW1uLmdyaWQucmVmbG93KCk7XG5cbiAgICAgICAgaWYgKGN1cnJlbnRDb2xXaWR0aCAhPT0gcGFyc2VGbG9hdCh0aGlzLmNvbHVtbi53aWR0aCkpIHtcbiAgICAgICAgICAgIHRoaXMuY29sdW1uLmdyaWQub25Db2x1bW5SZXNpemVkLmVtaXQoe1xuICAgICAgICAgICAgICAgIGNvbHVtbjogdGhpcy5jb2x1bW4sXG4gICAgICAgICAgICAgICAgcHJldldpZHRoOiBjdXJyZW50Q29sV2lkdGgudG9TdHJpbmcoKSxcbiAgICAgICAgICAgICAgICBuZXdXaWR0aDogdGhpcy5jb2x1bW4ud2lkdGhcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5pc0NvbHVtblJlc2l6aW5nID0gZmFsc2U7XG4gICAgfVxufVxuIl19