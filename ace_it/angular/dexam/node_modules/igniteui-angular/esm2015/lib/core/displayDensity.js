/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { InjectionToken, Input, Output, EventEmitter } from '@angular/core';
/** @enum {string} */
const DisplayDensity = {
    comfortable: 'comfortable',
    cosy: 'cosy',
    compact: 'compact',
};
export { DisplayDensity };
/**
 * Describes the object used to configure the DisplayDensity in Angular DI.
 * @record
 */
export function IDisplayDensityOptions() { }
if (false) {
    /** @type {?} */
    IDisplayDensityOptions.prototype.displayDensity;
}
/**
 * @record
 */
export function IDensityChangedEventArgs() { }
if (false) {
    /** @type {?} */
    IDensityChangedEventArgs.prototype.oldDensity;
    /** @type {?} */
    IDensityChangedEventArgs.prototype.newDensity;
}
/**
 * Defines the DisplayDensity DI token.
 * @type {?}
 */
export const DisplayDensityToken = new InjectionToken('DisplayDensity');
/**
 * Base class containing all logic required for implementing DisplayDensity.
 */
export class DisplayDensityBase {
    /**
     * @param {?} displayDensityOptions
     */
    constructor(displayDensityOptions) {
        this.displayDensityOptions = displayDensityOptions;
        this.onDensityChanged = new EventEmitter();
        this.oldDisplayDensityOptions = { displayDensity: DisplayDensity.comfortable };
        Object.assign(this.oldDisplayDensityOptions, displayDensityOptions);
    }
    /**
     * Returns the theme of the component.
     * The default theme is `comfortable`.
     * Available options are `comfortable`, `cosy`, `compact`.
     * ```typescript
     * let componentTheme = this.component.displayDensity;
     * ```
     * @return {?}
     */
    get displayDensity() {
        return this._displayDensity ||
            ((this.displayDensityOptions && this.displayDensityOptions.displayDensity) || DisplayDensity.comfortable);
    }
    /**
     * Sets the theme of the component.
     * @param {?} val
     * @return {?}
     */
    set displayDensity(val) {
        /** @type {?} */
        const currentDisplayDensity = this._displayDensity;
        this._displayDensity = (/** @type {?} */ (val));
        if (currentDisplayDensity !== this._displayDensity) {
            /** @type {?} */
            const densityChangedArgs = {
                oldDensity: currentDisplayDensity,
                newDensity: this._displayDensity
            };
            this.onDensityChanged.emit(densityChangedArgs);
        }
    }
    /**
     * @return {?}
     */
    ngDoCheck() {
        if (!this._displayDensity && this.displayDensityOptions &&
            this.oldDisplayDensityOptions.displayDensity !== this.displayDensityOptions.displayDensity) {
            /** @type {?} */
            const densityChangedArgs = {
                oldDensity: this.oldDisplayDensityOptions.displayDensity,
                newDensity: this.displayDensityOptions.displayDensity
            };
            this.onDensityChanged.emit(densityChangedArgs);
            this.oldDisplayDensityOptions = Object.assign(this.oldDisplayDensityOptions, this.displayDensityOptions);
        }
    }
    /**
     * Given a style class of a component/element returns the modified version of it based
     * on the current display density.
     * @protected
     * @param {?} baseStyleClass
     * @return {?}
     */
    getComponentDensityClass(baseStyleClass) {
        switch (this.displayDensity) {
            case DisplayDensity.cosy:
                return `${baseStyleClass}--${DisplayDensity.cosy}`;
            case DisplayDensity.compact:
                return `${baseStyleClass}--${DisplayDensity.compact}`;
            default:
                return baseStyleClass;
        }
    }
}
DisplayDensityBase.propDecorators = {
    displayDensity: [{ type: Input }],
    onDensityChanged: [{ type: Output }]
};
if (false) {
    /**
     * @type {?}
     * @protected
     */
    DisplayDensityBase.prototype._displayDensity;
    /** @type {?} */
    DisplayDensityBase.prototype.onDensityChanged;
    /**
     * @type {?}
     * @protected
     */
    DisplayDensityBase.prototype.oldDisplayDensityOptions;
    /**
     * @type {?}
     * @protected
     */
    DisplayDensityBase.prototype.displayDensityOptions;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGlzcGxheURlbnNpdHkuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9pZ25pdGV1aS1hbmd1bGFyLyIsInNvdXJjZXMiOlsibGliL2NvcmUvZGlzcGxheURlbnNpdHkudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7OztBQUFBLE9BQU8sRUFBRSxjQUFjLEVBQUUsS0FBSyxFQUFFLE1BQU0sRUFBRSxZQUFZLEVBQVcsTUFBTSxlQUFlLENBQUM7OztJQU9qRixhQUFjLGFBQWE7SUFDM0IsTUFBTyxNQUFNO0lBQ2IsU0FBVSxTQUFTOzs7Ozs7O0FBTXZCLDRDQUVDOzs7SUFERyxnREFBK0I7Ozs7O0FBR25DLDhDQUdDOzs7SUFGRyw4Q0FBMkI7O0lBQzNCLDhDQUEyQjs7Ozs7O0FBTS9CLE1BQU0sT0FBTyxtQkFBbUIsR0FBRyxJQUFJLGNBQWMsQ0FBeUIsZ0JBQWdCLENBQUM7Ozs7QUFLL0YsTUFBTSxPQUFPLGtCQUFrQjs7OztJQXdDM0IsWUFBc0IscUJBQTZDO1FBQTdDLDBCQUFxQixHQUFyQixxQkFBcUIsQ0FBd0I7UUFMNUQscUJBQWdCLEdBQUcsSUFBSSxZQUFZLEVBQTRCLENBQUM7UUFFN0QsNkJBQXdCLEdBQTJCLEVBQUUsY0FBYyxFQUFFLGNBQWMsQ0FBQyxXQUFXLEVBQUUsQ0FBQztRQUl4RyxNQUFNLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyx3QkFBd0IsRUFBRSxxQkFBcUIsQ0FBQyxDQUFDO0lBQ3hFLENBQUM7Ozs7Ozs7Ozs7SUEvQkQsSUFDVyxjQUFjO1FBQ3JCLE9BQU8sSUFBSSxDQUFDLGVBQWU7WUFDdkIsQ0FBQyxDQUFDLElBQUksQ0FBQyxxQkFBcUIsSUFBSSxJQUFJLENBQUMscUJBQXFCLENBQUMsY0FBYyxDQUFDLElBQUksY0FBYyxDQUFDLFdBQVcsQ0FBQyxDQUFDO0lBQ2xILENBQUM7Ozs7OztJQUtELElBQVcsY0FBYyxDQUFDLEdBQTRCOztjQUM1QyxxQkFBcUIsR0FBRyxJQUFJLENBQUMsZUFBZTtRQUNsRCxJQUFJLENBQUMsZUFBZSxHQUFHLG1CQUFBLEdBQUcsRUFBa0IsQ0FBQztRQUU3QyxJQUFJLHFCQUFxQixLQUFLLElBQUksQ0FBQyxlQUFlLEVBQUU7O2tCQUMxQyxrQkFBa0IsR0FBNkI7Z0JBQ2pELFVBQVUsRUFBRSxxQkFBcUI7Z0JBQ2pDLFVBQVUsRUFBRSxJQUFJLENBQUMsZUFBZTthQUNuQztZQUVELElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxJQUFJLENBQUMsa0JBQWtCLENBQUMsQ0FBQztTQUNsRDtJQUNMLENBQUM7Ozs7SUFZTSxTQUFTO1FBQ1osSUFBSSxDQUFDLElBQUksQ0FBQyxlQUFlLElBQUksSUFBSSxDQUFDLHFCQUFxQjtZQUMvQyxJQUFJLENBQUMsd0JBQXdCLENBQUMsY0FBYyxLQUFLLElBQUksQ0FBQyxxQkFBcUIsQ0FBQyxjQUFjLEVBQUU7O2tCQUMxRixrQkFBa0IsR0FBNkI7Z0JBQ2pELFVBQVUsRUFBRSxJQUFJLENBQUMsd0JBQXdCLENBQUMsY0FBYztnQkFDeEQsVUFBVSxFQUFFLElBQUksQ0FBQyxxQkFBcUIsQ0FBQyxjQUFjO2FBQ3hEO1lBRUQsSUFBSSxDQUFDLGdCQUFnQixDQUFDLElBQUksQ0FBQyxrQkFBa0IsQ0FBQyxDQUFDO1lBQy9DLElBQUksQ0FBQyx3QkFBd0IsR0FBRyxNQUFNLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyx3QkFBd0IsRUFBRSxJQUFJLENBQUMscUJBQXFCLENBQUMsQ0FBQztTQUM1RztJQUNMLENBQUM7Ozs7Ozs7O0lBTVMsd0JBQXdCLENBQUMsY0FBc0I7UUFDckQsUUFBUSxJQUFJLENBQUMsY0FBYyxFQUFFO1lBQ3pCLEtBQUssY0FBYyxDQUFDLElBQUk7Z0JBQ3BCLE9BQU8sR0FBRyxjQUFjLEtBQUssY0FBYyxDQUFDLElBQUksRUFBRSxDQUFDO1lBQ3ZELEtBQUssY0FBYyxDQUFDLE9BQU87Z0JBQ3ZCLE9BQU8sR0FBRyxjQUFjLEtBQUssY0FBYyxDQUFDLE9BQU8sRUFBRSxDQUFDO1lBQzFEO2dCQUNJLE9BQU8sY0FBYyxDQUFDO1NBQzdCO0lBQ0wsQ0FBQzs7OzZCQTNEQSxLQUFLOytCQXVCTCxNQUFNOzs7Ozs7O0lBakNQLDZDQUEwQzs7SUFpQzFDLDhDQUN1RTs7Ozs7SUFFdkUsc0RBQTRHOzs7OztJQUdoRyxtREFBdUQiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBJbmplY3Rpb25Ub2tlbiwgSW5wdXQsIE91dHB1dCwgRXZlbnRFbWl0dGVyLCBEb0NoZWNrIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cblxuLyoqXG4gKiBEZWZpbmVzIHRoZSBwb3NpYmxlIHZhbHVlcyBvZiB0aGUgY29tcG9uZW50cycgZGlzcGxheSBkZW5zaXR5LlxuICovXG5leHBvcnQgZW51bSBEaXNwbGF5RGVuc2l0eSB7XG4gICAgY29tZm9ydGFibGUgPSAnY29tZm9ydGFibGUnLFxuICAgIGNvc3kgPSAnY29zeScsXG4gICAgY29tcGFjdCA9ICdjb21wYWN0J1xufVxuXG4vKipcbiAqIERlc2NyaWJlcyB0aGUgb2JqZWN0IHVzZWQgdG8gY29uZmlndXJlIHRoZSBEaXNwbGF5RGVuc2l0eSBpbiBBbmd1bGFyIERJLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIElEaXNwbGF5RGVuc2l0eU9wdGlvbnMge1xuICAgIGRpc3BsYXlEZW5zaXR5OiBEaXNwbGF5RGVuc2l0eTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBJRGVuc2l0eUNoYW5nZWRFdmVudEFyZ3Mge1xuICAgIG9sZERlbnNpdHk6IERpc3BsYXlEZW5zaXR5O1xuICAgIG5ld0RlbnNpdHk6IERpc3BsYXlEZW5zaXR5O1xufVxuXG4vKipcbiAqIERlZmluZXMgdGhlIERpc3BsYXlEZW5zaXR5IERJIHRva2VuLlxuICovXG5leHBvcnQgY29uc3QgRGlzcGxheURlbnNpdHlUb2tlbiA9IG5ldyBJbmplY3Rpb25Ub2tlbjxJRGlzcGxheURlbnNpdHlPcHRpb25zPignRGlzcGxheURlbnNpdHknKTtcblxuLyoqXG4gKiBCYXNlIGNsYXNzIGNvbnRhaW5pbmcgYWxsIGxvZ2ljIHJlcXVpcmVkIGZvciBpbXBsZW1lbnRpbmcgRGlzcGxheURlbnNpdHkuXG4gKi9cbmV4cG9ydCBjbGFzcyBEaXNwbGF5RGVuc2l0eUJhc2UgaW1wbGVtZW50cyBEb0NoZWNrIHtcbiAgICBwcm90ZWN0ZWQgX2Rpc3BsYXlEZW5zaXR5OiBEaXNwbGF5RGVuc2l0eTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHRoZW1lIG9mIHRoZSBjb21wb25lbnQuXG4gICAgICogVGhlIGRlZmF1bHQgdGhlbWUgaXMgYGNvbWZvcnRhYmxlYC5cbiAgICAgKiBBdmFpbGFibGUgb3B0aW9ucyBhcmUgYGNvbWZvcnRhYmxlYCwgYGNvc3lgLCBgY29tcGFjdGAuXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIGxldCBjb21wb25lbnRUaGVtZSA9IHRoaXMuY29tcG9uZW50LmRpc3BsYXlEZW5zaXR5O1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgcHVibGljIGdldCBkaXNwbGF5RGVuc2l0eSgpOiBEaXNwbGF5RGVuc2l0eSB8IHN0cmluZyB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kaXNwbGF5RGVuc2l0eSB8fFxuICAgICAgICAgICAgKCh0aGlzLmRpc3BsYXlEZW5zaXR5T3B0aW9ucyAmJiB0aGlzLmRpc3BsYXlEZW5zaXR5T3B0aW9ucy5kaXNwbGF5RGVuc2l0eSkgfHwgRGlzcGxheURlbnNpdHkuY29tZm9ydGFibGUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIHRoZW1lIG9mIHRoZSBjb21wb25lbnQuXG4gICAgICovXG4gICAgcHVibGljIHNldCBkaXNwbGF5RGVuc2l0eSh2YWw6IERpc3BsYXlEZW5zaXR5IHwgc3RyaW5nKSB7XG4gICAgICAgIGNvbnN0IGN1cnJlbnREaXNwbGF5RGVuc2l0eSA9IHRoaXMuX2Rpc3BsYXlEZW5zaXR5O1xuICAgICAgICB0aGlzLl9kaXNwbGF5RGVuc2l0eSA9IHZhbCBhcyBEaXNwbGF5RGVuc2l0eTtcblxuICAgICAgICBpZiAoY3VycmVudERpc3BsYXlEZW5zaXR5ICE9PSB0aGlzLl9kaXNwbGF5RGVuc2l0eSkge1xuICAgICAgICAgICAgY29uc3QgZGVuc2l0eUNoYW5nZWRBcmdzOiBJRGVuc2l0eUNoYW5nZWRFdmVudEFyZ3MgPSB7XG4gICAgICAgICAgICAgICAgb2xkRGVuc2l0eTogY3VycmVudERpc3BsYXlEZW5zaXR5LFxuICAgICAgICAgICAgICAgIG5ld0RlbnNpdHk6IHRoaXMuX2Rpc3BsYXlEZW5zaXR5XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICB0aGlzLm9uRGVuc2l0eUNoYW5nZWQuZW1pdChkZW5zaXR5Q2hhbmdlZEFyZ3MpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgQE91dHB1dCgpXG4gICAgcHVibGljIG9uRGVuc2l0eUNoYW5nZWQgPSBuZXcgRXZlbnRFbWl0dGVyPElEZW5zaXR5Q2hhbmdlZEV2ZW50QXJncz4oKTtcblxuICAgIHByb3RlY3RlZCBvbGREaXNwbGF5RGVuc2l0eU9wdGlvbnM6IElEaXNwbGF5RGVuc2l0eU9wdGlvbnMgPSB7IGRpc3BsYXlEZW5zaXR5OiBEaXNwbGF5RGVuc2l0eS5jb21mb3J0YWJsZSB9O1xuXG5cbiAgICBjb25zdHJ1Y3Rvcihwcm90ZWN0ZWQgZGlzcGxheURlbnNpdHlPcHRpb25zOiBJRGlzcGxheURlbnNpdHlPcHRpb25zKSB7XG4gICAgICAgIE9iamVjdC5hc3NpZ24odGhpcy5vbGREaXNwbGF5RGVuc2l0eU9wdGlvbnMsIGRpc3BsYXlEZW5zaXR5T3B0aW9ucyk7XG4gICAgfVxuXG4gICAgcHVibGljIG5nRG9DaGVjaygpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9kaXNwbGF5RGVuc2l0eSAmJiB0aGlzLmRpc3BsYXlEZW5zaXR5T3B0aW9ucyAmJlxuICAgICAgICAgICAgICAgIHRoaXMub2xkRGlzcGxheURlbnNpdHlPcHRpb25zLmRpc3BsYXlEZW5zaXR5ICE9PSB0aGlzLmRpc3BsYXlEZW5zaXR5T3B0aW9ucy5kaXNwbGF5RGVuc2l0eSkge1xuICAgICAgICAgICAgY29uc3QgZGVuc2l0eUNoYW5nZWRBcmdzOiBJRGVuc2l0eUNoYW5nZWRFdmVudEFyZ3MgPSB7XG4gICAgICAgICAgICAgICAgb2xkRGVuc2l0eTogdGhpcy5vbGREaXNwbGF5RGVuc2l0eU9wdGlvbnMuZGlzcGxheURlbnNpdHksXG4gICAgICAgICAgICAgICAgbmV3RGVuc2l0eTogdGhpcy5kaXNwbGF5RGVuc2l0eU9wdGlvbnMuZGlzcGxheURlbnNpdHlcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHRoaXMub25EZW5zaXR5Q2hhbmdlZC5lbWl0KGRlbnNpdHlDaGFuZ2VkQXJncyk7XG4gICAgICAgICAgICB0aGlzLm9sZERpc3BsYXlEZW5zaXR5T3B0aW9ucyA9IE9iamVjdC5hc3NpZ24odGhpcy5vbGREaXNwbGF5RGVuc2l0eU9wdGlvbnMsIHRoaXMuZGlzcGxheURlbnNpdHlPcHRpb25zKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdpdmVuIGEgc3R5bGUgY2xhc3Mgb2YgYSBjb21wb25lbnQvZWxlbWVudCByZXR1cm5zIHRoZSBtb2RpZmllZCB2ZXJzaW9uIG9mIGl0IGJhc2VkXG4gICAgICogb24gdGhlIGN1cnJlbnQgZGlzcGxheSBkZW5zaXR5LlxuICAgICAqL1xuICAgIHByb3RlY3RlZCBnZXRDb21wb25lbnREZW5zaXR5Q2xhc3MoYmFzZVN0eWxlQ2xhc3M6IHN0cmluZyk6IHN0cmluZyB7XG4gICAgICAgIHN3aXRjaCAodGhpcy5kaXNwbGF5RGVuc2l0eSkge1xuICAgICAgICAgICAgY2FzZSBEaXNwbGF5RGVuc2l0eS5jb3N5OlxuICAgICAgICAgICAgICAgIHJldHVybiBgJHtiYXNlU3R5bGVDbGFzc30tLSR7RGlzcGxheURlbnNpdHkuY29zeX1gO1xuICAgICAgICAgICAgY2FzZSBEaXNwbGF5RGVuc2l0eS5jb21wYWN0OlxuICAgICAgICAgICAgICAgIHJldHVybiBgJHtiYXNlU3R5bGVDbGFzc30tLSR7RGlzcGxheURlbnNpdHkuY29tcGFjdH1gO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZXR1cm4gYmFzZVN0eWxlQ2xhc3M7XG4gICAgICAgIH1cbiAgICB9XG59XG4iXX0=